# The University of Manchester Physics and Astronomy Exam assessment code# Takes in CS exam grids (xlsx files) and produces output exam grids, with averages, degree classes etc.# taking into account the detailed rules (e.g. excluded units, promotion etc.).# This version is for AY2026 and is a re-write of previous versions## This Python script requires the following to be installed (e.g. using conda (preferred) or pip):# -Python v3.9 or above (tested on v3.11.3 which is preferred)# -numpy (tested on v1.24.3)# -pandas v1.5.3 or above (tested with v2.0.1 preferred)# -xlsxwriter (tested on v3.1.0 preferred)# -openpyxl (tested on v3.1.2 preferred) ### Immediate to-do list:# ---------------------## RE-WRITE! Intended Improvements:# 1. Remove old code or code for previous years.# 2. Clean up the codes part! Simplify it and use mark/EN/Mit Circ codes correctly (separately)# 3. Make more modular, including MPhys->BSc to go through all BSc functions.# 4. Resits - first line, just recreate, do not go through functions, except to add in the internal information as required# 5. Resits - run 2nd line through standard functions using simple rules (esp codes).# ## Known issues to keep in mind/future work:# ----------------------------------------#### MODIFICATION HISTORY:# --------------------## 24-Jun-2025  C. Dickinson    Begin re-write of PyAssess2025!#                              ################################################################## importsimport pandas as pdimport xlsxwriter#import openpyxl # (not used explicitly but needs to be installed for reading xlsx with pandas)import numpy as npimport sysimport copyimport os################################################################# MAIN INPUTS TO BE CHANGED################################################################# Set academic year (for filename and rules!)#AY = 2025  # for 2024/25AY = 2026  # for 2025/26# Define year (1=1st year, 2=2nd year, 31=3rd prog, 32=3rd complete ,4=4th year)classyear=4# Student type (1=Physics, 2=Math+Physics)studtype=1# Encode student IDs - if set to True (or 1) then encode the IDs, do not output names, and produce a look up table separatelyencode_sids = False# For testing non-complete grids with many missing marks, optionally fill the marks in (default=False)fill_marks = False# sort the output by score (yearmark/overall mark/status). If False, keeps same ordering as input (IDs will still match eitherway)# N.B. does not work for resit grids at the momentsort_output = False# check marks against input (if exists) and mark on output if different with '**'check_marks = False# check degree status against input (if exists) and print warning (to the screen) if notcheck_degree = False# do extreme marks - if set to True, compute extreme lo/hi year/overall marks for missing marks# for now, only works for Y3/Y4 final year students (switched off in get_extremes)if (classyear == 32 or classyear == 4 or classyear ==31): do_extremes = Trueelse: do_extremes = Falsedo_extremes = False    # Input directory for files (default is './' for current directory)indir = './'# Read in file for Y4 for students to get number of credits with marks < 40 to add to those in Y4# This was updated in 2025 to include 3 columns with more informationY3creds_filename = './data2025/y4-comp-and-L4-2025.xlsx'# Flag Carry Forward file - file containing students IDs and notes (e.g. for borderlines or other exceptions)# format is simply 2 columns and must be 2 columns. Can be multiple files separated by commas#flagCF_file = ''flagCF_file = './data2025/PHYS Carry forward.xlsx'# Input and output files for each cohort# Input filename (filename) can be .csv or .xls/.xlsx - the code will automatically read it in whichever the format if(classyear==1):    #filename = 'data2022/1st year exam grid_01.07.22_v3.xlsx'    #filename = 'resits 2021-22/Input grids/First Year_Resit Exam Grid_12.09_edited.xlsx'    #filename = 'data2023/Y1 - Input Grid.xlsx'    #filename = 'resits2023/PHYS_1221_Y1_RESIT_07.09.2023_StyleA_PLUS.xlsx'    if (studtype==1): filename = 'resits2024/PHYS_1231_Resit_Y1_Exam_Grids.xlsx'    else: filename = 'resits2024/PHYS_1231_Resit_Y1_MP_Exam_Grids.xlsx'    #filename = 'resits2023/PHYS_1221_Y1_RESIT_07.09.2023_StyleA_PLUS.xlsx'    #filename = 'resits2023/PHYS_1221 _Y1_Exam_Grids_Resit_08.09.2023.xlsx.xlsx'        # output filename    if (studtype==1): outfilename = '1styear_Physics.' + 'AY' + str(AY) + '.xlsx'   # Physics filename    else: outfilename = '1styear_MathsPhysics.' + 'AY' + str(AY) + '.xlsx'   # M+P filenameelif (classyear == 2):    #filename = 'data2022/2nd Year Exam Grid_01.07.22_v3.xlsx'    #filename = 'resits 2021-22/Input grids/Second Year_Resit Exam Grid_12.09_edited.xlsx'    #filename = 'data2023/Y2 - Input Grid.xlsx'    #filename = 'resits2023/PHYS_1221_Y2_RESIT_07.09.2020_StyleA_Plus.xlsx'    if (studtype == 1): filename = 'resits2024/PHYS_1231_Resit_Y2_Exam_Grids.xlsx'    else: filename = 'resits2024/PHYS_1231_Resit_Y2_MP_Exam_Grids.xlsx'    #filename = 'resits2023/PHYS_1221_Y2_RESIT_07.09.2020_StyleA_Plus.xlsx'    #filename = 'resits2023/PHYS_1221 _Y2_Exam_Grids_Resit_08.09.2023.xlsx.xlsx'    #filename = 'resits2023/PHYS_1221_Y2_Exam_Grids_Resit_08.09.2023-new.xlsx'    #filename = 'resits2024/MSE_1221_YR2_EXAM_GRIDS_RESIT.xlsm'        # output filename    if (studtype==1): outfilename = '2ndyear_Physics.' + 'AY' + str(AY) + '.xlsx'   # Physics filename    else: outfilename = '2ndyear_MathsPhysics.' + 'AY' + str(AY) + '.xlsx'   # M+P filenameelif(classyear==32):    #filename  = './data2022/3rd year exam grid_25.06.22_v2.xlsx'    #filename  = './data2023/Y3 - BSc - Input Grid.xlsx'     #filename  = './data2023/BSc-MAB.xlsx'    if (studtype==1): filename = 'data2025/PHYS_1241_S2_Y3_GRAD_Exam_Grids.xlsx'    else: filename = 'data2025/PHYS_1241_S2_Y3_MP_GRAD_Exam_Grids.xlsx'              # output filename    if (studtype==1): outfilename = 'FinalYear_BSc_Physics.' + 'AY' + str(AY) + '.xlsx'   # Physics filename    else: outfilename = 'FinalYear_BSc_MathsPhysics.' + 'AY' + str(AY) + '.xlsx'   # M+P filename    elif (classyear == 31):    #filename  = './data2022/3rd year exam grid_25.06.22_v2.xlsx'    #filename  = './data2023/NEW - STYLE A PLUS - Physics_Y3.xlsx'    #filename   = './data2023/Y3  - MPhys - Input Grid.xlsx'    if (studtype==1): filename  = 'data2025/PHYS_1241_S2_Y3_PROG_Exam_Grids.xlsx'    else: filename = 'data2025/PHYS_1241_S2_Y3_MP_PROG_Exam_Grids.xlsx'            # output filename    if (studtype==1): outfilename = '3rdyear_MPhys.' + 'AY' + str(AY) + '.xlsx'   # Physics filename    else: outfilename = '3rdyear_MMath.' + 'AY' + str(AY) + '.xlsx'   # M+P filename    elif(classyear==4):    #filename = './data2022/4th year exam grid_25.06.22_v2.xlsx'    #filename = './data2023/NEW - STYLE A PLUS - Physics_Y4.xlsx'    #filename = './data2023/Y4 - MPhys - Input Grid.xlsx'    if (studtype==1): filename = 'data2025/PHYS_1241_S2_Y4_Exam_Grids.xlsx'    else: filename = 'data2025/PHYS_1241_S2_Y4_MP_Exam_Grids.xlsx'              # output filename    if (studtype==1): outfilename = 'FinalYear_MPhys.' + 'AY' + str(AY) + '.xlsx'   # Physics filename    else: outfilename = 'FinalYear_MMath.' + 'AY' + str(AY) + '.xlsx'   # M+P filenameelse:    print('*ERROR: Classyear not defined correctly (should be 1, 2, 31, 32, or 4)')    sys.exit(0)################################################################# CLASS DEFINITIONS################################################################# class to include all student info, but start with most important info# and include defaults for important parametersclass StudentInfo:    def __init__(self,emplid,classyear):        # Most important inputs        self.emplid = emplid        self.classyear = classyear        # Default parameters (in case not set and is needed by a function later)        self.status          = 'ACTV'  # default status        self.anonymous       = False        self.someunitunder30 = False        self.resitstriggered = False        self.faillabprog     = False        self.fail            = False        self.passfail        = 'Pass' # default unless not true        self.failreason      = ''        self.referredcoursenames = ''        self.deferredcoursenames = ''        self.deferredcredits = 0        self.creditsexcluded = 0        self.referred_idx    = []        self.keep_referred_idx = []        self.deferred_idx    = []        self.excluded_idx    = []        self.excludedcoursenames = []        self.compensated_idx = []        self.XN_idx          = []        self.marks           = []        self.mark_codes      = []        self.en_codes        = []        self.mitcirc_codes   = []        self.p_mark_codes    = []        self.p_en_codes      = []        self.p_mitcirc_codes = []        self.marksout        = []        self.codesout        = []        self.p_marksout      = []        self.p_codesout      = []        self.year3mark = -1        self.Y3creds_below40 = 0  # number of Y3 credits with marks < 40 (for Y4 only)        self.Y3creds_below40_nomc = 0  # L3 credits below 40 not excluded with no MCs (Y4 only)         self.Y3creds_below40_mc = 0    # L3 credits below 40 excluded with MCs (Y4 only)        self.Y3creds4_passed = 0        # L4 credits passed in Y3 (Y4 only)        self.credits4total_passed = 0   # Total L4 credits passed (across Y3+Y4)        self.honours         = 1         self.demote          = False        self.borderline      = False        self.promote         = False        self.promotetype     = ''        self.repeating       = False        self.resitgrid       = False        self.secondpass      = False        self.secondattempt_idx = []        self.mphysstudent    = False        self.mathstudent     = False        self.PPstudent       = False        self.PHYS30810       = False        self.PPaway          = False        self.abroad          = False        self.interrupt       = False        self.Euro            = False        self.phys1           = -1        self.phys2           = -1        self.phys3           = -1        self.math1           = -1        self.math2           = -1        self.math3           = -1        self.L1CM            = -1        self.L2CM            = -1        self.L3CM            = -1        self.L4CM            = -1        self.dooverall       = False        self.degclass_alg    = ''        self.degclass_review = ''        self.degclass_actual = ''        self.boundary_notes  = ''        self.flagCF_notes    = ''        self.award           = ''        self.mc              = '' # ('Y' if MCC codes exist otherwise blank)        self.manual          = False        self.withdrawn       = False        self.input_yearmark  = -1        self.input_overallmark = -1        self.input_award     = ''        self.input_classification     = ''        self.classification  = ''        self.award           = ''        self.overallmark     = -1        self.overallmarkout  = '-1'        self.yearmark_not_consistent = False        self.overallmark_not_consistent = False        self.award_not_consistent = False        self.classification_not_consistent = False        self.lab_resit       = False        self.boundary_zone   = ''        self.preboard_notes  = ''        self.mphys_to_bsc    = False        self.progress        = True################################################################# FUNCTIONS################################################################################################################################# find the number of rows to skip before main data table# sheet_name is optional (provide the sheet name otherwise it will assume the 1st sheet)def find_skipnrows(filename,sheet_name=0):    # read all data in first    try:        if (filename.split('.')[-1] == 'csv'): df = pd.read_csv(filename, dtype='str',encoding = "ISO-8859-1")        else: df=pd.read_excel(filename,sheet_name=sheet_name, dtype='str')    except:        print('\nERROR reading the main input file (find_skipnrows()): {0:s}\nPlease check filename and/or directory and make sure it is xls/xlsx/csv format...\n'.format(filename))        print('If filename is ok, then there must be an issue with reading the file in via pandas...')        sys.exit(0)    # clean up dataframe of NaNs but leave Unnamed columns for now       df = df.replace(np.nan, '', regex=True)  # Remove NaNs    df = df.replace('\xa0', '', regex=True)  # Remove any unicode non-breakable space ('\ax0')        # find row where data starts    trycols = [1]  # try a few columns to make sure this is where the data starts    skipnrows = 0    for i in trycols:        col = df.iloc[:,i].to_list()        for j in np.arange(len(col)):            if (col[j] != ''):                nrows = j                break        if (nrows > skipnrows): skipnrows = nrows    skipnrows += 1 # to skip the required number of rows                return skipnrows################################################################# read in student data (usually from an excel (.xlsx) file but can be csv)# The correct data usually first input sheetdef read_data(filename, studtype):    # first check file is actually there    if (os.path.exists(filename) == False):        print('\nERROR: Input file: {0:s}\ndoes not appear to exist! Check filename!\n'.format(filename))        sys.exit(0)            try:        # must be "PyAssess" sheet name or the first input sheet if not         sheet_names = pd.ExcelFile(filename).sheet_names   # get sheet names                if (len(sheet_names) == 1): # if only one sheet use that            sheet_name = 0            print('\nOnly 1 sheet in the Excel file, so using that...\n')        elif (len(sheet_names) > 1): # if more than one look for "PyAssess"            if (studtype == 1): # for physics students                sheet_name = [s for s in sheet_names if (s.lower().find('phys') >= 0 and s.lower().find('mp') < 0)] # get matching sheet_name            elif (studtype == 2): # M+P students                sheet_name = [s for s in sheet_names if (s.lower().find('mp') >= 0)] # get matching sheet_names            if (classyear == 31): # for progressing 3rd year                sheet_name = [s for s in sheet_name if (s.lower().find('prog') >= 0)] # get matching sheet_names            if (classyear == 32): # for graduating 3rd year                sheet_name = [s for s in sheet_name if (s.lower().find('grad') >= 0)] # get matching sheet_names            if (len(sheet_name) > 1): # if more than one that match (!), take the first one but give a warning                sheet_name = str(sheet_name[0])  # take the 1st matching one anyway                print('\nWARNING: There is more than 1 sheet matching "PHYS"/"MP" - using the first one: {0:s} (Please check it is the correct one...)'.format(str(sheet_name)))            else:                sheet_name = sheet_names[0]      #  just take the 1st                print('\nWARNING: Using the first sheet: {0:s} (Please check it is the correct one...)'.format(str(sheet_name)))                        skipnrows = find_skipnrows(filename, sheet_name=sheet_name)  # get number of rows to skip                if (filename.split('.')[-1] == 'csv'): df = pd.read_csv(filename, skiprows=skipnrows, dtype='str',encoding = "ISO-8859-1")        else: df=pd.read_excel(filename,skiprows=skipnrows,dtype='str', sheet_name=sheet_name)        print('\nRead in main input file OK: {0:s}\n'.format(filename))    except:        print('ERROR reading the main input file: {0:s}\nMake sure it is xls/xlsx/csv format...\n'.format(filename))        print('If filename is ok then there must be an issue with reading the file in via pandas (also make sure no active filters set)...')        sys.exit(0)    # clean up dataframe of NaNs but leave Unnamed columns for now       df = df.replace(np.nan, '', regex=True)  # Remove NaNs    df = df.replace('\xa0', '', regex=True)  # Remove any unicode non-breakable space ('\ax0')    # just to be 100% certain, remove 'Award'/'Classification' since these are populated later in CS with real awards    # but sometimes they are incorrect and we don't want them getting in here at all!    # (We override 'Award' later but still, just in case something changes....)    #columns = df.columns.to_list()    #idx = [i for i, s in enumerate(columns) if s == 'Award']    #if (len(idx) == 1):    #    df.drop(columns=columns[idx[0]], inplace=True)    #idx = [i for i, s in enumerate(columns) if s == 'Classification']    #if (len(idx) == 1):    #    df.drop(columns=columns[idx[0]], inplace=True)                # reindex from 0 to N to ensure no gaps    #df = df.reindex(df)        return df################################################################# Remove Unnamed ('^Unnamed') columns from the dataframedef remove_unnamed_columns(df):    return df.loc[:, ~df.columns.str.contains('^Unnamed')]   # remove Unnamed columns################################################################# Check column names are standard and change as necessary# This function also converts 1-line Module/Mark/EN to old-style 2-line Unit (for AY>=2024)def check_column_names(df):    columnnames = df.columns.to_list()    # Make sure they are all strings!    for i in range(len(columnnames)):        columnnames[i] = str(columnnames[i])    df.columns = columnnames            # check that Emplid is there    if ('Emplid' not in columnnames):        if ('id' in columnnames): df.rename(columns={'id':'Emplid'}, inplace=True)        elif ('ID' in columnnames): df.rename(columns={'ID':'Emplid'}, inplace=True)        elif ('sid' in columnnames): df.rename(columns={'sid':'Emplid'}, inplace=True)        elif ('SID' in columnnames): df.rename(columns={'SID':'Emplid'}, inplace=True)        elif ('uid' in columnnames): df.rename(columns={'uid':'Emplid'}, inplace=True)        elif ('UID' in columnnames): df.rename(columns={'UID':'Emplid'}, inplace=True)        else: print('*WARNING: ''Emplid'' not in the header')    # Get ID number if it exists    if ('ID\nNo.' in columnnames):        df.rename(columns={'ID\nNo.':'ID No.'}, inplace=True)                # check that Plan is there    if ('Plan' not in columnnames):        if ('Prog' in columnnames): df.rename(columns={'Prog':'Plan'}, inplace=True)        elif ('Prog.' in columnnames): df.rename(columns={'Prog.':'Plan'}, inplace=True)        elif ('Programme' in columnnames): df.rename(columns={'Programme':'Plan'}, inplace=True)        else: print('*WARNING: ''Plan'' not in the header')    # If additional unnecessary rows/indices remove and re-index    df.dropna(axis=0,how='all',inplace=True,ignore_index=True)                # If duplicated Names/Emplid (e.g. faculty CS resit 3-line grids) then remove the extra names/emplids/plans etc.    emplids = df.loc[:,'Emplid'].to_list()    duplicate_idx = [idx for idx, val in enumerate(emplids) if val in emplids[:idx]]    for idx in duplicate_idx:        df.loc[idx,'Emplid'] = ''        df.loc[idx,'Name']   = ''        df.loc[idx,'Plan']   = ''    # determine if 1-line (faculty CS), 2-line (old-style but used by the rest of this code), 3-line (resits)    names = df.loc[:,"Name"].to_list()    names_idx = [i for i, s in enumerate(names) if s != '']    diff_idx  = list(np.diff(names_idx))    nrows_per_student = max(set(diff_idx), key=diff_idx.count)  # most common value    if (nrows_per_student == 0 or nrows_per_student > 3):        print('*ERROR: cannot determine number of rows per student (1/2/3)...usually lack of data...\n')        sys.exit(0)        # if 3-lines, must be a resit grid    if (nrows_per_student == 3):         resitgrid = True    else:        resitgrid = False    # first drop unwanted columns in between module and mark (usually "Link" columns for excel linking)    remove_cols = [s for s in columnnames if (s.lower().find('link') >=0)]    df.drop(remove_cols, axis=1, inplace=True)    columnnames = df.columns.to_list()  # update column names list    # remove Module2 columns if they exist    remove_cols = [s for s in columnnames if (s.lower().find('module2') >=0)]    df.drop(remove_cols, axis=1, inplace=True)    columnnames = df.columns.to_list()  # update column names list    # remove GBN columns if they exist    remove_cols = [s for s in columnnames if (s.lower().find('gbn') >=0)]    df.drop(remove_cols, axis=1, inplace=True)    columnnames = df.columns.to_list()  # update column names list    # remove AM1/AM2/AM3 columns if they exist    remove_cols = [s for s in columnnames if (s.lower().find('am1') >=0 or s.lower().find('am2') >=0 or s.lower().find('am3') >=0 or s.lower().find('am4') >=0)]    df.drop(remove_cols, axis=1, inplace=True)    columnnames = df.columns.to_list()  # update column names list            # get columns with module names    module_cols_idx = [i for i, s in enumerate(columnnames) if (s.lower().find('module') >= 0)]    module_cols = [columnnames[i] for i in module_cols_idx]    nmodules = len(module_cols)    # for the other columns, there should only be one for each module so rename using dictionaries    unit_dict = {'Module':'Unit 1', 'Module.1':'Unit 2', 'Module.2':'Unit 3', 'Module.3':'Unit 4', 'Module.4':'Unit 5', 'Module.5':'Unit 6', 'Module.6':'Unit 7', 'Module.7':'Unit 8', 'Module.8':'Unit 9', 'Module.9':'Unit 10', 'Module.10':'Unit 11', 'Module.11':'Unit 12', 'Module.12':'Unit 13', 'Module.13':'Unit 14', 'Module.14':'Unit 15', 'Module.15':'Unit 16', 'Module.16':'Unit 17', 'Module.17':'Unit 18', 'Module.18':'Unit 19', 'Module.19':'Unit 20'}    en_dict = {'EN':'EN 1', 'EN.1':'EN 2', 'EN.2':'EN 3', 'EN.3':'EN 4', 'EN.4':'EN 5', 'EN.5':'EN 6', 'EN.6':'EN 7', 'EN.7':'EN 8', 'EN.8':'EN 9', 'EN.9':'EN 10', 'EN.10':'EN 11', 'EN.11':'EN 12', 'EN.12':'EN 13', 'EN.13':'EN 14', 'EN.14':'EN 15', 'EN.15':'EN 16', 'EN.16':'EN 17', 'EN.17':'EN 18', 'EN.18':'EN 19', 'EN.19':'EN 20'}    mitcirc_dict = {'Mit\nCircs':'Mit\nCircs 1', 'Mit\nCircs.1':'Mit\nCircs 2', 'Mit\nCircs.2':'Mit\nCircs 3', 'Mit\nCircs.3':'Mit\nCircs 4', 'Mit\nCircs.4':'Mit\nCircs 5', 'Mit\nCircs.5':'Mit\nCircs 6', 'Mit\nCircs.6':'Mit\nCircs 7', 'Mit\nCircs.7':'Mit\nCircs 8', 'Mit\nCircs.8':'Mit\nCircs 9', 'Mit\nCircs.9':'Mit\nCircs 10', 'Mit\nCircs.10':'Mit\nCircs 11', 'Mit\nCircs.11':'Mit\nCircs 12', 'Mit\nCircs.12':'Mit\nCircs 13', 'Mit\nCircs.13':'Mit\nCircs 14', 'Mit\nCircs.14':'Mit\nCircs 15', 'Mit\nCircs.15':'Mit\nCircs 16', 'Mit\nCircs.16':'Mit\nCircs 17', 'Mit\nCircs.17':'Mit\nCircs 18', 'Mit\nCircs.18':'Mit\nCircs 19', 'Mit\nCircs.19':'Mit\nCircs 20'}    # just got the dict entries required    unit_dict = {k: unit_dict[k] for k in list(unit_dict)[:nmodules]}    en_dict = {k: en_dict[k] for k in list(en_dict)[:nmodules]}    mitcirc_dict = {k: mitcirc_dict[k] for k in list(mitcirc_dict)[:nmodules]}    # rename all columns in the dictionaries    df.rename(columns=unit_dict, inplace=True)    df.rename(columns=en_dict, inplace=True)    df.rename(columns=mitcirc_dict, inplace=True)        # for 1-line per student (not resits)    if (nrows_per_student == 1):                mark_dict = {}        # get the columns with marks but only those immediately after module (only take this one)        for i in range(nmodules):            idx = module_cols_idx[i]            oldname = df.columns.values[idx+1]            newname = 'Mark ' + str(i+1)            mark_dict[oldname] = newname        # rename mark columns using dictionary        df.rename(columns=mark_dict, inplace=True)        # Now convert to 2 lines as per old format to allow rest of code to work seamlessly ;-)                # 1. Add blank row after each student        df.index = range(0, 2*len(df), 2)        df2 = df.reindex(index=range(2*len(df)), copy=True)                # 2. Add mark/EN codes below coursename in each Unit column - also includes Mit Circs to be added together (if exists)        mitcirc_colname = [s for s in columnnames if (s.lower().find('circ') >= 0)]        if (len(mitcirc_colname) == 0):            print('No Mit Circ column found in main input file - ensure you are using an external MCC file...\n')        else:            mitcirc_colname = mitcirc_colname[0]  # take the 1st one            for i in np.arange(0,len(df2),2):                for j in np.arange(nmodules)+1:                    df2.loc[i+1, 'Unit ' + str(j)] = df2.loc[i, 'Mark ' + str(j)]                    en_col_str = 'EN ' + str(j)                    df2.loc[i+1, en_col_str] = df2.loc[i, en_col_str]  # put in EN                     df2.loc[i,en_col_str] = ''  # blank EN on top row                    mit_col_str = mitcirc_colname + ' ' + str(j)                         df2.loc[i+1, mit_col_str] = df2.loc[i, mit_col_str]  # put in Mit Circ                    df2.loc[i,mit_col_str] = ''  # blank Mit. Circ on top row                        # 3. Remove Mark columns (so that EN is the next column after each mark)        mark_cols = list(mark_dict.values())         df2.drop(mark_cols, axis=1, inplace=True)                # clean up dataframe of NaNs but leave Unnamed columns for now           df2 = df2.replace(np.nan, '', regex=True)  # Remove NaNs        df2 = df2.replace('\xa0', '', regex=True)  # Remove any unicode non-breakable space ('\ax0')        # change back to df to return        df = df2.copy()    # make old-style 3-line format from new CS faculty 3-line format so to allow rest of code to work seamlessly ;-)    if (nrows_per_student == 3):        df2 = df.copy()        # make sure df has rows that are multiple of 3        #rem = len(df2)%3        #row = df2.loc[len(df2)-1,:]        #for i in range(rem):        #    df2 = pd.concat([df2, row],axis=1,ignore_index=True)        #df2 = df2.replace(np.nan, '', regex=True)  # Remove NaNs from new rows                    # add mark/EN codes below coursename in each Unit column - also inlcude Mit Circs to be added together (if exists)        mitcirc_colname = [s for s in columnnames if (s.lower().find('circ') >= 0)]        if (len(mitcirc_colname) == 0):            print('No Mit Circ column found in main input file - ensure you are using an external MCC file...\n')        else:            mitcirc_colname = mitcirc_colname[0]  # take the 1st one            for i in np.arange(0,len(df2),3):                for j in np.arange(nmodules)+1:                    if (df2.loc[i,'Emplid'] == ''): # if past students list on spreadsheet, don't continue                        continue                    en_col_str = 'EN ' + str(j)                    mit_col_str = mitcirc_colname + ' ' + str(j)                    df2.loc[i,en_col_str] = ''  # blank EN top row                    df2.loc[i,mit_col_str] = '' # blank Mit circ top row                    # Fill data for 2nd row                    #if (df2.loc[i+1,en_col_str] != '' and df2.loc[i+1,mit_col_str] != ''):                    #    df2.loc[i+1,en_col_str] += '_' + df2.loc[i+1,mit_col_str]                    #elif (df2.loc[i+1,mit_col_str] != ''):                    #    df2.loc[i+1,en_col_str] = df2.loc[i+1,mit_col_str]                    # Fill data for 2nd row                    #if (df2.loc[i+2,en_col_str] != '' and df2.loc[i+2,mit_col_str] != ''):                    #    df2.loc[i+2,en_col_str] += '_' + df2.loc[i+2,mit_col_str]                    #elif (df2.loc[i+2,mit_col_str] != ''):                    #    df2.loc[i+2,en_col_str] = df2.loc[i+2,mit_col_str]                            # clean up dataframe of NaNs but leave Unnamed columns for now           df2 = df2.replace(np.nan, '', regex=True)  # Remove NaNs        df2 = df2.replace('\xa0', '', regex=True)  # Remove any unicode non-breakable space ('\ax0')        # change back to df to return        df = df2.copy()            # for resits that have specific names convert to unit numbers    #keys = list(unitcolumns_dict.keys())    #for i in np.arange(len(keys)):    #    key = keys[i]    #    if (key in columnnames): df.rename(columns={key:'Unit {0:d}'.format(i)}, inplace=True)    return df, resitgrid  ################################################################# function to read in Flag Carry Forward notes# N.B. will assume 3 columns - Emplid, Name,Flag Carry Forward and can be on multiple sheetsdef read_flagCF_file_multisheet(flagCF_file):    if (flagCF_file == ''): # do nothing if notes_filename does not exist        return None    #if multiple files (separated by commas, loop over each one    filenames = flagCF_file.split(',')    nfiles    = len(filenames)    dfs = []  # list of dataframes        for filename in filenames:        if (os.path.exists(filename) == False):            print('\nERROR: flagCF notes file: {0:s}\ndoes not appear to exist!\nCheck filename!\n'.format(filename))            print('Continuing on without flagCF notes...\n')            return None                try:            sheet_names = pd.ExcelFile(filename).sheet_names   # get sheet names            print('Read in flagCF notes file {0:s}\n'.format(filename))        except:            print('ERROR: flagCF note files {0:s} cannot be read in - check xlsx format...\n'.format(filename))            print('\nContinuing on without flagCF notes...\n')            return None                    # loop over each sheet        df_sheets = []        for sheet_name in sheet_names:                        try:                df=pd.read_excel(filename,dtype='str', sheet_name=sheet_name)                print('Read in sheet of flagCF notes file: {0:s}\n'.format(sheet_name))            except:                print('ERROR: flagCF note files {0:s} cannot be read in - check xlsx format...\n'.format(filename))                print('\nContinuing on without flagCF notes...\n')                return None                            # get just the key columns and give them a standard label            columns = df.columns.to_list()            ncolumns = len(columns)            # check number of columns            if (ncolumns < 3):                print('\nERROR with flagCF notes file: {0:s}\n Only {1:d} columns when there should be 3 at least!\n'.format(filename, ncolumns))            elif (ncolumns > 4):                print('WARNING: more than 3 columns in flagCF file: {0:s} (using the columns 1 (UID) and 3 (Carry Forward))\n'.format(filename))                        # now make df with just the 3 required columns with the exact same names ready for concatenation            column_names = ['ID', 'Name', 'Flag Carry Forward']  # new column names                        df.rename(columns={columns[0]:column_names[0], columns[1]:column_names[1], columns[2]:column_names[2]},inplace=True) # rename cols with standard names            df = df[column_names].copy()   # new dataframe with just 3 columns            # append to df containing info from multiple sheets            df_sheets.append(df)        # concatenate the lists        df = pd.concat(df_sheets, axis=0, ignore_index=True, sort=False)                    # clean up dataframe of NaNs         df = df.replace(np.nan, '', regex=True)  # Remove NaNs        df = df.replace('\xa0', '', regex=True)  # Remove any unicode non-breakable space ('\ax0')        # add df to list, ready to concatanate        dfs.append(df)    # concatenate    df = pd.concat(dfs, axis=0, ignore_index=True, sort=False)        return df################################################################# function to read in list of Y3 credits failed with/without MCs and L4 passed in Y3def read_Y3creds_file(filename):    if (filename == '' or classyear != 4): # do nothing if interrupting_filename does not exist or if not Y4        return None    if (os.path.exists(filename) == False):        print('\nERROR: Y3creds_file:  {0:s}\ndoes not appear to exist! Check filename!\n'.format(filename))        print('Continuing on without this information!...\n')        return None    sheet_name = 'summary'  # This is the sheet name that should be there (change as necessary) otherwise first sheet will be used    # check file is xlsx foramt    try:        sheet_names = pd.ExcelFile(filename).sheet_names        print('Read in Y3creds_file file OK: {0:s}\n'.format(filename))    except:        print('ERROR reading in Y3creds_file: {0:s} Check xlsx format!\n'.format(filename))        print('Continuing on without this information!...\n')        return None        # read in the sheet data    if (sheet_name in sheet_names):        skipnrows = find_skipnrows(filename, sheet_name=sheet_name)  # get number of rows to skip         df=pd.read_excel(filename,dtype='str', sheet_name=sheet_name, skiprows=skipnrows)   # read expected sheet name from above        print('Read in Y3creds_file  file OK: {0:s}\n'.format(filename))    else:        skipnrows = find_skipnrows(filename, sheet_name=0)  # get number of rows to skip         df=pd.read_excel(filename,dtype='str', sheet_name=0, skiprows=skipnrows)   # otherwise assume 1st one        print('Read in Y3creds_file  file OK: {0:s} BUT assuming 1st sheet ({1:s}) (CHECK THIS IS CORRECT!)\n'.format(filename,sheet_names[0]))            # get just the key columns and give them a standard label    columns = df.columns.to_list()    col1 = [columns[0]] # assume 1st is UID    col2 = [s for s in columns if (s.lower().find('fail') >=0 and s.lower().find('excluded') >=0 and s.lower().find('not') >=0) ]    col3 = [s for s in columns if (s.lower().find('fail') >=0 and s.lower().find('excluded') >=0 and s.lower().find('not') < 0) ]    col4 = [s for s in columns if (s.lower().find('4') >=0 and s.lower().find('pass') >=0) ]    print(columns)    print(col1, col2, col3, col4)        # check if columns exist at all otherwise return None and give warning    if (len(col2) == 0):        print('WARNING: Y3creds_file column not as expected - assuming column 3\n')        col2 = columns[2]    if (len(col3) == 0):        print('WARNING: Y3creds_file column not as expected - assuming column 4\n')        col2 = columns[3]    if (len(col4) == 0):        print('WARNING: Y3creds_file column not as expected - assuming column 5\n')        col2 = columns[4]            if (columns.index(col2[0]) != 2):        print('WARNING: Y3creds_file unexpected column numbers - check to be sure!\n')    if (columns.index(col3[0]) != 3):        print('WARNING: Y3creds_file unexpected column numbers - check to be sure!\n')    if (columns.index(col4[0]) != 4):        print('WARNING: Y3creds_file unexpected column numbers - check to be sure!\n')            # output only required columns and output standard column names    column_names = ['ID', 'Y3 fails not excluded', 'Y3 fails with MCs, excluded', 'L4 passed in Y3']  # new column names                df.rename(columns={col1[0]:column_names[0], col2[0]:column_names[1], col3[0]:column_names[2], col4[0]:column_names[3]},inplace=True) # rename cols with standard names    df = df[column_names].copy()   # new dataframe with just 3 columns            # clean up dataframe of NaNs     df = df.replace(np.nan, '', regex=True)  # Remove NaNs    df = df.replace('\xa0', '', regex=True)  # Remove any unicode non-breakable space ('\ax0')    return df################################################################# see if is an interrupting studentdef get_interrupt(Info, df,interrupting_students):    # Interrupting students can be identified from separate file or (hard-coded) list - check this first!    if (Info.emplid in interrupting_students):        Info.interrupt = True            # if no df_interrupt, see if student is in interrupting_students array, otherwise just return    if (df is None):        return Info    # Otherwise, see if student is in df_interrupt    columns = df.columns.to_list()    col = [s for s in columns if (s.lower().find('id') >=0)]            if (Info.emplid in df[col[0]].to_list()):        Info.interrupt = True        print('Interrupting student!')            return Info################################################################# see if is student is in then "for manual completion" listdef get_manual(Info, manual_students):    # Interrupting students can be identified from separate file or (hard-coded) list - check this first!    if (Info.emplid in manual_students):        if (Info.resitgrid == True and Info.secondpass == False):            Info.manual = False        else: # for when main grid (1st pass) or resit grid (2nd pass)            Info.manual = True            print('For manual completion (insufficient/incorrect data)')            return Info################################################################# extract relevant students from df to another df by typedef extract_students_by_type(df,classyear,studtype,resitgrid):                  # get indices of relevant students    if (classyear == 1 or classyear == 2 or classyear == 4):        if (studtype == 1):            idx = df.index[(df['Plan'].str.contains('MPhys')) | (df['Plan'].str.contains('BSc')) & (~df['Plan'].str.contains('Math'))]        else:            idx = df.index[(df['Plan'].str.contains('Math'))]                if(classyear==31):        if (studtype == 1):            idx = df.index[(df['Plan'].str.contains('MPhys')) & (~df['Plan'].str.contains('Math'))]        else:            idx = df.index[(df['Plan'].str.contains('MMath'))]    #  Select BScs without math    if(classyear==32):        if(studtype==1):            idx = df.index[(df['Plan'].str.contains('BSc')) & (df['Plan'].str.contains('Phys')) & (~df['Plan'].str.contains('Math'))]        else:            idx = df.index[(df['Plan'].str.contains('BSc')) & (df['Plan'].str.contains('Math'))]                # If no students, return and give warning    if (len(idx) == 0):        print('\n*ERROR: No students found - check inputs and that studtype is correct (1=Physics, 2=M+P)\n')        sys.exit(0)                # add indices for the 2nd row of each student record    idx2 = []   # array of full indices    idx = idx.to_list()  # array of the first row index    for i in range(len(idx)):        idx2.append(idx[i])        idx2.append(idx[i]+1)        if (resitgrid):  # add 3rd row index if not on next student            idx2.append(idx[i]+2)            dfstudents = df.iloc[idx2]    # extract all the relevant rows    dfstudents.reindex()          # reindex to ensure it is contiguous for later        return dfstudents################################################################# get all student ids from a dataframedef get_sids(df):        sids = df.loc[:,'Emplid']        if (sids.size < 1):        print('No student IDs found...check file and column for SIDs (should be the 1st column called Emplid or UID or SID or similar)')        sys.exit(0)    sids = sids.to_list()  # make a list    sids = list(filter(None,sids))    # remove empty strings    # also remove any unicode non-breaking spaces (e.g. '\xa0') which can sometimes appear out of nowhere!    # not needed now - removed at the beginning in the allstudents dataframe    #sids = [x.strip() for x in sids]  # remove any spaces ('\xa0' -> '')    #sids_cleaned = [x for x in sids if x != '']  # remove any blank elements ('')                return sids################################################################def get_dfstudent(df,sid,resitgrid):        dfstudent=df.loc[df['Emplid'] == sid]  # select row with studentID= target    index=dfstudent.index.to_list()          # get index number of this row    dfstudent1 = df.loc[df.index == index[0]]    dfstudent2 = df.loc[df.index == index[0]+1]        dfstudent = pd.concat([dfstudent1, dfstudent2])    # if resit student get 3rd row    if (resitgrid == True):        dfstudent3 = df.loc[df.index == index[0]+2]        dfstudent = pd.concat([dfstudent, dfstudent3])  # add extra row to df            dfstudent.reindex()        return dfstudent################################################################# Make Info student record class filling with basic marks etc.# Ignores courses that are in ignore_coursesdef make_Info(df,anid,classyear,ignore_courses,AY, fill_marks=False):    columns = df.columns.to_list() # get columns        Info = StudentInfo(anid,classyear)            # Make Info record and add SID/classyear    Info.Plan = df["Plan"].values[0]    # Add Plan    Info.AY   = AY                      # Add academic year    if ('ID No.' in columns):        Info.IDnumber = df['ID No.'].values[0]  # ID number from input sheet (if exists)    else:        Info.IDnumber = ''   # otherwise just blank        # Determine if progressing or finalyear    if (classyear == 32 or classyear == 4):        Info.finalyear = True    else:        Info.finalyear = False        # Determine if M+P student    if ('math' in Info.Plan.lower()):        Info.mathstudent = True    else:        Info.mathstudent = False            # Determine if MPhys student    if ('mphys' in Info.Plan.lower() or 'Mp' in Info.Plan or 'MM' in Info.Plan):        Info.mphysstudent = True    else:        Info.mphysstudent = False    # determine if a PP (professional placement) student although this doesn't catch all - look for PHYS30810 later!!!    if ('PP' in Info.Plan):        Info.PPstudent = True        Info.PPpass    = -1  # no info at moment    else:        Info.PPstudent = False            # determine if resitting - which means there is a 3rd row    if (len(df) == 3):        Info.resitgrid = True    else:        Info.resitgrid = False    # Determine if an "abroad" student (usually in Y3) via programme name    # but also have to hard-code some below because we can't always tell (e.g. plan MPhys Physics can go abroad)    if (Info.mphysstudent == True and Info.mathstudent == False and 'study' in Info.Plan.lower()):        Info.abroad = True    if ('3A' in Info.Plan or '[A]' in Info.Plan or 'Eu' in Info.Plan): # Physics with Study in Europe        Info.abroad = True        Info.Euro   = True    # Make sure all abroad students are identidied from separate (hard-coded) list    # (because we can't always tell (e.g. plan MPhys Physics can go abroad)     if (Info.emplid in abroad_students):        Info.abroad = True            # add in simple information from input data    if ("Name" in columns):        Info.Name = df["Name"].values[0] # add Name if available    else: Info.anonymous = True  # anonymous file    # Admitted Term    if ("Admit Term" in columns):        Info.admitterm = df["Admit Term"].values[0]    elif ("Admit\nTerm" in columns):        Info.admitterm = df["Admit\nTerm"].values[0]    # Boundary Zone (if exists)    if ("BZ" in columns):        Info.boundary_zone = df["BZ"].values[0]            # Credits taken/passed    if ("Units\nTaken" in columns): Info.UnitsTaken = df["Units\nTaken"].values[0]    if ("Units\nPassed" in columns): Info.UnitsTaken = df["Units\nPassed"].values[0]    # AS (status) code    if ("AS Code" in columns): Info.AScode = df["AS Code"].values[0]    # Overall mark (Deg GPA)    if ("Deg.\nGPA" in columns):        Info.input_overallmark = df["Deg.\nGPA"].values[0]        if (Info.input_overallmark == ''):            Info.input_overallmark = -1        else:            Info.input_overallmark = float(Info.input_overallmark)            # Degree award and classification    if ('Award' in columns):        Info.input_award = df["Award"].values[0]    if ('Classification' in columns):        Info.input_classification = df["Classification"].values[0]    # Pre-Exam board minutes    if ('Pre-Exam Board\nMinutes' in columns):        Info.preboard_notes = df["Pre-Exam Board\nMinutes"].values[0]            # If previous year marks exist in the file (from 2023) store them separately    # and into phys1, phys2 etc.    # also copy to math1, math2 to ensure maths overall average is correct    if ("Pr. Yr Mk\n/ GPA" in columns and Info.classyear == 2): # If Y2 resit grid it may only have this one        Info.dooverall = True        try:            Info.L1CM = float(df["Pr. Yr Mk\n/ GPA"].values[0])            Info.L1CM  = round(Info.L1CM+0.000001,1)  # round to 1 d.p. in case not already in the input!            Info.phys1 = Info.L1CM            Info.math1 = Info.phys1        except:            Info.L1CM = -1            Info.phys1 = -1            if ("L1CM" in columns):  # more generally         Info.dooverall = True  # for later on to ensure it is outputted at the end        try:            Info.L1CM = float(df["L1CM"].values[0])            Info.L1CM  = round(Info.L1CM+0.000001,1)  # round to 1 d.p. in case not already in the input!            Info.phys1 = Info.L1CM            Info.math1 = Info.phys1        except:            Info.L1CM = -1            Info.phys1 = -1    if ("L2CM" in columns):        try:            Info.L2CM = float(df["L2CM"].values[0])            Info.L2CM  = round(Info.L2CM+0.000001,1)  # round to 1 d.p. in case not already in the input!            Info.phys2 = Info.L2CM            Info.math2 = Info.phys2        except:            Info.L2CM = -1            Info.phys2 = -1    if ("L3CM" in columns):        try:            Info.L3CM = float(df["L3CM"].values[0])            Info.L3CM = round(Info.L3CM+0.000001,1)  # round to 1 d.p. in case not already in the input!            Info.phys3 = Info.L3CM            Info.year3mark = Info.phys3  # to ensure overall mark is calculated correctly        except:            Info.L3CM = -1            Info.phys3 = -1    if ("L4CM" in columns):        try:            Info.L4CM = float(df["L4CM"].values[0])            Info.L4CM = round(Info.L4CM+0.000001,1)  # round to 1 d.p. in case not already in the input!        except:            Info.L4CM = -1            # Reset the last phys1/2/3/4 if a repeating student    # Unfortunately, not reliable, because L1CM for the *current* year gets populated later (and is sometimes there anyway!)    #if (Info.classyear == 1 and Info.L1CM > -1):    #    Info.phys1 = -1    #    Info.repeating = True    #if (Info.classyear == 2 and Info.L2CM > -1):    #    Info.phys2 = -1    #    Info.repeating = True    #if ((Info.classyear == 31 or Info.classyear == 32) and Info.L3CM > -1):    #    Info.phys3 = -1    #    Info.year3mark = -1    #    Info.repeating = True    #if (Info.classyear == 4 and Info.L4CM > -1):    #    Info.phys4 = -1    #    Info.repeating = True                # add all the Unit information including codes    columns = df.filter(regex='^Unit\ ',axis=1).columns.to_list()  # just unit columns    coursenames = []    coursenamesout = []    marks = []    marksout = []   # string for output marks (including potentially codes etc)    mark_codes = []    codesout = []    credits = []    en_codes = []    mitcirc_codes = []        # loop over each Unit column    for col in columns:        data = df.loc[:,col].values  # get main data        coursename = data[0][0:9] # coursename is first 10 characters                if (len(coursename) < 5 or coursename in ignore_courses):  # move on if blank            continue        # get unit number        unit_number = int(col.split()[1])                # credits        lbindex = data[0].find('(')        rbindex = data[0].find(')')        thiscredit = int(data[0][lbindex + 1:rbindex])                # Get codes for any courses        idx = df.columns.get_loc(col)  # get indices of column with potential codes        en_code = df['EN ' + str(unit_number)].values[1]        mitcirc_code = df['Mit\nCircs ' + str(unit_number)].values[1]                # add mark and get code string        mark_str = str(data[1])        #print(mark_str, code)        # blank mark code unless it is set below        mark_code = ''                # for testing non-complete grids with missing marks, optionally add in marks for checking codes/decisions etc.        if (fill_marks == True and mark_str == ''):            mark_str = '50'                try:  # if just a number (usually is)            mark = round(float(mark_str)+0.000001) # mark as a (rounded) integer            markout = str(mark) # *keep as integer in the end (remove str()) when this is not used later                except: # if not just a number and code            if (mark_str == ''): # if empty                mark = -1                markout = ''                print('*WARNING: No mark for {0:s} ({1:s})'.format(coursename,mark_str))            elif (mark_str[0].isnumeric() == True):  # if XXC or XXR or XX_X get numerical mark                mark = round(float(''.join([c for c in mark_str if c.isdigit()])))  # get only numerical values                mark_code = ''.join([c for c in mark_str if not c.isdigit()]) # get any code with the mark                markout = str(mark)  + mark_code  # with markcode for reproduction                 if (mark_code == 'R' and Info.resitgrid == False): Info.repeating = True  # if capped resit, repeating student            else: # no numerical mark but not empty!                markout = mark_str  # output the code (e.g. PRO) even though no mark                mark = -1                # warning only if is going to be non-0 credit weighted (and not PHYS30810 with 120 credits)                if ((thiscredit > 0 and thiscredit < 100) or coursename in generalpapers):                     print('*WARNING: No mark for {0:s} ({1:s})'.format(coursename,mark_str))                elif (thiscredit == 0):                    markout = 'AUD'   # likely a student has signed up but not taking the exam                            # If no mark, mark as a blank (if want "PRO" etc. to be re-produced, comment out lines below)        #if (mark == -1):        #    markout = ''        # Combine EN and Mit Circ codes for now (maybe deal with later)        if (en_code == ''):            codeout = mitcirc_code        else:            codeout = en_code + ' ' + mitcirc_code                    # Check again for PP students by looking for PHYS30810 and see whether on placement or not        if (coursename == 'PHYS30810'):            Info.PHYS30810 = True            Info.PPstudent = True            # get PHYS30810 pass/fail if available            if (mark_str.find('P') >=0):                Info.PPpass = True                markout = 'P'                Info.PPaway = False            elif (mark_str.find('F') >=0):                Info.PPpass = False                markout = 'F'                Info.PPaway = False                Info.PPstudent = False # PP fail means they will not now be on PP course anymore - treat like a normal student            else:                Info.PPpass = -1                Info.PPaway = True                    # Append the values to the individual lists if it is a real course        coursenamesout.append(data[0])  # Keep original coursename + credits for output        coursenames.append(coursename)          marks.append(mark)  # mark        marksout.append(markout) # marksout        mark_codes.append(mark_code) # any codes alongside marks        en_codes.append(en_code) # EN notes        mitcirc_codes.append(mitcirc_code) # Mit Circ codes        credits.append(thiscredit)        codesout.append(codeout)  # Combine for now        # PP/away students: Check that there are no other marks, which should not be there if PP student is away    if (Info.PPstudent == True and Info.PPaway == True and len(marks) > 1):        print('WARNING: Looks like a PP student but there appears to be other marks for this year....please check!')            # Enforce position/ordering of some courses for clearer output later    if (classyear == 4):        try:            idx = coursenames.index('PHYS40181')  # If exists put in 1st columnn            if (idx and idx != 0):                coursenamesout.insert(0,coursenamesout[idx])                coursenames.insert(0,coursenames[idx])                marks.insert(0,marks[idx])                marksout.insert(0,marksout[idx])                credits.insert(0,credits[idx])                codesout.insert(0,codesout[idx])                del coursenamesout[idx+1]                del coursenames[idx+1]                del marks[idx+1]                del marksout[idx+1]                del credits[idx+1]                del codesout[idx+1]        except:            pass        try:            idx = coursenames.index('PHYS40182')  # If exists put in 2nd columnn            if (idx and idx != 1):                coursenamesout.insert(1,coursenamesout[idx])                coursenames.insert(1,coursenames[idx])                marks.insert(1,marks[idx])                marksout.insert(1,marksout[idx])                credits.insert(1,credits[idx])                codesout.insert(1,codesout[idx])                del coursenamesout[idx+1]                del coursenames[idx+1]                del marks[idx+1]                del marksout[idx+1]                del credits[idx+1]                del codesout[idx+1]        except:            pass            if (classyear == 32 or classyear == 31):        try:            idx = coursenames.index('PHYS30010')  # If exists put in 1st columnn            if (not idx): idx = coursenames.index('PHYS30210')  # If exists put in 1st columnn            if (idx and idx != 0):                coursenamesout.insert(0,coursenamesout[idx])                coursenames.insert(0,coursenames[idx])                marks.insert(0,marks[idx])                marksout.insert(0,marksout[idx])                credits.insert(0,credits[idx])                codesout.insert(0,codesout[idx])                del coursenamesout[idx+1]                del coursenames[idx+1]                del marks[idx+1]                del marksout[idx+1]                del credits[idx+1]                del codesout[idx+1]        except:            pass        try:            idx = coursenames.index('PHYS30180')  # If exists put in 2nd columnn            if (not idx): idx = coursenames.index('PHYS30280')  # If exists put in 2nd columnn            if (idx and idx != 1):                coursenamesout.insert(1,coursenamesout[idx])                coursenames.insert(1,coursenames[idx])                marks.insert(1,marks[idx])                marksout.insert(1,marksout[idx])                credits.insert(1,credits[idx])                codesout.insert(1,codesout[idx])                del coursenamesout[idx+1]                del coursenames[idx+1]                del marks[idx+1]                del marksout[idx+1]                del credits[idx+1]                del codesout[idx+1]        except:            pass        try:            idx = coursenames.index('PHYS30880')  # If exists put in 3rd columnn            if (idx and idx != 2):                coursenamesout.insert(2,coursenamesout[idx])                coursenames.insert(2,coursenames[idx])                marks.insert(2,marks[idx])                marksout.insert(2,marksout[idx])                credits.insert(2,credits[idx])                codesout.insert(2,codesout[idx])                del coursenamesout[idx+1]                del coursenames[idx+1]                del marks[idx+1]                del marksout[idx+1]                del credits[idx+1]                del codesout[idx+1]        except:            pass    # add the lists back to the Info object    Info.coursenamesout = coursenamesout    Info.coursenames    = coursenames    Info.marks          = marks    Info.marksout       = marksout    Info.mark_codes     = mark_codes    Info.credits        = credits    Info.en_codes       = en_codes    Info.mitcirc_codes  = mitcirc_codes    Info.codesout       = codesout        # Store indices of courses with no mark    Info.nomarks_idx = [i for i, j in enumerate(marks) if j < 0]    # Store indices of XN    XN_idx = [i for i, s in enumerate(Info.en_codes) if 'XN' in s]  # get idx of any XN codes    Info.XN_idx += XN_idx        # Set mcc=True if there are any MCC codes (i.e. not blank '')    if (any(Info.mitcirc_codes)): Info.mitcircs = True        # If already compensated (for resit grid) then note it    if (Info.resitgrid == True):        idx = [x for x, s in enumerate(Info.mark_codes) if (s.find('C') >=0 and s.find('MC') <0 and s.find('L1C') <0)]         for i in idx:            if i not in Info.compensated_idx:                Info.compensated_idx.append(i)                    return Info################################################################# cap resit marks if R2 in input grid - also remove R2->"cap" to save confusion later with referrals# Note that this is strictly only correct if original mark <30 (ok for AY=2024, we think)def cap_resit_marks(Info):    # don't do anything if a resit grid (dealt with elsewhere in apply_capped_resit_marks())    if (Info.resitgrid == True):         return Info    # cap any second attempt marks at 30 if above 30    for idx in Info.secondattempt_idx:        if (Info.marks[idx] > 29.95):            Info.marksout[idx] = Info.marks[idx]  # output actual mark            Info.marks[idx] = 30   # cap mark at 30 if above                                # remove R2 from codes to save confusion later            Info.codes[idx] = 'cap'            Info.codes2[idx] = 'cap'            # add back 'C' if compensated            if (idx in Info.compensated_idx):                Info.codes[idx] += '_C'                Info.codes2[idx] += '_C'                    return Info################################################################# add Y3 credits data (for Y4 only) if file exists (NEW VERSION 2025)def add_Y3creds_data(Info,df):        if (df is None or Info.classyear != 4):  # do nothing more if no MCC file        Info.Y3creds_below40 = 0        return Info    column_names = df.columns        # get rows of matching student (there may be several)    rows = df['ID'] == Info.emplid    data = df[rows].values    # if no match, continue    if (len(data) == 0):        Info.Y3creds_below40 = 0 # default (should be 0 anyway)        return Info    # add all Y3 fails together (with/without MCs)    try:        data = data[0] # first list in array is what we need        Y3creds_below40      = int(data[1]) + int(data[2])        Y3creds_below40_nomc = int(data[1])        Y3creds_below40_mc   = int(data[2])        Y3creds4_passed      = int(data[3])    except:        Y3creds_below40 = 0        Y3creds_below40_nomc = 0        Y3creds_below40_mc   = 0        Y3creds4_passed      = 0        print('ERROR: Y3 creds below 40: Non-numerical data cannot be added...CHECK!!\n')            # Assign data back to Info    Info.Y3creds_below40      = Y3creds_below40 # Total number of L3 credits below 40 (Y4 only)         Info.Y3creds_below40_nomc = Y3creds_below40_nomc  # L3 credits below 40 not excluded with no MCs (Y4 only)    Info.Y3creds_below40_mc   = Y3creds_below40_mc    # L3 credits below 40 excluded with MCs (Y4 only)    Info.Y3creds4_passed      = Y3creds4_passed       # L4 credits passed in Y3 (Y4 only)                return Info################################################################# Determine which units are 2nd attempts i.e. proper resits that can't be taken again# for now, this is only for resit grids with a secondpass as we rarely have codes (usually repeating students)def get_secondattempts(Info):    # put previous attempts in an array when doing second pass (For resit grids)    if (Info.secondpass == True):        Info.p_secondattempt_idx = Info.secondattempt_idx.copy()        Info.secondattempt_idx = []                # loop over each unit and find where it is a 2nd attempt based on previous codes unless current code excuses it (e.g. X, X1, XL)        for idx in range(len(Info.mitcirc_codes)):            if (Info.mitcirc_codes[idx].find('X') >=0 and Info.mitcirc_codes[idx].find('XN') < 0):                pass            elif ((Info.p_mitcirc_codes[idx].find('R') >=0 and Info.p_mitcirc_codes[idx].find('R1') < 0 and Info.p_mitcirc_codes[idx].find('SR') < 0) or Info.p_mitcirc_codes[idx].find('A2') >=0):                Info.secondattempt_idx.append(idx)                    # if not a resit grid, then see if there is a code with the main mark    elif (Info.resitgrid == False):        for idx in range(len(Info.mitcirc_codes)):            if ( (Info.mitcirc_codes[idx].find('R') >=0 and Info.mitcirc_codes[idx].find('R1') < 0 and Info.mitcirc_codes[idx].find('SR') < 0) or Info.mitcirc_codes[idx].find('A2') >=0):                    Info.secondattempt_idx.append(idx)                    return Info################################################################# get credit weights from coursename or credweights dictionary if 0# will run through all courses# unless idx set to list of indices to re-do (e.g. if compensated later need to put credweights back for these only)def get_credweights(Info,credweightunits,useidx=False):    credits = Info.credits.copy()  # get credits    marks   = Info.marks.copy()    # marks in case missing (which is -1)        # loop over those that are zero using supplied useidx or all zeroes if not    if (useidx):        idx = list([useidx])        credweights = Info.credweights.copy()   # take existing credweights    else:        credweights = credits.copy()  # does not exist yet so take credits as default        idx = [i for i, j in enumerate(credits) if j == 0]    # loop over relevant idx    for i in idx:        coursename = Info.coursenames[i]        if (useidx):            credweights[i] = credits[i]   # if possible compensation put it back to original credits                        if (credits[i] == 0):              try:                credweights[i] = credweightunits[coursename]  # set to correct weight otherwise remains as 0            except:                pass  # no need to give a warning now                Info.credweights = credweights  # Add back to Info                    return Info################################################################# get core/non-core courses for physics and mathdef get_core_courses(Info,isphyscore, ismathcoure):    coursenames     = Info.coursenames.copy()        # Physics core courses    physcore_idx = [i for i in range(len(coursenames)) if coursenames[i] in isphyscore]  # get indices where core courses         # Math core courses (N.B. Y1 all math courses are core only for AY<=2022)    if (Info.mathstudent == True):        mathcore_idx = [i for i in range(len(coursenames)) if coursenames[i] in ismathcore]  # get indices where specific core courses     # Add back to Info    Info.physcore_idx = physcore_idx    if (Info.mathstudent == True):        Info.mathcore_idx    = mathcore_idx   # extra variable only relevant for Math/Phys students        Info.core_idx        = physcore_idx + mathcore_idx  # all core course indices (M+P students)    else:         Info.core_idx    = physcore_idx   # Physics students (no MATHs core)            return Info################################################################# apply manual exclusions to courses (for rare cases) - using manual_exclusions dictionarydef apply_manual_exclusions(Info, manual_exclusions):    # look for ID in manual_exclusions and exclude courses    if (Info.emplid in manual_exclusions.keys()):        coursenames = manual_exclusions[Info.emplid].split(',') # split coursenames if more than 1        # loop over each course        for coursename in coursenames:            try:                idx = Info.coursenames.index(coursename)                Info.codes[idx] = 'X'       # add 'X' to exclude this course            except: # if cannot be found, must be a typo in the manual_exclusions list                '*ERROR: course ({0:s}) not found to manually exlcude - check manual_exclusions list...\n'                return Info################################################################# determine exluded courses from year mark including which ones to be deferred or with no markdef exclude_courses(Info):    # find where codes exist    codes = Info.mitcirc_codes    idx = [i for i in range(len(codes)) if codes[i] != '']  # get indices where codes exist        # DO A FEW THINGS FOR Y3/Y4, THE REST ONLY APPLIES TO Y1/Y2 WHO HAVE RESITS        # For PP students (Professional Placement) last year that have PHYS30810 (120) and current Y3 marks - ignore PHYS30810 (120)    # If on its own with no marks, should be at the bottom of the grid (which will happen anyway if this is ignored so try that)    # (Judith Teams chat 22-Jun-2023)    if (Info.PPstudent == True and Info.PHYS30810 == True):        Info.excluded_idx.append(Info.coursenames.index('PHYS30810'))    # if not Y1/Y2, there should be no SR1/MA3/MA4/MA8 codes - print warning to screen if so    if (Info.classyear > 2 and ('SR' in codes or 'MA' in codes)):        print('*WARNING: SR/MA codes exist here when they should not! (Y3/Y4)')    # : Y3/Y4 only MA8/A8, L1C/L2C/L3C (see Judith email 20-Jun-2025)     if (Info.classyear > 2):        for i in idx:            if (codes[i].find('A8') >=0 or codes[i].find('L1C') >=0 or codes[i].find('L2C') >=0 or codes[i].find('L3C') >=0):                Info.excluded_idx.append(i)                Info.excludedcoursenames.append(Info.coursenames[i])                Info.creditsexcluded += Info.credits[i]                Info.credweights[i] = 0    # OTHERWISE DO NOTHING IF Y3/Y4    if (Info.classyear > 2):        return Info                    # Blank variables unless already set and set credweights to 0 if no mark and previously excluded    excluded_idx = []    excludedcoursenames = []    deferred_idx = []    deferredcoursenames = ''    deferredcredits = 0    creditsexcluded = 0    # If resit grid (2nd pass), and no new mark, but was excluded last time, then exclude this time again    if (Info.secondpass == True and len(Info.excluded_idx) > 0):        for i in Info.excluded_idx:            if (i not in Info.resit_idx):  # only if no new mark                excluded_idx.append(i)                excludedcoursenames.append(Info.coursenames[i])                creditsexcluded += Info.credits[i]                Info.credweights[i] = 0                # loop over each code and excluded if required    # But first exclude courses with no marks from year average where there should be e.g. if A5 it should be treated as per normal    if (len(Info.nomarks_idx) > 0):        for i in Info.nomarks_idx:            if ('XN' not in Info.codes[i] and 'A5' not in Info.codes[i]):                 excluded_idx.append(i)                excludedcoursenames.append(Info.coursenames[i])                creditsexcluded += Info.credits[i]                Info.credweights[i] = 0   # do not include in year average    # loop over each code    for i in idx:        # if resit grid (only) and A3/A4/A5 take current status of resits if deferral (N.B. referrals done in get_referred_units())        # but for A3/A4/A5 case of resits only do this if failed        if (Info.resitgrid == True and (codes[i].find('A4') >=0 and codes[i].find('MA4') <0) and (codes[i].find('A3')>=0 or codes[i].find('A5') >=0)):                                # If deferral last time, then stay with deferral (R1) unless an X or if mark >39.95            if (Info.mitcirc_codes[i].find('R1') >= 0 or (Info.mitcirc_codes[i].find('X') >=0 and Info.mitcirc_codes[i].find('XN') < 0)):                excluded_idx.append(i)                excludedcoursenames.append(Info.coursenames[i])                creditsexcluded += Info.credits[i]                Info.credweights[i] = 0                                # if first pass, codes are not valid anyway so only include the R1                if (Info.secondpass == False and Info.mitcirc_codes[i].find('X') < 0):                    Info.codesout[i] = 'R1'                # Defer if Y1/Y2 and if resittable (credits>0)                if (Info.mitcirc_codes[i].find('R1') >=0 and (Info.classyear == 1 or Info.classyear == 2) and Info.credits[i] > 0):                    deferred_idx.append(i)                    deferredcredits += Info.credits[i]                    if (codes[i].find('A4') >=0 and Info.marks[i] > 39.95): # optional deferral if passed                        deferredcoursenames += Info.coursenames[i] + '[1opt] / '                    else:                        deferredcoursenames += Info.coursenames[i] + '[1] / '  # deferral if failed            # if second pass (resit grid) and still failed with A3/A4/A5 and previously deferred then assume still deferred            if (Info.secondpass == True and Info.marks[i] < 39.95 and i in Info.p_deferred_idx and i not in deferred_idx):                excluded_idx.append(i)                excludedcoursenames.append(Info.coursenames[i])                creditsexcluded += Info.credits[i]                Info.credweights[i] = 0                deferred_idx.append(i)                deferredcredits += Info.credits[i]                if (codes[i].find('A4') >=0 and Info.marks[i] > 39.95): # optional deferral if passed                    deferredcoursenames += Info.coursenames[i] + '[1opt] / '                else:                    deferredcoursenames += Info.coursenames[i] + '[1] / '  # deferral if failed                            # MA4/A4/A5: Y1/Y2 only, resit as first attempt (deferral) -> R1 (A4) or R2 (A5) (done in get_referred)        elif (codes[i].find('A4') >=0 and codes[i].find('MA4') <0):            excluded_idx.append(i)            excludedcoursenames.append(Info.coursenames[i])            creditsexcluded += Info.credits[i]            Info.credweights[i] = 0            #Info.codes[i] = 'A4'            # Defer if Y1/Y2 and if resittable (credits>0)            if ((Info.classyear == 1 or Info.classyear == 2) and Info.credits[i] > 0):                deferred_idx.append(i)                if (codes[i].find('A4') >=0 and Info.marks[i] > 39.95): # optional deferral if passed                    deferredcoursenames += Info.coursenames[i] + '[1opt] / '                else:                    deferredcoursenames += Info.coursenames[i] + '[1] / '  # deferral if failed                deferredcredits += Info.credits[i]        # A5: Y1/Y2 only, resit as first attempt (deferral) -> R2 (A5) but only if failed        elif (codes[i].find('A5') >=0 and Info.marks[i] < 39.95):            Info.codesout[i] = 'R2_A5'            # Change to referral if resittable (credits>0)            if ((Info.classyear == 1 or Info.classyear == 2) and Info.credits[i] > 0):                Info.referred_idx.append(i)                Info.referredcoursenames += Info.coursenames[i] + ' / '        # R1/A1 means exclude and treat as a resit at first attempt next time         #elif (((codes[i].find('R1') >= 0 and codes[i].find('SR1') < 0) or (codes[i].find('A1') >=0 and codes[i].find('A10') <0) or (codes[i].find('C1') >=0)) and i not in Info.secondattempt_idx and i not in Info.compensated_idx): # and not already excluded        elif (((codes[i].find('R1') >= 0 and codes[i].find('SR1') < 0) or codes[i].find('A1') >=0 or codes[i].find('C1') >=0) and i not in Info.secondattempt_idx and i not in Info.compensated_idx): # and not already excluded            excluded_idx.append(i)            excludedcoursenames.append(Info.coursenames[i])            creditsexcluded += Info.credits[i]            Info.credweights[i] = 0                        # Defer if Y1/Y2 and if resittable (credits>0)            if ((Info.classyear == 1 or Info.classyear == 2) and Info.credits[i] > 0):                deferred_idx.append(i)                if (Info.marks[i] > 39.95): # optional deferral if passed                    deferredcoursenames += Info.coursenames[i] + '[1opt] / '                else:                    deferredcoursenames += Info.coursenames[i] + '[1] / '  # deferral if failed                deferredcredits += Info.credits[i]                    # MA3/A3: Y1/Y2 only, exclude from average -> X (if no A4/A5 code, since it may be passed)        elif (codes[i].find('A3') >=0 and codes[i].find('A5') < 0):               excluded_idx.append(i)            excludedcoursenames.append(Info.coursenames[i])            creditsexcluded += Info.credits[i]            Info.credweights[i] = 0            #codes[i] = 'A3'            #codes[i] = 'X'  # do this later                                # X = exclude from year mark        elif (codes[i] == 'X' or codes[i] == '_X' or codes[i].find('X_C') >=0): # includes 'X_C' for 2nd pass (resits)            excluded_idx.append(i)            excludedcoursenames.append(Info.coursenames[i])            creditsexcluded += Info.credits[i]            Info.credweights[i] = 0        # XL = Absent from exam with reason: excludes from the calculation of the year mark and flags as a resit at 1st attempt (deferred)        elif (codes[i].find('XL') >= 0):            excluded_idx.append(i)            excludedcoursenames.append(Info.coursenames[i])            creditsexcluded += Info.credits[i]            Info.credweights[i] = 0            # Defer if Y1/Y2 and if resittable (credits>0)            if ((Info.classyear == 1 or Info.classyear == 2) and Info.credits[i] > 0):                if (i not in Info.secondattempt_idx):   # if not already a 2nd attempt                    Info.codesout[i] = Info.codesout[i] + '_R1'                    deferred_idx.append(i)                    deferredcoursenames += Info.coursenames[i] + '[1] / '                    deferredcredits += Info.credits[i]                else:                    Info.referred_idx.append(i)                    Info.referredcoursenames += Info.coursenames[i] + ' / '                            # X1 = Deferall in Y1/Y2 (same as XL)         elif (codes[i].find('X1') >= 0):            excluded_idx.append(i)            excludedcoursenames.append(Info.coursenames[i])            creditsexcluded += Info.credits[i]            Info.credweights[i] = 0            # Defer if Y1/Y2 and if resittable (credits>0)            if ((Info.classyear == 1 or Info.classyear == 2) and Info.credits[i] > 0):                if (i not in Info.secondattempt_idx):  # if not already a 2nd attempt                    Info.codes[i] = Info.codes[i] + '_R1'                    deferred_idx.append(i)                    deferredcoursenames += Info.coursenames[i] + '[1] / '                    deferredcredits += Info.credits[i]                else:                    Info.referred_idx.append(i)                    Info.referredcoursenames += Info.coursenames[i] + ' / '                            # XN = Missed with no reason - do NOT exclude!        elif (codes[i].find('XN') >= 0):            pass        # L1C/L2C for previous year - means extra credit courses/mark from previous year and these should not form part of the average - exclude        # (Judith email 09-Sep-2023 and 14-Jun-2024)        elif (codes[i].find('L1C') >= 0 and Info.classyear == 2):            excluded_idx.append(i)            excludedcoursenames.append(Info.coursenames[i])            creditsexcluded += Info.credits[i]            Info.credweights[i] = 0        elif (codes[i].find('L2C') >= 0 and (Info.classyear == 31 or Info.classyear == 32)):            excluded_idx.append(i)            excludedcoursenames.append(Info.coursenames[i])            creditsexcluded += Info.credits[i]            Info.credweights[i] = 0        elif (codes[i].find('L3C') >= 0 and (Info.classyear == 4)):            excluded_idx.append(i)            excludedcoursenames.append(Info.coursenames[i])            creditsexcluded += Info.credits[i]            Info.credweights[i] = 0                # If no mark previously and no mark on resits then exlcude them (marking boycott!) and make a note!    if (Info.secondpass == True):        for i in Info.p_nomarks_idx:            if (i in Info.nomarks_idx):                excluded_idx.append(i)                excludedcoursenames.append(Info.coursenames[i])                creditsexcluded += Info.credits[i]                Info.credweights[i] = 0                print('Excluding {0:s} because no marks both times!'.format(Info.coursenames[i]))        # Add extras back to Info    Info.excluded_idx        = excluded_idx    Info.excludedcoursenames = excludedcoursenames    Info.creditsexcluded     = creditsexcluded    Info.deferred_idx        = deferred_idx    Info.deferredcoursenames = deferredcoursenames    Info.deferredcredits     = deferredcredits        return Info################################################################# Function to determine MATH units and marks/credits and also math credits takendef get_math_units(Info):    math_units = []    coursenames = Info.coursenames    idx = [i for i in range(len(coursenames)) if 'MATH' in coursenames[i]]  # get indices if MATH unit    idx2 = [i for i in range(len(coursenames)) if 'MATH' not in coursenames[i]]  # get indices if not MATH unit    # Physics/math credits taken    mathcreditstaken = np.sum(np.array(Info.credits)[idx])    physcreditstaken = np.sum(np.array(Info.credits)[idx2])    # Remove credits for PHYS30810 for PP students! (in all cases - either away or mark from previous year)    if (Info.PHYS30810 == True): # don't look for PPstudent because if they fail PHYS30810 no longer a PP student!        idx = Info.coursenames.index('PHYS30810')        physcreditstaken -= Info.credits[idx]            # Add back to Info    Info.math_units_idx = idx    Info.phys_units_idx = idx2    Info.mathcreditstaken = mathcreditstaken    Info.physcreditstaken = physcreditstaken    Info.creditstaken = mathcreditstaken + physcreditstaken        return Info################################################################# Determine the overall project mark for S1/S2 or both# taking into account special cases for non-standard projects (Phys/Phil and M+P)def get_projectmark(Info):    # If not Y3/Y4 then skip this function    if (Info.classyear == 1 or Info.classyear == 2):        return Info        # taking into account special cases for non-standard projects (Phys/Phil and M+P)    # or with only 1 project    coursenames = Info.coursenames    project1mark = -1    # -1 means no mark       project2mark = -1    # -1 means no mark        # BSc dissertation for 3rd years    if ('PHYS30880' in coursenames and Info.classyear == 32):        idx = coursenames.index('PHYS30880')        project1mark = Info.marks[idx]        project1cred = Info.credits[idx]            if ('PHYS40181' in coursenames and 'PHYS40182' in coursenames):        idx = coursenames.index('PHYS40181')        project1mark = Info.marks[idx]      # S1        project1cred = Info.credits[idx]        idx = coursenames.index('PHYS40182')        project2mark = Info.marks[idx]      # S2        project2cred = Info.credits[idx]            elif ('PHYS40181' in coursenames and 'PHYS40182' not in coursenames):        idx = coursenames.index('PHYS40181')        project1mark = Info.marks[idx]      # S1        project1cred = Info.credits[idx]    elif ('PHYS40181' not in coursenames and 'PHYS40182' in coursenames):        idx = coursenames.index('PHYS40182')        project2mark = Info.marks[idx]      # S2        project2cred = Info.credits[idx]                    # for Phys/Phil who do an essay for one project - only worth 10 credits c.f. 20 credits for physics    if ('PHIL40000' in coursenames and project1mark==-1):        idx = coursenames.index('PHIL40000')        project1mark = Info.marks[idx]        project1cred = Info.credits[idx]    elif ('PHIL40000' in coursenames and project2mark==-1):        idx = coursenames.index('PHIL40000')        project2mark = Info.marks[idx]        project2cred = Info.credits[idx]            # for Math/Phys Math projects only 15 credits c.f. 20 credits for physics    if ('MATH40011' in coursenames and project1mark==-1):        idx = coursenames.index('MATH40011')        project1mark = Info.marks[idx]        project1cred = Info.credits[idx]    if ('MATH40022' in coursenames and project2mark==-1):        idx = coursenames.index('MATH40022')        project2mark = Info.marks[idx]        project2cred = Info.credits[idx]            # combine S1/S2 project marks    if (project1mark >=0 and project2mark >=0):        projectmark = ((project1mark*project1cred)+(project2mark*project2cred))/float(project1cred+project2cred)        projectcred = project1cred+project2cred    elif (project1mark >=0 and project2mark == -1):        projectmark = project1mark        projectcred = project1cred    elif (project2mark >=0 and project1mark == -1):        projectmark = project2mark        projectcred = project2cred    elif (project1mark == -1 and project2mark == -1):        projectmark = 0        projectcred = 0            # Add to Info    Info.projectmark = round(projectmark+0.000001)    Info.projectcred = projectcred    return Info################################################################# Find which units are passed/faileddef get_passed_failed(Info,mustpass,noresitlist):    Info.faillabprog = False # default is False in case allowed to resit 2nd time (e.g. 'A2')    marks = Info.marks.copy()  # get numerical marks    Info.someunitunder30 = False # default (and to reset on 2nd pass for resits)        # get passed marks/credits    passed_idx = [i for i in range(len(marks)) if marks[i] >= 39.95]  # passed marks                if (len(passed_idx) > 0):        creditspassed = np.sum(np.array(Info.credits)[passed_idx])  # Sum of passed credits    else:        creditspassed = 0    # also get Y3 unit credits passed (needed for BSc criteria) for Y3 students (also do for Y4)    if (Info.classyear == 31 or Info.classyear == 32 or Info.classyear == 4):        passed3_idx = [i for i in range(len(marks)) if (marks[i] >= 39.95 and Info.coursenames[i][4] == '3')]        # Level 4 also include level 6 courses (for Philosophy)        passed4_idx = [i for i in range(len(marks)) if (marks[i] >= 39.95 and (Info.coursenames[i][4] == '4' or Info.coursenames[i][4] == '6'))]         if (len(passed3_idx) > 0):            credits3passed = np.sum(np.array(Info.credits)[passed3_idx]) # Sum of passed Y3 courses        else:            credits3passed = 0        if (len(passed4_idx) > 0):            credits4passed = np.sum(np.array(Info.credits)[passed4_idx]) # Sum of passed Y4 courses        else:            credits4passed = 0                    Info.passed3_idx = passed3_idx        Info.credits3passed = int(credits3passed)        Info.passed4_idx = passed4_idx        Info.credits4passed = int(credits4passed)        Info.credits34passed = Info.credits3passed + Info.credits4passed    # For Y4, also need total Level 4 credits passed over Y3+Y4    if (classyear == 4):        Info.credits4total_passed = Info.credits4passed + Info.Y3creds4_passed        # get nominally failed marks/credits    failed_idx = [i for i in range(len(marks)) if (marks[i] < 39.95 and marks[i] >= 0 and i not in Info.excluded_idx)]  # failed marks        # Get sum of "failed" credits    if (len(failed_idx) > 0):        creditsfailed = np.sum(np.array(Info.credits)[failed_idx])  # Sum of "failed" credits    else:        creditsfailed = 0    # Store locations of units in 30-39 range for possible compensation     units30_39_idx = [i for i in range(len(marks)) if (marks[i] >= 29.95 and marks[i] < 39.95)]        # loop through nominally failed courses and determine outcome at end    for i in failed_idx:        # has this course been failed when it must be passed i.e. lab,  project?         if (Info.coursenames[i] in mustpass):            if ('R2' not in Info.codesout[i] and 'A2' not in Info.codesout[i]): # (but not if A2/R2 code for resits)                Info.faillabprog = True  # add failreason later on in get_status            # If lab mark is 39, then allow resit and REVW rather than fail (Judith email 28-Jun-2024)            if (Info.faillabprog == True and Info.marks[i] > 38.45):                Info.faillabprog = False                Info.lab_resit = True                        #if any course is < 30%, resits triggered for 1st/2nd year (also trigger resits later)        if(marks[i]<29.95 and Info.coursenames[i] not in noresitlist and Info.credits[i] > 0 and i not in Info.excluded_idx):            if (Info.secondpass == True and Info.p_marks[i] >=29.95): # If 2nd pass, consider original mark first to prevent unncessary referrals                pass            else:  # otherwise really have a unit under 30%                Info.someunitunder30 = True                #if (Info.secondpass == True): print(i, Info.coursenames[i], Info.p_marks[i], Info.marks[i])    # ***Also assume unit is failed if no mark and not exlcuded    for idx in Info.nomarks_idx:        if (idx not in failed_idx and idx not in Info.excluded_idx):            failed_idx.append(idx)        # Add back to Info    Info.passed_idx = passed_idx    Info.creditspassed = int(creditspassed)    Info.failed_idx = failed_idx       Info.creditsfailed = int(creditsfailed)    Info.units30_39_idx = units30_39_idx    return Info################################################################# Determine which units are to be referred (resit) or can be compensateddef get_referred_units(Info):        # If not Y1/Y2 then skip this function (no resits in Y3/Y4)    if (Info.classyear != 1 and Info.classyear != 2):        return Info    # if level 3 or higher course, no resits, so add to mustpass    for coursename in Info.coursenames:        courselevel = int(coursename[4])        if (courselevel >=3 and coursename not in mustpass):            mustpass.append(coursename)                # blank variables in case this is being ran twice (for resit grids) but keep record of resits at 2nd attempt to keep for later    if (Info.secondpass == True):        Info.keep_referred_idx = [idx for idx in Info.referred_idx if idx in Info.secondattempt_idx]        Info.referred_idx = []  # blank them        Info.referredcoursenames = '' # blank them        #Info.compensated_idx = []  # do not blank here!         # If A5 code on input then they should not be considered 2nd attempt this time since they can resit        idx = [i for i, s in enumerate(Info.codes) if ('A4' in s or 'A5' in s or 'A2' in s or 'A1' in s)]        for idx in idx:            if (idx in Info.secondattempt_idx):                Info.secondattempt_idx.remove(idx)                Info.codes2[idx] = Info.codes2[idx].replace('A5', '')  # remove A5 code since it will be changed to R2 later                Info.codes2[idx] = Info.codes2[idx].replace('A4', '')  # remove A5 code since it will be changed to R2 later                Info.codes2[idx] = Info.codes2[idx].replace('A2', '')  # remove A5 code since it will be changed to R2 later                Info.codes2[idx] = Info.codes2[idx].replace('A1', '')  # remove A5 code since it will be changed to R2 later                    # If definetly not a fail overall    if (Info.faillabprog==0 and (Info.creditsfailed-Info.deferredcredits <= 40)):        # if not more than 40 credits < 40% and none below 30%, they can all be compensated (except Y1 MATHs for M+P students and mustpass)        if (Info.someunitunder30==0):            for idx in Info.units30_39_idx:                if (idx not in Info.excluded_idx and idx not in Info.compensated_idx and Info.coursenames[idx] not in mustpass):                    Info.compensated_idx.append(idx) # compensated automatically for Physics students                # if any mark <30% must be resat and triggers resits of any core course 30-39% (if <40 credits 30-39%)        elif (Info.someunitunder30==1):            Info.resitstriggered = True            for idx in Info.failed_idx: # loop through all failed courses                if (idx not in Info.excluded_idx and Info.credits[idx] != 0): # if not excluded                    if (Info.marks[idx] < 29.95):  # if <30% must be resat                        if (idx in Info.secondattempt_idx): # If 2nd attempt and is failed, then is a fail!                            Info.fail = True                            Info.status = 'FAIL'                            Info.progress= False                            Info.failreason = 'Failed (<30%) 2nd attempts'                            print('Failed 2nd attempts')                        else:                            Info.referred_idx.append(idx)                    elif (idx in Info.units30_39_idx and idx in Info.core_idx): # if 30-39 resit if core course                        if (idx in Info.secondattempt_idx): # If 2nd attempt and is failed, then is a fail!                            Info.fail = True                            Info.status = 'FAIL'                            Info.progress= False                            Info.resitstriggered=True                            Info.failreason = 'Failed 2nd attempts (core not compensatable)'                            print('Failed 2nd attempt: {0:s} not compensatable'.format(Info.coursenames[idx]))                        elif (Info.secondpass == False and idx not in Info.compensated_idx): # not if secondpass and already compensated                            Info.referred_idx.append(idx)                    elif (idx not in Info.referred_idx and idx not in Info.core_idx and idx not in Info.compensated_idx and Info.coursenames[idx] not in mustpass):                            Info.compensated_idx.append(idx) # else will be compensated (not for 0-credit units)                    elif (idx not in Info.compensated_idx): # else referred if not already compensated                        Info.referred_idx.append(idx)                # Else if > 40 credits at 30-39%, all core units must be resat    elif ((Info.creditsfailed-Info.deferredcredits) > 40 and len(Info.failed_idx) >0):        Info.resitstriggered = True        for idx in Info.failed_idx:  # loop through all failed courses            if (Info.marks[idx] < 29.95 and idx not in Info.excluded_idx and Info.credits[idx] !=0): # courses < 30% must be resat                if (Info.secondattempt_idx and idx not in Info.excluded_idx): # if 2nd attempt, and is failed, then is a fail!                    Info.status='FAIL'                    print('Fail due to failed 2nd attempts')                    Info.failreason = 'Failed 2nd attempts'                    Info.fail = True                    Info.progress = False                    Info.resitstriggered=False                else:                    Info.referred_idx.append(idx)              elif (idx in Info.core_idx and idx not in Info.excluded_idx and Info.credits[idx] !=0):  # only for core courses                if (Info.secondattempt_idx and idx not in Info.excluded_idx): # if 2nd attempt, and is failed, then is a fail!                    Info.status='FAIL'                    print('Fail due to failed 2nd attempts')                    Info.failreason = 'Failed 2nd attempts'                    Info.fail = True                    Info.progress = False                    Info.resitstriggered=False                else:                    Info.referred_idx.append(idx)              elif (idx not in Info.deferred_idx and idx not in Info.excluded_idx and Info.credits[idx] !=0): # else must be compensated as an option                if (idx not in Info.compensated_idx and Info.coursenames[idx] not in mustpass):                    Info.compensated_idx.append(idx)        # If Maths+Physics student, some MATHs courses in Y1 not compensatable and must be resat    # (pre-2023: all MATHs in 1st year, post-2023 two modules - see Judith McGovern email 14-May-2022     if (Info.mathstudent == True and Info.classyear == 1):        if (Info.AY <= 2022):  # all MATHs units in 1st year non-compensatable            for idx in Info.compensated_idx:                if (idx in Info.math_units_idx):                    Info.compensated_idx.remove(idx)                    if (Info.secondattempt_idx and idx not in Info.excluded_idx): # if 2nd attempt, and is failed, then is a fail!                        Info.status='FAIL'                        print('Fail due to failed 2nd attempts')                        Info.failreason = 'Failed 2nd attempts'                        Info.fail = True                        Info.progress = False                        Info.resitstriggered=False                    else:                        Info.referred_idx.append(idx)        elif (Info.AY > 2022): # post 2023 onwards: only 2 MATHs modules (listed in not_compensatable dictionary)            for idx in Info.compensated_idx:                if (Info.coursenames[idx] in not_compensatable):                    Info.compensated_idx.remove(idx)                    if (Info.secondattempt_idx and idx not in Info.excluded_idx): # if 2nd attempt, and is failed, then is a fail!                        Info.status='FAIL'                        print('Fail due to failed 2nd attempts')                        Info.failreason = 'Failed 2nd attempts'                        Info.fail = True                        Info.progress = False                        Info.resitstriggered=False                    else:                        Info.referred_idx.append(idx)                        # Now put back any previous referred coursenames at 2nd attempt into the referred idx list     if (Info.secondpass == True):        for idx in Info.keep_referred_idx:  # put back only referred that are 2nd attempt            if (idx not in Info.referred_idx):                Info.referred_idx.append(idx)    # For resits ensure that all R1/R2 codes still next to mark there even if no mark/previous code (therefore not in resit_idx)    if (Info.secondpass == True):        for idx in Info.referred_idx:            if ('R2' not in Info.codes2[idx]):                Info.codes2[idx] = 'R2_' + Info.codes2[idx]                if (idx not in Info.resit_idx):                    Info.resit_idx.append(idx)                     for idx in Info.deferred_idx:            if ('R1' not in Info.codes2[idx]):                Info.codes2[idx] = 'R1_' + Info.codes2[idx]                if (idx not in Info.resit_idx):                    Info.resit_idx.append(idx)                                        # Remove compensation if a referral (e.g. a capped resit like 30R is not compensated)    #idx = [i for i in Info.compensated_idx if (i not in Info.referred_idx and i not in Info.deferred_idx)]    #for i in idx:    #    Info.compensated_idx.remove(i)            # Deal with any resit marks < 30 (failed) but OM 30-39 - do not need to be resats    #if (Info.secondpass == True)                    # Remove compensation code if above 40    for idx in Info.compensated_idx:        if (Info.marks[idx] >= 39.95):            Info.compensated_idx.remove(idx)                    # apply referred coursenames and any missing R codes     for idx in Info.referred_idx:        Info.referredcoursenames += Info.coursenames[idx] + ' / '  # add referred coursenames        if (Info.codes2[idx].find('R') < 0 and Info.codes[idx].find('SR') < 0):            #Info.codes[idx] += '_R2'  # not for CS 1-line sheet            Info.codes2[idx] = 'R2_' + Info.codes2[idx] # to incidcate resit at 2nd attempt            Info.en_codes[idx] = 'R2_' + Info.en_codes[idx] # for CS 1-line sheet                # Apply any missing compensated unit codes to the mark if not there (don't add to mark unless on input)    for idx in Info.compensated_idx:        #if (Info.marksout[idx].find('C') < 0):            #Info.marksout[idx] += 'C' # to indicate compensated (only if on input grid to be consistent)        #if (Info.codes2[idx].find('C') < 0 and Info.codes2[idx].find('MC') < 0):        #Info.codes[idx] += '_C'   # not for CS 1-line sheet        Info.codes2[idx] += '_C'        Info.en_codes[idx] += '_C'  # for CS 1-line sheet            # Remove any leading/trailing '_' to the code if it exists    for i in range(len(Info.codes)):        if (len(Info.codes[i]) > 0 and Info.codes[i][0] == '_'): Info.codes[i] = Info.codes[i][1:]        if (len(Info.codes2[i]) > 0 and Info.codes2[i][0] == '_'): Info.codes2[i] = Info.codes2[i][1:]        if (len(Info.en_codes[i]) > 0 and Info.en_codes[i][0] == '_'): Info.en_codes[i] = Info.en_codes[i][1:]        #if (len(Info.p_codes[i]) > 0 and Info.p_codes[i][0] == '_'): Info.p_codes[i] = Info.p_codes[i][1:]        if (len(Info.codes[i]) > 0 and Info.codes[i][-1] == '_'): Info.codes[i] = Info.codes[i][0:-1]        if (len(Info.codes2[i]) > 0 and Info.codes2[i][-1] == '_'): Info.codes2[i] = Info.codes2[i][0:-1]        if (len(Info.en_codes[i]) > 0 and Info.en_codes[i][-1] == '_'): Info.en_codes[i] = Info.en_codes[i][0:-1]                # Remove any trailing ' / ' in referred/deferred coursenames    #if (Info.referredcoursenames[-2:].find('/') >=0):    #    Info.referredcoursenames = Info.referredcoursenames[:-2]    #if (Info.deferredcoursenames[-2:].find('/') >=0):    #    Info.deferredcoursenames = Info.deferredcoursenames[:-2]                # Remove any spaces    Info.codes = [s.replace(' ', '') for s in Info.codes]    Info.codes2 = [s.replace(' ', '') for s in Info.codes2]    Info.en_codes = [s.replace(' ', '') for s in Info.en_codes]        return Info################################################################# make precapped/poscapped marks arrays, and also apply any other rules for resitsdef apply_capped_resit_marks(Info):    # only apply if 2nd pass (resit)     if (Info.secondpass == True):        # if a course is excluded due to missing but is referred (for 2nd attempt) then still include in average        for idx in Info.referred_idx:            if (idx in Info.excluded_idx): # do not exclude if XL but is a referall (e.g. R2) and use original mark/credits                Info.excluded_idx.remove(idx)                Info.excludedcoursenames.remove(Info.coursenames[idx])                Info.credweights[idx] = Info.credits[idx]                Info.marks_postcapped[idx] = Info.p_marks[idx]   # apply marks to postcapped array        # If a course is compensated and OM<29.95, but new mark is >30, use new mark (this is for when compensated was determined later)        #for idx in Info.compensated_idx:        #    if (Info.p_marks[idx] < 29.95 and Info.marks[idx] > 29.95):        #        Info.marks_postcapped[idx] = Info.marks[idx]        # If a course is compensated and OM<29.95, but new mark is >30, cap at 30 (still compensatable) - if 2nd attempt (not 1st)        for idx in Info.compensated_idx:            if (idx in Info.secondattempt_idx and Info.p_marks[idx] < 29.95 and Info.marks[idx] > 29.95):                Info.marks_postcapped[idx] = 30                        # use capped resit marks         Info.marks_precapped = Info.marks.copy() # to store just in case needed        Info.marks = Info.marks_postcapped.copy() # replace marks with correct (capped) resit marks    return Info################################################################# get overall average year markdef get_yearmark(Info):    # get arrays            marks = np.array(Info.marks.copy())    credweights = np.array(Info.credweights.copy())    # get credits    sumcredweights = np.sum(credweights)    Info.sumcredweights = sumcredweights        # do calculation    if (sumcredweights > 0):        Info.yearmark = np.sum(marks*credweights)/sumcredweights        Info.yearmark = round(Info.yearmark + 0.000001, 1) # round to 1 d.p.    else:        Info.yearmark = -1  # if no marks    Info.yearmarkout = str(Info.yearmark)            return Info################################################################# get overall average year mark for Physics and Math separately including overall year mark (for M+P students only)def get_mp_yearmark(Info):        marks       = np.array(Info.marks.copy())    credweights = np.array(Info.credweights.copy())  # Needed for separate Physics/Math averages    credits     = np.array(Info.credits.copy())      # Needed for year average for weighting of Physics/Math        # Physics    idx = Info.phys_units_idx    physcredweights = np.sum(credweights[idx])    if (physcredweights > 0):        phys_yearmark = np.sum(marks[idx]*credweights[idx])/physcredweights  # do not round yet    else:        phys_yearmark = 0.0            # Math    idx = Info.math_units_idx    mathcredweights = np.sum(credweights[idx])    if (mathcredweights > 0):        math_yearmark = np.sum(marks[idx]*credweights[idx])/mathcredweights  # do not round yet    else:        math_yearmark = 0.0        # Overall year mark replaced by weighted average of M+P separately using original credit weightings (for M+P students only)    # Exclude deferred credits from the credit M+P credit split (Judith email 06-Jul-2022 but won't be an issue for future years)    # From 2023 just do straight average like for other students    if (Info.mathstudent):        phys_units_idx = Info.phys_units_idx.copy()        math_units_idx = Info.math_units_idx.copy()        excluded_idx   = Info.excluded_idx.copy()            # get physics/maths units omitting excluded ones        phys_assessed_credits_idx = [idx for idx in phys_units_idx if idx not in excluded_idx]        math_assessed_credits_idx = [idx for idx in math_units_idx if idx not in excluded_idx]        sumcredits_phys = np.sum(credits[phys_assessed_credits_idx])        sumcredits_math    = np.sum(credits[math_assessed_credits_idx])        if ( (sumcredits_phys+sumcredits_math) == 0):  # just to catch when 0 credits            yearmark = 0        else:            yearmark   = (phys_yearmark*sumcredits_phys + math_yearmark*sumcredits_math)/(sumcredits_phys+sumcredits_math)                    Info.yearmark  = round(yearmark+0.000001,1)  # only add back to Info if math student (round to 1 d.p.)                # From AY 2023, just do straight average like for other students (not sure why above is not identical to this!)        if (Info.AY >= 2023):            Info = get_yearmark(Info)            # Add back to Info    Info.physcredweights = physcredweights    Info.mathcredweights    = mathcredweights    Info.phys_yearmark   = round(phys_yearmark+0.000001,1)  # round to 1 d.p.    Info.math_yearmark      = round(math_yearmark+0.00001,1)      # round to 1 d.p.    # If missing marks (-1) put back as intger (-1) rather than -1.0    if (Info.yearmark < 0): Info.yearmark = -1    if (Info.phys_yearmark < 0): Info.phys_yearmark = -1    if (Info.math_yearmark < 0): Info.math_yearmark = -1             # Add O/P/M string and physics/math credist taken string for output    Info.year_opm           = str(Info.yearmark) + ' / ' + str(Info.phys_yearmark) + ' / ' + str(Info.math_yearmark)     Info.creditstaken_pm    = str(Info.physcreditstaken) + ' / ' + str(Info.mathcreditstaken)        return Info################################################################# get credits at and above each level (for promotion and CS output)def get_credits_above(Info):    # Get credits credits in each class, not including excluded credits    marks = Info.marks.copy()    idx = [i for i, v in enumerate(marks) if (v >= boundaryfirst and i not in Info.excluded_idx)] # 1st    Info.credsatfirst = sum([Info.credits[i] for i in idx])    idx = [i for i, v in enumerate(marks) if (v >= boundaryupper2 and v < boundaryfirst and i not in Info.excluded_idx)]  #2.1    Info.credsatupper2 = sum([Info.credits[i] for i in idx])    idx = [i for i, v in enumerate(marks) if (v >= boundarylower2 and v < boundaryupper2 and i not in Info.excluded_idx)] #2.2    Info.credsatlower2 = sum([Info.credits[i] for i in idx])    idx = [i for i, v in enumerate(marks) if (v >= boundarythird and v < boundarylower2 and i not in Info.excluded_idx)]  #3rd    Info.credsatthird = sum([Info.credits[i] for i in idx])    idx = [i for i, v in enumerate(marks) if (v < boundarythird and v >=0 and i not in Info.excluded_idx)]  # Failed (<40 but >=0 to ignore -1 marks!)    Info.credsfailed = sum([Info.credits[i] for i in idx])    idx = [i for i, v in enumerate(marks) if (v >= 29.95 and v < boundarythird and i not in Info.excluded_idx)]  # CF (30-39) - for CS output     Info.credsatCF = sum([Info.credits[i] for i in idx])        # credits above each class    Info.credsaboveupper2 = Info.credsatfirst + Info.credsatupper2    Info.credsabovelower2 = Info.credsaboveupper2 + Info.credsatlower2    Info.credsabovethird  = Info.credsabovelower2 + Info.credsatthird        return Info################################################################# Get overall mark based on years availabledef get_overallmark(Info):    overallmark=-1    overallmathmark=-1    overallphysmark=-1    # BSc and MPhys have same weights except in Y4     if (Info.classyear != 4):        if (Info.phys1<0 and Info.phys2<0): # no first or second year mark, so 1st year (also direct entry to 3rd year)            overallmark = Info.yearmark          elif (Info.phys1<0 and Info.phys2>0): # no first year mark, so direct entry            overallmark = (1/3)*Info.phys2 + (2/3)*Info.yearmark         elif (Info.phys1>0 and Info.phys2<0):  # for 2nd years when CF file available            overallmark = 0.25*Info.phys1 + 0.75*Info.yearmark         else: # Default for 3-year course (both BSc and MPhys progressing - see Judith emails 24/25-Jun-2023)            overallmark = 0.1*Info.phys1+0.3*Info.phys2+0.6*Info.yearmark          overallphysmark = overallmark                         #  Y4 (MPhys only)     if (Info.classyear == 4):        if (Info.phys1 < 0 and Info.phys2 > 0): # no first year mark, direct entry to 2nd year            overallmark = (0.19/0.94)*Info.phys2 + (0.375/0.94)*Info.phys3 + (0.375/0.94)*Info.yearmark          elif (Info.phys1 < 0 and Info.phys2 < 0 and Info.phys3>0): # no first or second year mark, so direct entry to 3rd year             overallmark = 0.5*Info.phys3 + 0.5*Info.yearmark          elif (Info.phys1 < 0 and Info.phys2 < 0 and Info.phys3<0): # only 4th year mark available            overallmark = Info.yearmark          else: # 4th year default            overallmark = 0.06 * Info.phys1 + 0.19 * Info.phys2 + 0.375 * Info.phys3 + 0.375*Info.yearmark               # MPHYS study in/abroad [ Phys Europe 4th year - previously had [3A] or [A] to be added to the program code to differentiate them. ]    # only apply in Y4 (otherwise 3-year weights)    if (Info.classyear == 4 and (Info.abroad == True or Info.Euro == True)):         overallmark = 0.08 * Info.phys1 + 0.23 * Info.phys2 + 0.23 * Info.phys3 + 0.46*Info.yearmark                     overallphysmark = overallmark  # log physics mark    # BSc M/P (only for pre AY=2023 for backward compatibility)    if (Info.AY <= 2022 and 'BSc' in Info.Plan and 'Math' in Info.Plan):        if (Info.phys1<0 and Info.phys2>0): # no first year mark, so direct entry (Y3)            overallmark=0.3333*(Info.phys2+Info.math2)/2.+0.6666*Info.yearmark             overallphysmark = 0.3333 * Info.phys2 + 0.6666 * Info.phys_yearmark             overallmathmark = 0.3333 * Info.math2 + 0.6666 * Info.math_yearmark        elif (Info.phys1>0 and Info.phys2<0): # 2nd year students when CF file available             overallmark = 0.25*(Info.phys1+Info.math1)/2. + 0.75*Info.yearmark            overallphysmark = 0.25*Info.phys1 + 0.75*Info.phys_yearmark            overallmathmark = 0.25*Info.math1 + 0.75*Info.math_yearmark        else:            overallmark= 0.1*(Info.phys1+Info.math1)/2. + 0.3*(Info.phys2+Info.math2)/2. +0.6*Info.yearmark            overallphysmark = 0.1*Info.phys1 + 0.3*Info.phys2 + 0.6*Info.phys_yearmark            overallmathmark = 0.1*Info.math1 + 0.3*Info.math2 + 0.6*Info.math_yearmark    # MPHYS M/P (only for pre AY=2023 backward compatibility)    if (Info.AY <= 2022 and 'Phys' in Info.Plan and 'Math' in Info.Plan and 'BSc' not in Info.Plan):        if (Info.phys1 < 0 and Info.phys2 > 0 and Info.year3mark < 0): # no first  year mark, so direct entry (Y3)            overallmark = (0.19/0.565)*(Info.phys2+Info.math2)/2.  + (0.375/0.565)*Info.yearmark              overallmathmark = (0.19/0.565)*Info.math2 + (0.375/0.565)*Info.math_yearmark            overallphysmark = (0.19/0.565)*Info.phys2 + (0.375/0.565)*Info.phys_yearmark        elif (Info.phys1 < 0 and Info.phys2 > 0 and Info.year3mark > -1): # no first  year mark, so direct entry (Y4)            overallmark = (0.19/0.94)*(Info.phys2+Info.math2)/2. + (0.375/0.94)*Info.year3mark + (0.375/0.94)*Info.yearmark              overallmathmark = (0.19/0.94)*Info.math2 + (0.375/0.94)*Info.math3 + (0.375/0.94)*Info.math_yearmark            overallphysmark = (0.19/0.94)*Info.phys2+ (0.375/0.94)*Info.phys3 + (0.375/0.94)*Info.phys_yearmark        elif (Info.phys1 < 0 and Info.phys2 < 0 and Info.year3mark > -1): # no first or second year mark, so direct entry            overallmark = 0.5*Info.year3mark + 0.5*Info.yearmark              overallphysmark = 0.5*Info.phys3 + 0.5*Info.phys_yearmark            overallmathmark = 0.5*Info.math3 + 0.5*Info.math_yearmark        elif (Info.phys1>0 and Info.phys2<0):  # 2nd years when CF file available             overallmark = 0.06/0.25 * (Info.phys1+Info.math1)/2. + 0.19/0.25*Info.yearmark            overallmathmark =  0.06/0.25 * Info.math1 + 0.19/0.25 * Info.math_yearmark            overallphysmark = 0.06/0.25 * Info.phys1 + 0.19/0.25 * Info.phys_yearmark        elif (Info.phys1>0 and Info.phys2>0 and Info.phys3<0): # 3rd years            overallmark = (0.06/0.625)*(Info.phys1+Info.math1)/2. + (0.19/0.625)*(Info.phys2+Info.math2)/2. + (0.375/0.625)*Info.yearmark            overallmathmark =  (0.06/0.625)*Info.math1 + (0.19/0.625)*Info.math2 + (0.375/0.625)*Info.math_yearmark            overallphysmark = (0.06/0.625)*Info.phys1 + (0.19/0.625)*Info.phys2 + (0.375/0.625)*Info.phys_yearmark        else: # 4th years            overallmark = 0.06 * (Info.phys1+Info.math1)/2. + 0.19 * (Info.phys2+Info.math2)/2. + 0.375 * Info.year3mark + 0.375*Info.yearmark            overallmathmark =  0.06 * Info.math1 + 0.19*Info.math2 + 0.375*Info.math3 + 0.375*Info.math_yearmark            overallphysmark = 0.06 * Info.phys1 + 0.19 * Info.phys2 + 0.375 * Info.phys3 + 0.375*Info.phys_yearmark    # Add back to Info    Info.overallmark     = round(overallmark+0.000001,1)    Info.overallphysmark = round(overallphysmark+0.000001,1)    Info.overallmathmark = round(overallmathmark+0.000001,1)    # add output mark as a string (so can easily add '**' or other things later)    Info.overallmarkout = str(Info.overallmark)    # also output O/P/M    Info.overallmark_opm = Info.overallmarkout + ' / ' + str(Info.overallphysmark) + ' / ' + str(Info.overallmathmark)        return Info################################################################# get status for progression# remove referred/deferred info if already faileddef get_status(Info):    if (Info.fail == False): # unless a fail for another reason 'ACTV' default status to begin with        Info.status = 'ACTV'          # borderlines for MPhys students    if (Info.AY == 2020 or Info.AY == 2021):        rbsc_upper = 51.95  # changed due to COVID after 2019 (used in 2020/2021) but not in 2022 - see Ivan/Judith email 15-Sep-2022         rx_upper   = 54.95    else: # pre-2019 and post 2022 back to normal        rbsc_upper = 52.95         rx_upper   = 54.95            if (len(Info.deferred_idx) > 0):        Info.status = 'A/D'         # student with deferrals        if (Info.fail == True):             Info.fail = False            Info.failreason = ''            if (len(Info.referred_idx) > 0):         Info.status = 'REVW'        # student with resits (REVW trumps A/D)        if (Info.fail == True): # in case a "fail" (resit/second pass) but shouldn't be, reset:            Info.fail = False            Info.failreason = ''                                        # MPhys borderline/move to BSc students (for Y2/3)     if (Info.mphysstudent == True and Info.classyear == 2):         # For students without resits (1st pass)         if (Info.secondpass == False and len(Info.referred_idx) == 0 and len(Info.deferred_idx) == 0):            if (Info.yearmark < rbsc_upper):                Info.status = 'R/BSc'            elif (Info.yearmark < rx_upper):                Info.status = 'R/X'        # On 2nd pass, if referalls use new (August) mark otherwise use previous (June) mark (Judith email 15-Sep-2022)        if (Info.secondpass == True and len(Info.deferred_idx) == 0):            # if no referrals, use new (August) mark             if (len(Info.referred_idx) == 0):                if (Info.yearmark < rbsc_upper):                    Info.status = 'R/BSc'                elif (Info.yearmark < rx_upper):                    Info.status = 'R/X'            # if referrals, use previous (June) mark            elif (len(Info.referred_idx) > 0):                yearmark = Info.p_yearmark # (previous mark in June)                if (yearmark < rbsc_upper):                    Info.status = 'R/BSc'                elif (yearmark < rx_upper):                    Info.status = 'R/X'    # Y3->Y4 progression    if (Info.classyear == 31):        # Min level of credits to progress for Y3->Y4 is 100 credits        min_credits = 100                # must be level 3/4/6 courses from 2023 but  only for BSc, not MPhys! (Judith email 24-Jun-2023)                        if (Info.faillabprog==False and Info.creditspassed>=min_credits):            if (Info.yearmark>=49.95 and Info.overallmark>=49.95):  # carry on MPhys                Info.status   = 'ACTV'                Info.fail     = False                Info.progress = True            elif (Info.yearmark>=47.95 and Info.overallmark>=47.95):  # borderline goes to review                Info.status   = 'REVW BSc 2.2'                Info.degclass = 2                Info.progress = False                #Info.finalyear = True  # Put these back if wanting to go through apply_promotion etc.            elif (Info.overallmark>=49.95): # BSc if not a fail                Info.status   = 'BSc 2.2'                Info.degclass = 2                if (Info.overallmark > borderupper2):                    Info.status = 'REVW ' + Info.status                Info.progress = False                #Info.finalyear = True  # Put these back if wanting to go through apply_promotion etc.            elif (Info.overallmark>=39.95): # BSc if not a fail                Info.status   = 'BSc 3'                if (Info.overallmark > borderlower2):                    Info.status = 'REVW ' + Info.status                Info.degclass = 1                Info.progress = False                #Info.finalyear = True  # Put these back if wanting to go through apply_promotion etc.        elif (Info.faillabprog==False and Info.creditspassed<min_credits):  # borderline with fewer credits goes to review for BSc            if (Info.overallmark>59.95 and Info.credits34passed>=creditstogetBScgood):                Info.status = 'BSc 2.1'                if (Info.overallmark > borderfirst):                    Info.status = 'REVW ' + Info.status                Info.degclass = 3                Info.progress = False                #Info.finalyear = True            elif (Info.overallmark>49.95 and Info.credits34passed>=creditstogetBScgood):                Info.status = 'BSc 2.2'                if (Info.overallmark > borderupper2):                    Info.status = 'REVW ' + Info.status                Info.degclass = 2                Info.progress = False                #Info.finalyear = True            elif (Info.overallmark>39.95 and Info.credits34passed>=creditstogetBSclower):                Info.status = 'BSc 3'                if (Info.overallmark > borderlower2 and Info.credits34passed>=creditstogetBScgood):                    Info.status = 'REVW ' + Info.status                Info.degclass = 1                Info.progress = False                #Info.finalyear = True            else:                Info.status   = 'FAIL'                Info.degclass = -1                Info.failreason = '<MPhys fail (<50%) and not enough marks/credits ({0:d}/{1:d}) for BSc 3 '.format(Info.credits34passed,creditstogetBSclower)                Info.fail     = True                Info.progress = False                        else:  # MPhys Fail -> BSc            Info.status   = 'FAIL->BSc'            Info.fail     = True            Info.progress = False            #Info.finalyear = True            if (Info.faillabprog == True):   Info.failreason = 'MPhys fail (lab/project) -> BSc'            elif (Info.creditspassed < creditstogetMPHYSlower):       Info.failreason = 'MPhys fail (credits) -> BSc'            elif (Info.overallmark < 49.95): Info.failreason = 'MPhys fail (<50%) -> BSc'                    # if not progressing to Y4, set as final year student (if you want it to go through apply_promotion etc.)        # THIS DOES NOT WORK PROPERLY! e.g. wants to add degclass columns which don't exist etc. SO HAVE TO KEEP SEPARATE RULES ABOVE        if (Info.progress == False and Info.fail == False):            Info.mphys_to_bsc = True        #    Info.finalyear = True     # DOES NOT WORK CORRECTLY AT MOMENT        #    Info.mphysstudent = False        #    Info.classyear = 32            # Additional requirement for M+P students to get >45% M+P separately to progress in 3rd year to progress    if (Info.mathstudent == True and Info.classyear == 31 and Info.fail == False):         if (Info.faillabprog == False and (Info.phys_yearmark<45 or Info.math_yearmark<45)): # >45% M+P separately            if (Info.overallmark>boundaryupper2 and Info.credits34passed>=creditstogetBScgood):                Info.status = 'REVW BSc 2.1'                Info.progress = False                #Info.finalyear = True            elif (Info.overallmark>boundarylower2 and Info.credits34passed>=creditstogetBScgood):                Info.status = 'REVW BSc 2.2'                Info.progress = False                #Info.finalyear = True            elif (Info.overallmark>boundarythird and Info.credits34passed>=creditstogetBSclower):                Info.status = 'REVW BSc 3'                Info.progress = False                #Info.finalyear = True            else: # if not borderline, then is a fail                    Info.status = 'FAIL'                    Info.failreason = '<45% separately in Math/Phys and not borderline'                    Info.fail = True                    Info.progress = False                    # Y1/Y2 if < 80 credits (if > 60, may be able to resit as per below), but don't do this if missing marks    if ( (Info.classyear == 1 or Info.classyear == 2) and ((Info.creditspassed+Info.deferredcredits) < 80) and len(Info.referred_idx) == 0 and len(Info.deferred_idx) == 0 and len(Info.nomarks_idx) == 0):        Info.fail = True        Info.progress = False        Info.status = 'FAIL'        Info.failreason = '<80 credits'            # If fewer than 60 credits, then fail    if ((Info.creditspassed + Info.deferredcredits) < 60):        Info.fail   = True        Info.status = 'FAIL'        Info.failreason = '< 60 credits'    # For 2nd attempts that are failed or no mark for a resit then is a fail (unless codes say is first attempt or can be excluded)    if (Info.secondpass == True):        for idx in Info.secondattempt_idx:            if (Info.marks[idx] < 29.95 and idx not in Info.excluded_idx and idx not in Info.referred_idx):                Info.fail = True                Info.progress = False                Info.status = 'FAIL'                Info.failreason = 'Failed (<30%) 2nd attempt resits'    if (Info.faillabprog == True):  # student has failed lab        Info.status = 'FAIL'        Info.failreason = Info.failreason + ' Failed lab/project/non-resittable unit'        Info.fail = True    # If 'PRO' in the marks likely the full marks are not in so just change fail to ACTV unless definitely deferred units    #if ('PRO' in Info.codes):    #    Info.status = 'ACTV'    #    Info.fail   = False    #    Info.progress = True    #    Info.failreason = ''    #elif (hasattr(Info,'p_codes') and 'PRO' in Info.p_codes):    #    Info.status = 'ACTV'    #    Info.fail   = False    #    Info.progress = True    #    Info.failreason = ''    # if it looks like a repeating student remove _R, _C etc. and  reset status and output to screen for info    # (these would normally be put in the donotprocesslist)    if (Info.finalyear == False and Info.resitgrid == False and Info.repeating == True):    #    Info.status = ''    #    Info.codes = ['']*len(Info.codes)    #    Info.compensated_idx = []    #    Info.referred_idx = []    #    Info.referredcoursenames = ''    #    Info.deferred_idx = []        #print('Looks like repeating student -details (resits/status) may be incorrect for Y1/Y2 (marks should still be ok)')        pass # better not print anything since L?CM marks give the current years marks so all students appear to be repeating!!    # if lab mark is 39 can resit over summer (essay)    if (Info.lab_resit == True and (Info.creditspassed+Info.deferredcredits >= 40)): # only if < 60 credits failed plus lab (worth 20)         for idx in Info.failed_idx:            if (Info.marks[idx] > 38.45 and Info.coursenames[idx] in mustpass and Info.secondpass == False): # make sure not 2nd attempt with same mark                Info.fail = False                Info.failreason = 'Resit failed lab'                Info.status = 'REVW'                if (idx not in Info.referred_idx):                    Info.referred_idx += [idx]                    if (len(Info.codes2[idx]) == 0):  # add 'R2' to show it's a resit                        Info.codes2[idx] = 'R2'                    elif (Info.codes2[idx].find('R2') < 0): # (if not there already from the input)                        Info.codes2[idx] += '_R2'                        print('hello')                                            if (len(Info.referred_idx) > 1): # add mustpass course to referral list                        Info.referredcoursenames += ' / ' + Info.coursenames[idx]                    else:                        Info.referredcoursenames = Info.coursenames[idx]                    if (len(Info.deferred_idx) > 1): # add leading ' / ' if necessary                        Info.referredcoursenames = ' / ' + Info.referredcoursenames                                                # In general, if a fail, referrals/deferalls and print out the fail reason (and remove any C/R *output* codes - go back to inputs only)    if (Info.fail == True):         #if (Info.resitgrid == False): # do not do for resit grids for now            #codes = Info.codes.copy()            #for i in range(len(codes)): # Remove R/C codes, R1/R2, SR1 etc.            #        codes[i] = codes[i].replace('R', '')            #        codes[i] = codes[i].replace('C','')            #        codes[i] = codes[i].replace('1', '')            #        codes[i] = codes[i].replace('2','')            #        codes[i] = codes[i].replace('S', '')            #        codes[i] = codes[i].replace('XN', '')            #        codes[i] = codes[i].replace('_','')                                    print('Fail due to ' + Info.failreason)        Info.passfail = 'Fail'  # extra varibale for 1-line CS grids ]        Info.codesout = Info.mitcirc_codes.copy() # for CS go back to original codes        Info.referredcoursenames = ''        Info.deferredcoursenames = ''    return Info################################################################# get degree classification based on overall mark for finalyear students# also, include promotion if relevantdef get_degclass(Info):    # If not final year    if (Info.finalyear == False):        return Info    fail = 0  # Not a fail by default    demote = 0  # Not demoted by default (this is for deciding whether promotion cann be applied later)    creditspassed = Info.creditspassed  # credits passed for BSc    # get appropriate number of credits passed (must be level 3/4/6 courses from 2022 onwards)    if (Info.classyear != 4 and AY >= 2022): creditspassed = Info.credits34passed    else: creditspassed = Info.creditspassed            # if failed lab/project then is a fail - don't go through the logic further down    if (Info.faillabprog == True):        Info.honours  = 1        Info.degclass = -1        Info.fail     = True        Info.demote   = 0        Info.failreason = 'Failed lab/project/non-resittable unit'        return Info            # BSc or MPHys -> BSc    if (Info.classyear == 32):                    if  creditspassed>=creditstogetBScgood and Info.overallmark>=boundaryfirst:            honours=1            degclass=4        elif creditspassed >= creditstogetBSclower and creditspassed <=creditstogetBScgood and Info.overallmark >= boundaryfirst:            honours = 1            degclass = 3            demote = 1        elif creditspassed>=creditstogetBScgood and Info.overallmark>=boundaryupper2 and Info.overallmark<boundaryfirst:            honours = 1            degclass = 3        elif creditspassed>=creditstogetBSclower and creditspassed <=creditstogetBScgood and Info.overallmark>=boundaryupper2 and Info.overallmark<boundaryfirst:            honours = 1            degclass = 2            demote = 1        elif creditspassed>=creditstogetBScgood and Info.overallmark>=boundarylower2 and Info.overallmark<boundaryupper2:            honours = 1            degclass = 2        elif creditspassed>=creditstogetBSclower and creditspassed<creditstogetBScgood and Info.overallmark>=boundarylower2 and Info.overallmark<boundaryupper2:            honours = 1            degclass = 1            demote = 1        elif creditspassed >= creditstogetBSclower and Info.overallmark >= boundarythird:            honours = 1            degclass = 1        elif creditspassed >= creditstogetBSclower:            honours =0            degclass=0            demote = 1        else: # Fail            honours=0            degclass=-1            fail = 1            demote = 1            Info.failreason = 'Not enough credits at L3'                # MPhys - for 2025 with new credit counting rules requiring L3 credits as well (see Judith email 03-Jun-2025)    if (Info.AY >= 2025 and Info.classyear == 4):        # get classification based on overallmark mark only        if (Info.overallmark>=boundaryfirst):            honours=1            degclass=4        elif (Info.overallmark>=boundaryupper2 and Info.overallmark<boundaryfirst):            honours = 1            degclass = 3        elif (Info.overallmark>=boundarylower2 and Info.overallmark<boundaryupper2):            honours = 1            degclass = 2        else: # Fail            honours=0            degclass=-1            fail = 1        # Consider passed/failed credits with 2 constraints:        # i) Need to pass 80 credits at L4 in Y4        # ii) No more than 40 credits failed at L3/L4        # get number of passed credits over Y3+Y4        credits34failed = Info.Y3creds_below40 + Info.creditsfailed        Info.credits34failed = credits34failed        # i) Need to pass 80 credits at L4 (across Y3/Y4) otherwise demote        if (Info.credits4total_passed < creditstogetMPHYS):            honours = 1            if (degclass >=3):                degclass = degclass -1            else:                degclass = -1                honours  = 0                fail = 1            demote = 1            Info.failreason = 'Fewer than 80 L4 credits ({0:d}) passed'.format(Info.credits4total_passed)        # ii) No more than 40 credits failed at L3/L4        elif (credits34failed > 40):            honours = 1            if (degclass >= 3):                degclass = degclass -1            else:                degclass = -1                honours  = 0                fail = 1            demote = 1            Info.failreason = 'More than 40 failed credits ({0:d}) failed over Y3/Y4'.format(credits34failed)            # MPhys - for 2024 when only Y3+Y4 credits over the 2 years    elif (Info.AY == 2024 and Info.classyear == 4):        # get number of passed credits over Y3+Y4        creditspassed34 = creditspassed + (120-Info.Y3creds_below40)        Info.creditspassed34 = creditspassed34                if  creditspassed34>=creditstogetMPHYS34 and Info.overallmark>=boundaryfirst:            honours=1            degclass=4        elif creditspassed34 >= creditstogetMPHYSlower34 and creditspassed34 <=creditstogetMPHYS34 and Info.overallmark >= boundaryfirst:            honours = 1            degclass = 3            demote = 1            Info.failreason = 'Not enough credits ({0:d}) over Y3/Y4'.format(creditspassed34)        elif creditspassed34>=creditstogetMPHYS34 and Info.overallmark>=boundaryupper2 and Info.overallmark<boundaryfirst:            honours = 1            degclass = 3        elif creditspassed34>=creditstogetMPHYSlower34 and creditspassed34 <=creditstogetMPHYS34 and Info.overallmark>=boundaryupper2 and Info.overallmark<boundaryfirst:            honours = 1            degclass = 2            demote = 1            Info.failreason = 'Not enough credits ({0:d}) over Y3/Y4'.format(creditspassed34)        elif creditspassed34>=creditstogetMPHYS34 and Info.overallmark>=boundarylower2 and Info.overallmark<boundaryupper2:            honours = 1            degclass = 2        else: # Fail            honours=0            degclass=-1            fail = 1            demote = 1            if (creditspassed34<=creditstogetMPHYSlower34): Info.failreason = 'Not enough credits ({0:d}) for MPhys over Y3/Y4'.format(creditspassed34)            # MPhys - for before 2024 when only considering Y4 credits    elif (Info.AY < 2024 and Info.classyear == 4):        if  creditspassed>=creditstogetMPHYS and Info.overallmark>=boundaryfirst:            honours=1            degclass=4        elif creditspassed >= creditstogetMPHYSlower and creditspassed <=creditstogetMPHYS and Info.overallmark >= boundaryfirst:            honours = 1            degclass = 3            demote = 1        elif creditspassed>=creditstogetMPHYS and Info.overallmark>=boundaryupper2 and Info.overallmark<boundaryfirst:            honours = 1            degclass = 3        elif creditspassed>=creditstogetMPHYSlower and creditspassed <=creditstogetMPHYS and Info.overallmark>=boundaryupper2 and Info.overallmark<boundaryfirst:            honours = 1            degclass = 2            demote = 1        elif creditspassed>=creditstogetMPHYS and Info.overallmark>=boundarylower2 and Info.overallmark<boundaryupper2:            honours = 1            degclass = 2        else: # Fail            honours=0            degclass=-1            fail = 1            demote = 1    # Put back into Info    Info.honours  = honours    Info.degclass = degclass    Info.fail     = fail    Info.demote   = demote        return Info################################################################# Apply promotion to borderline students in final yeardef apply_promotion(Info):    if (Info.finalyear == False and Info.mphys_to_bsc == False): # if not final year do not continue        return Info    # If BZ column contains a 'XB' or 'BX' then extend bounary zones by one (to account for COVID years - Judith email 03-Jun-2025)    extend_boundary = 0    if ('xb' in Info.boundary_zone.lower() or 'bx' in Info.boundary_zone.lower()):        extend_boundary = -1            # Also additional exception for 2025 Y4 only - one student is direct entry and should not have extended boundaries    if (Info.emplid == '11184110' and Info.AY == 2025 and Info.classyear == 4):        extend_boundary = 0  # put back to normal            # determine if borderline or not    if( (Info.overallmark >= (borderfirst+extend_boundary) and Info.overallmark < boundaryfirst) or (Info.overallmark >= (borderupper2+extend_boundary) and Info.overallmark < boundaryupper2) or (Info.overallmark >= (borderlower2+extend_boundary) and Info.overallmark < boundarylower2) or (Info.overallmark>=(borderthird+extend_boundary) and Info.overallmark<boundarythird)):        Info.borderline = True        Info.promote    = False    else:   # Just carry on if not borderline        Info.borderline = False        Info.promote = False        return Info    # do not continue if student has been demoted for not enough credits, continue    if (Info.demote == True): # (put here so borderline information is recorded above)        return Info            # If borderline see if can be promoted    if (Info.borderline == True):        # Apply algorithm A        if (Info.classyear == 32 or Info.classyear == 31):  # BSc or MPhys Y3 -> BSc            if(Info.degclass==3 and Info.credsatfirst>=creditstogetBScgood):                Info.promote=True            elif(Info.degclass==2 and Info.credsaboveupper2>=creditstogetBScgood):                Info.promote=True            elif(Info.degclass==1 and Info.credsabovelower2>=creditstogetBScgood):                Info.promote=True        else: # MPhys            if (Info.degclass == 3 and Info.credsatfirst >= creditstogetMPHYSalgA):                Info.promote = True            elif (Info.degclass == 2 and Info.credsaboveupper2 >= creditstogetMPHYSalgA):                Info.promote = True            elif (Info.degclass == 1 and Info.credsabovelower2 >= creditstogetMPHYSalgA):                Info.promote = True        # If A is successful, promote and return        if (Info.promote == True):            Info.promotetype = 'A'            Info.degclass += 1            return Info        # if A doesn't work, try algorithm B        if(Info.classyear == 32 or Info.classyear == 31):  # BSc or MPhys Y3 -> BSc            if(Info.degclass==3 and Info.credsatfirst >= creditstogetalgB and Info.projectmark>=boundaryfirst and Info.yearmark>Info.overallmark):                Info.promote=True            elif(Info.degclass==2 and Info.credsaboveupper2 >= creditstogetalgB and Info.projectmark>=boundaryupper2 and Info.yearmark>Info.overallmark):                Info.promote=True            elif(Info.degclass==1 and Info.credsabovelower2 >= creditstogetalgB and Info.projectmark>=boundarylower2 and Info.yearmark>Info.overallmark):                Info.promote=True        else: # MPhys            if (Info.degclass==3 and Info.credsatfirst >= creditstogetalgB and Info.projectmark>=boundaryfirst and Info.yearmark > Info.overallmark):                Info.promote = True            elif (Info.degclass==2 and Info.credsaboveupper2 >= creditstogetalgB and Info.projectmark>=boundaryupper2 and Info.yearmark > Info.overallmark):                Info.promote = True            elif (Info.degclass==1 and Info.credsabovelower2 >= creditstogetalgB and Info.projectmark>=boundarylower2 and Info.yearmark > Info.overallmark):                Info.promote = True        # If B is successful, promote and return        if (Info.promote == True):            Info.promotetype = 'B'            Info.degclass += 1            return Info            return Info################################################################# If not already promoted, try applying promotion to borderline students in final year using 2/3 of assessed credits (output P(A_X)/P(B_X) to indicate this# (see Judith email 30-Jun-2022)# For AY=2024 - do not make changes to degree but just output PA_X/PB_X in review for information only def apply_promotion_x(Info):    if (Info.finalyear == False and Info.mphys_to_bsc == False):  # if not final year or has been demoted for not enough credits, continue        return Info    if (Info.promote == True):     # if already promoted, don't need to do anything        return Info    # If BZ column contains a 'XB' or 'BX' then extend bounary zones by one (to account for COVID years - Judith email 03-Jun-2025)    extend_boundary = 0    if ('xb' in Info.boundary_zone.lower() or 'bx' in Info.boundary_zone.lower()):        extend_boundary = -1    # Also additional exception for 2025 Y4 only - one student is direct entry and should not have extended boundaries    if (Info.emplid == '11184110' and Info.AY == 2025 and Info.classyear == 4):        extend_boundary = +1  # put back to normal            # determine if borderline or not    if( (Info.overallmark >= (borderfirst+extend_boundary) and Info.overallmark < boundaryfirst) or (Info.overallmark >= (borderupper2+extend_boundary) and Info.overallmark < boundaryupper2) or (Info.overallmark >= (borderlower2+extend_boundary) and Info.overallmark < boundarylower2) or (Info.overallmark>=(borderthird+extend_boundary) and Info.overallmark<boundarythird)):        Info.borderline = True        Info.promote    = False    else:   # Just carry on if not borderline        Info.borderline = False        Info.promote = False        return Info    # If borderline see if can be promoted    if (Info.borderline == True):        # get assessed credits only        assessedcredits = Info.creditstaken - Info.creditsexcluded # (this includes missing marks!)        creditstogetalgA_x = 0.6667 * assessedcredits        if (creditstogetalgA_x > 80): creditstogetalgA_x = 80  # don't have more than 80 (e.g. if taken 125+credits)                # Apply algorithm A        if (Info.classyear == 32):  # BSc            if(Info.degclass==3 and Info.credsatfirst>=creditstogetalgA_x):                Info.promote=True            elif(Info.degclass==2 and Info.credsaboveupper2>=creditstogetalgA_x):                Info.promote=True            elif(Info.degclass==1 and Info.credsabovelower2>=creditstogetalgA_x):                Info.promote=True        else: # MPhys            if (Info.degclass == 3 and Info.credsatfirst >= creditstogetalgA_x):                Info.promote = True            elif (Info.degclass == 2 and Info.credsaboveupper2 >= creditstogetalgA_x):                Info.promote = True            elif (Info.degclass == 1 and Info.credsabovelower2 >= creditstogetalgA_x):                Info.promote = True        # If A is successful, promote and return        if (Info.promote == True):            Info.promotetype = 'A_X'            Info.degclass += 1            # reset since this was only done for COVID in 2022            if (Info.AY >=2023):                Info.degclass -= 1                Info.promote = False # so not to change degree class                            return Info        creditstogetalgB_x = creditstogetalgA_x - 10   # -10 credits for alg B (usually 70 if no non-assessed courses)                # if A doesn't work, try algorithm B        if(Info.classyear == 32):  # BSc            if (Info.degclass==3 and Info.credsatfirst >= creditstogetalgB_x and Info.projectmark>=boundaryfirst and Info.yearmark>Info.overallmark):                Info.promote=True            elif (Info.degclass==2 and Info.credsaboveupper2 >= creditstogetalgB_x and Info.projectmark>=boundaryupper2 and Info.yearmark>Info.overallmark):                Info.promote=True            elif (Info.degclass==1 and Info.credsabovelower2 >= creditstogetalgB_x and Info.projectmark>=boundarylower2 and Info.yearmark>Info.overallmark):                Info.promote=True        else: # MPhys            if (Info.degclass==3 and Info.credsatfirst >= creditstogetalgB_x and Info.projectmark>=boundaryfirst and Info.yearmark > Info.overallmark):                Info.promote = True            elif (Info.degclass==2 and Info.credsaboveupper2 >= creditstogetalgB_x and Info.projectmark>=boundaryupper2 and Info.yearmark > Info.overallmark):                Info.promote = True            elif (Info.degclass==1 and Info.credsabovelower2 >= creditstogetalgB_x and Info.projectmark>=boundarylower2 and Info.yearmark > Info.overallmark):                Info.promote = True        # If B is successful, promote and return        if (Info.promote == True):            Info.promotetype = 'B_X'            Info.degclass += 1            # reset since this was only done for COVID in 2022            if (Info.AY >=2023):                Info.degclass -= 1                Info.promote = False # so not to change degree class                        return Info            return Info################################################################# convert degree class to a string for output grid# Also add extra variables for extra columnsdef degclass_to_string(Info):    if (Info.finalyear == False): # do nothing if not final year student        return Info    # deg classification    degclass_dict = {        4:"1",        3:"2.1",        2:"2.2",        1:"3",        0:"Ord.",        -1:"Fail",        -2:"NOT SET!!!"}    # degree type    degstr = Info.Plan.split('(')[0]    degstr = ''.join(degstr.split()) # remove white space in degree plan (e.g. MMath & Phys)    degstr = degstr + ' ' # have a gap at the end ready for classification below    # Add to Info, with new class and also add promotion string     if (Info.promote == True):        Info.degclass_str = degstr + degclass_dict[Info.degclass-1] + ' P(' + Info.promotetype + ')'    else:        Info.degclass_str = degstr + degclass_dict[Info.degclass] #             # Add 3 extra columns (one is used for borderline students)    Info.degclass_alg = degstr + degclass_dict[Info.degclass]    Info.degclass_actual = degstr + degclass_dict[Info.degclass]        if (Info.borderline == True):        if (Info.promote == True):            Info.degclass_review = 'P' + Info.promotetype            Info.degclass_actual = degstr + degclass_dict[Info.degclass]    # actual is correct one                        # alg class depends on promotetype (A Uni-wide = algorithm, but B is department so should be original class)            if (Info.promotetype == 'A'):                Info.degclass_alg    = degstr + degclass_dict[Info.degclass]    # algorithmic is the correct one            elif (Info.promotetype == 'B'):                Info.degclass_alg    = degstr + degclass_dict[Info.degclass-1]    # algorithmic is the original one (so CS Override shows this)                    else:            Info.degclass_review = 'CR/marks'   # not promoted or inadequeate credits    if ('MA9' in Info.mitcirc_codes): Info.degclass_review += ' MA9'  # also add this code if exists (Judith request June 2023)    # since PA_X/PB_X is not algorithmic, do not change the degree (promote) but ensure PA_X/PB_X is outputted for information    if (Info.promote == False and Info.promotetype == 'A_X' or Info.promotetype == 'B_X'):        Info.degclass_review = 'P' + Info.promotetype            return Info################################################################# If MPhys fail, see if can get BSc based on Y1-Y3 marks# Also correct MPhys award/classification variables for CS 1-line formatdef degclass_MPhys_to_BSc(Info):    if (Info.classyear != 4 or Info.mphys_to_bsc == False):        return Info        # If 4th year MPhys fail, output BSc based on Y1-Y3 marks     # Only fail if less than 2 years worth of marks    if (Info.fail == True or Info.mphys_to_bsc == True):        Info2 = copy.deepcopy(Info)  # make temporary Info to trick functions that it is BSc not MPhys        Info2.classyear = 32    # Convert to a BSc student         plan = Info.Plan        Info2.Plan = plan.replace('BSc','MPhys') # Convert to a BSc student        if (Info.mathstudent == False): Info2.yearmark = Info.phys3   # 3rd year mark is now finalyear mark        else: Info2.yearmark = Info.year3mark                         # Average Phys/Math for M+P students        Info2.phys3 = -1              # set this back to -1        Info.math3  = -1              # set this back to -1        Info2 = get_overallmark(Info2)  # Get overall mark if CF available        newoverallmark = Info2.overallmark    # new overall mark        Info.newoverallmark = round(newoverallmark+0.00001,1)  # add to Info        if (newoverallmark>boundaryfirst):            Info.degclass_str = 'BSc 1' + ' (' + str(newoverallmark) + '%)'            Info.degclass_alg = 'BSc 1'            Info.degclass = 4            Info.honours = 1            Info.degclass_review = Info.degclass_str            Info.degclass_actual = Info.degclass_alg        elif (newoverallmark>boundaryupper2):            Info.degclass_str = 'BSc 2.1' + ' (' + str(newoverallmark) + '%)'            Info.degclass_alg = 'BSc 2.1'            Info.degclass = 3            Info.honours = 1            Info.degclass_review = Info.degclass_str            Info.degclass_actual = Info.degclass_alg        elif (newoverallmark>boundarylower2):            Info.degclass_str = 'BSc 2.2' + ' (' + str(newoverallmark) + '%)'            Info.degclass_alg = 'BSc 2.2'            Info.degclass = 2            Info.honours = 1            Info.degclass_review = Info.degclass_str            Info.degclass_actual = Info.degclass_alg        elif (newoverallmark>boundarythird):            Info.degclass_str = 'BSc 3' + ' (' + str(newoverallmark) + '%)'            Info.degclass_alg = 'BSc 3'            Info.degclass = 2            Info.honours = 1            Info.degclass_review = Info.degclass_str            Info.degclass_actual = Info.degclass_alg        else:            Info.degclass_str = 'Fail'            Info.degclass_alg = 'Fail'            Info.degclass = -1            Info.degclass_review = Info.degclass_str            Info.degclass_actual = Info.degclass_alg            Info.honours = 0                # Reset fail/fail reason as necessary        if (Info.degclass_str.lower().find('fail') >=0):            Info.fail = True            Info.failreason = 'Fail BSc (< 40%)'            Info.finalyear = True  # to ensure sorting of students is done correctly at the end        elif (Info.faillabprog == True): # to catch MPhys -> BSc with failed lab/project            Info.fail = True            Info.failreason = 'Fail lab/project -> BSc'            Info.finalyear = True  # to ensure sorting of students is done correctly at the end        else:            Info.fail = False            Info.finalyear = True  # to ensure sorting of students is done correctly at the end        # Check that there are at least 2 years of marks otherwise it is still a fail (chat with Judith 30-Jun-2022)        markyears = [Info.phys1, Info.phys2, Info.phys3]        idx = [i for i, x in enumerate(markyears) if x < 0]        if (len(idx) > 1):            Info.fail = True            Info.failreason = '(<2 years BSc marks)'            Info.degclass_str = 'Fail ' + Info.failreason            Info.degclass_alg = 'Fail'            Info.degclass_review = Info.degclass_str            Info.degclass_actual = Info.degclass_alg                return Info################################################################# Check status from input ("AS Code") and compare with PyAssess/overridedef check_status(Info):    # check against PyAssess status    if (Info.AScode == 'ACTV' and Info.status != 'ACTV'):        print('*WARNING: AScode ({0:s}) and Status ({1:s}) do not agree'.format(Info.AScode,Info.status))    #elif (Info.AScode == 'REVW' and Info.status != 'REVW'):    #    print('*WARNING: AScode ({0:s}) and Status ({1:s}) do not agree'.format(Info.AScode,Info.status))                # replace codes for some circumstances    if (Info.AScode == 'COMP'): # completed and already given degree award        Info.status = 'Completed'    elif (Info.AScode == 'LEFT' or Info.AScode == 'EXCL' or Info.AScode == 'EXIT'):  # withdrawn        Info.status = 'Withdrawn'        Info.withdrawn = True            elif (Info.AScode == 'RFYR' or Info.AScode == 'RYIA' or Info.AScode == 'RYOA'):  # repeat year (interrupting)        Info.interrupt = True    elif (Info.AScode == 'ACTR' or Info.AScode == 'MACT' or Info.AScode == 'PCFL' or Info.AScode == 'SPCL'): # ignore these        return Info            return Info################################################################# Check yearmark against input grid (if available)def check_overallmarks(Info, check_marks):    if (check_marks == False):  # If not set to True, do nothing        return Info        # get input yearmark if available    if (Info.classyear == 1):       Info.input_yearmark = Info.L1CM    elif (Info.classyear == 2):        Info.input_yearmark = Info.L2CM    elif (Info.classyear == 31 or Info.classyear == 32):        Info.input_yearmark = Info.L3CM    elif (Info.classyear == 4):        Info.input_yearmark = Info.L4CM    # compare yearmark against PyAssess if available    if (Info.yearmark >=0 and Info.input_yearmark >=0):        diff = Info.input_yearmark - Info.yearmark        if (np.abs(diff) > 0.05):            Info.yearmark_not_consistent = True            print('*WARNING: Yearmark ({0:.1f}) does not agree with input ({1:.1f})'.format(Info.yearmark,Info.input_yearmark))            if (np.abs(diff) < 0.11):                Info.yearmarkout = Info.yearmarkout + '*' + '{0:+.2f}'.format(diff)            else:                Info.yearmarkout = Info.yearmarkout + '**' + '{0:+.1f}'.format(diff)                                    # compare overllmark against PyAssess if available    if (Info.overallmark >=0 and Info.input_overallmark >=0):        diff = Info.input_overallmark - Info.overallmark        if (np.abs(diff) > 0.05):            Info.overallmark_not_consistent = True            print('*WARNING: Overallmark ({0:.1f}) does not agree with input ({1:.1f})'.format(Info.overallmark,Info.input_overallmark))            if (np.abs(diff) < 0.11):                Info.overallmarkout = Info.overallmarkout + '*' + '{0:+.2f}'.format(diff)            else:                Info.overallmarkout = Info.overallmarkout + '**' + '{0:+.1f}'.format(diff)                return Info################################################################# Check degree award/classification againt input grid (if available)def check_deg_award(Info, check_degree):    if (Info.finalyear == False or check_degree==False):  # if not final year or if check_degree=False, do nothing        return Info        # compare degree award    if ((Info.award.lower() not in Info.input_award.lower()) and (Info.input_award.lower() not in Info.award.lower()) ):        Info.award_not_consistent = True        Info.degclass_alg = Info.degclass_alg + '**'        print('*WARNING: Degree award ({0:s}) does not agree with input ({1:s})'.format(Info.award,Info.input_award))            # compare degree classification    if (Info.classification.lower() not in Info.input_classification.lower()):        if (Info.input_classification.lower().find('xxx') >=0 and Info.degclass_alg.lower().find('fail') >=0): # if 'XXX' its equivalent to a fail            pass        else:            Info.classification_not_consistent = True            Info.degclass_alg = Info.degclass_alg + '**'            print('*WARNING: Degree classification ({0:s}) does not agree with input ({1:s})'.format(Info.classification,Info.input_classification))                return Info################################################################# cleanup PP/study in Europe/abroad status/deg/overall mark if not avaialble# also use this to blank/cleanup students with unknown codes/circumstancesdef cleanup_nomark_students(Info):    # If no courses listed at all so no credits taken, don't show averages/fail    if (Info.creditstaken <= 0):        Info.degclass_str = ''        Info.degclass_alg = ''        Info.degclass_review = ''        Info.degclass_actual = ''        Info.status = 'No marks'        Info.failreason = ''        Info.yearmark = -1        Info.overallmark = -1    # If clearly a lot of missing marks, don't show fail    if (Info.creditstaken <= 80):        Info.degclass_str = ''        Info.degclass_alg = ''        Info.degclass_review = ''        Info.degclass_actual = ''        Info.status = ''        Info.failreason = 'Many marks (>=40 credits) missing!'            # If PP with no final year marks but still may have a coursename in the list with credit    # check for PHYS30810 rather than PP for PP students because if they fail, no longer a PP student!    if (Info.PHYS30810 == True and Info.PPaway == True):        Info.degclass_str = 'Intercal'        Info.degclass_alg = 'Intercal'        Info.degclass_review = ''        Info.degclass_actual = 'Intercal'        Info.award = ''        Info.award2 = ''        Info.classification = ''        Info.classification2 = ''        Info.status = 'Intercal'        Info.fail = False        Info.failreason = ''        Info.overallmark = -1        Info.codesout = Info.mitcirc_codes.copy() #             # If study abroad/PP and have PHYS31000/PHYS41000 with no marks, indicate in output as "Intercal" (Judith email 01-Jul-2022)    #abroadunits_idx = np.array([i for i, names in enumerate(Info.coursenames) if ('PHYS31000' in names or 'PHYS41000' in names or 'PHYS30810' in names or 'PHYS40810' in names)])    abroadunits_idx = np.array([i for i, names in enumerate(Info.coursenames) if ('PHYS31000' in names or 'PHYS41000' in names or 'PHYS40810' in names)])    if (len(abroadunits_idx) > 0):        marks = np.array(Info.marks)        markstotal = np.sum(marks[abroadunits_idx])        if (markstotal < 0):            Info.degclass_str = '' #'Intercal'            Info.status = 'Intercal'            Info.degclass_alg = '' # 'Intercal'            Info.degclass_review = '' # 'Intercal'            Info.fail = False            Info.failreason = ''            Info.overallmark = -1            Info.overallmark_lohi = '' # to prevent a box appearing            Info.overallmark_extremes_str = ''  # to ensure blank            Info.codesout = Info.mitcirc_codes.copy()  # keep codes on CS sheet                # If known to be interrupting do not calculate year/overall mark/degree classification etc. and mark as interrupting    if (Info.interrupt == True):        Info.degclass_str = 'Interrupt'        Info.status       = 'Interrupt'        Info.degclass_alg = 'Interrupt'        Info.degclass_review = ''        Info.degclass_actual = 'Interrupt'        Info.award = ''        Info.award2 = ''        Info.classification = ''        Info.classification2 = ''        Info.fail         = False        Info.failreason   = ''        Info.yearmark     = -1 # to ensure students are at the bottom of the grid        Info.overallmark  = -1 # to ensure all at bottom of grid        Info.referredcoursenames = ''        Info.deferredcoursenames = ''        Info.codesout = Info.mitcirc_codes.copy()    # keep codes on CS sheet    # If in the "for manual completion" list due to insufficient/ioncorrect information, mark and blank     if (Info.manual == True):        Info.degclass_str = ''        Info.status       = ''        Info.degclass_alg = ''        Info.degclass_review = ''        Info.degclass_actual = ''        Info.award = ''        Info.award2 = ''        Info.classification = ''        Info.classification2 = ''        Info.fail         = False        Info.failreason   = 'For manual completion (insufficient/incorrect info)'        Info.yearmark     = -1 # to ensure students are at the bottom of the grid        Info.overallmark  = -1 # to ensure all at bottom of grid        Info.referredcoursenames = ''        Info.deferredcoursenames = ''        Info.codes = Info.mitcirc_codes.copy()  # keep codes on CS sheet (blank anyway)    if (Info.withdrawn == True):        Info.degclass_str = ''        Info.status       = 'Withdrawn'        Info.degclass_alg = ''        Info.degclass_review = ''        Info.degclass_actual = ''        Info.award = ''        Info.award2 = ''        Info.classification = ''        Info.classification2 = ''        Info.fail         = False        Info.failreason   = 'Withdrawn'        Info.yearmark     = -1 # to ensure students are at the bottom of the grid        Info.overallmark  = -1 # to ensure all at bottom of grid        Info.referredcoursenames = ''        Info.deferredcoursenames = ''        Info.codesout = Info.mitcirc_codes.copy()  # keep codes on CS sheet (blank anyway)            # ***Temporarily blank out columns where we don't understand the codes (yet!) and make a note for the pre-board    # Only for Y1/Y2 2023 and not resits    unknown_codes = ['ror', 'rof', 'rwf', 'r2', 'l1c', 'r1']    #codes = Info.orig_codes.copy()    if (AY==2023 and Info.resitgrid == False):        codes = Info.en_codes.copy()  # for now go back to original input codes to identify RoR etc.        codes = [x.lower() for x in codes]        j = 0 # counter        for ucode in unknown_codes:            if ucode in codes:                Info.manual = True   # so can output list at the end                Info.status = ''                Info.yearmark = -1                Info.overallmark = -1                Info.referredcoursenames = ''                Info.deferredcoursenames = ''                Info.codesout = Info.mitcirc_codes.copy()  # keep codes on CS sheet (blank anyway)                # output string with code(s)                if (j == 0):                    Info.failreason = 'For manual completion: contains {0:s}'.format(ucode.upper())                else:                    Info.failreason += ', ' + ucode.upper()                j += 1  # add to counter                # or if repeating, blank out columns for manual completion    if (Info.repeating == True):        Info.status = ''        Info.yearmark = -1        Info.overallmark = -1        Info.failreason = 'For manual completion (repeating student)'        Info.referredcoursenames = ''        Info.deferredcoursenames = ''        Info.codesout = Info.mitcirc_codes.copy()  # keep codes on CS sheet (blank anyway)            return Info################################################################# cleanup "manual" students def cleanup_manual_students(Info):    # If in the "for manual completion" list due to insufficient/ioncorrect information, mark and blank     if (Info.manual == True):        Info.degclass_str = ''        Info.status       = ''        Info.degclass_alg = ''        Info.degclass_review = ''        Info.degclass_actual = ''        Info.award = ''        Info.award2 = ''        Info.classification = ''        Info.classification2 = ''        Info.fail         = False        Info.failreason   = 'For manual completion (insufficient/incorrect info)'        Info.yearmark     = -1 # to ensure students are at the bottom of the grid        Info.overallmark  = -1 # to ensure all at bottom of grid        Info.referredcoursenames = ''        Info.deferredcoursenames = ''        Info.codes = Info.orig_codes.copy()  # keep codes on CS sheet (blank anyway)        Info.codes2 = Info.orig_en_codes.copy()  # keep codes on 2-line sheet as well for info        Info.en_codes = Info.orig_en_codes.copy() # Original EN codes            return Info################################################################# make basic output dataframe including extra columns CS format def make_output_df():    # make list of all possible definite columns (more will be added later)    columns = ['ID No.', 'Emplid', 'Emplid*','Name', 'Admit Term', 'Plan',                'Unit 1', 'Code 1',                'Unit 2', 'Code 2',                'Unit 3', 'Code 3',                'Unit 4', 'Code 4',                'Unit 5', 'Code 5',                'Unit 6', 'Code 6',                'Unit 7', 'Code 7',                'Unit 8', 'Code 8',                'Unit 9', 'Code 9',                'Unit 10', 'Code 10',                'Unit 11', 'Code 11',                'Unit 12', 'Code 12',                'Unit 13', 'Code 13',                'Unit 14', 'Code 14',                'Unit 15', 'Code 15',                'Unit 16', 'Code 16',                'Unit 17', 'Code 17',                'Unit 18', 'Code 18',                'Unit 19', 'Code 19',                'Unit 20', 'Code 20',                'Credits Taken', 'Credits Passed', 'Credits Failed', 'Year Mark', 'Overall', 'Status', 'Resits', 'Referred', 'Deferred', 'Mit Circ']    # make dataframe    df = pd.DataFrame(columns=columns)    return df################################################################# add column data from this student (Info) to the output student dataframe# also output other columns used for CS format laterdef add_data_df(df,Info,encode_sids):    # First few columns    if (encode_sids == True):        new_row1 = {'ID No.': [Info.IDnumber], 'Emplid': [Info.emplid], 'Emplid*': [Info.emplid_encoded]}        new_row2 = {'ID No.': [''], 'Emplid': [''], 'Emplid*': ['']}    elif (Info.anonymous == False):        new_row1 = {'ID No.': [Info.IDnumber], 'Emplid': [Info.emplid]}        new_row2 = {'ID No.': [''], 'Emplid': ['']}    else:        new_row1 = {'ID No.': [Info.IDnumber], 'Emplid*': [Info.emplid_encoded]}        new_row2 = {'ID No.': [''], 'Emplid*': ['']}    # remove ID No. if blank (i.e. no ID number in input)    if (Info.IDnumber == ''):        del new_row1['ID No.']        del new_row2['ID No.']            # Next set of columns before units    new_row1['Name'] = [Info.Name]    new_row1['Admit Term'] = [Info.admitterm]    new_row1['Plan'] = [Info.Plan]    new_row2['Name'] = ['']    new_row2['Admit Term'] = ['']    new_row2['Plan'] = ['']            # Add each unit that exists - 2 columns per unit (mark and code)    for i in range(len(Info.coursenamesout)):        unit_str = 'Unit ' + str(i+1)        unitcode_str = 'Code ' + str(i+1)        new_row1[unit_str] = [Info.coursenamesout[i]]        new_row2[unit_str] = [Info.marksout[i]]      # Just mark with 2 column output        new_row1[unitcode_str] = ['']        new_row2[unitcode_str] = [Info.codesout[i]]    # Use codes2 for 2-Line output which has some slightly different codes                # Also Add extra columns required for CS format (on the 1st line of each student, 2nd line keep blank and will be removed later)        mark_str = 'Mark ' + str(i+1)        encode_str = 'EN ' + str(i+1)        mitcircs_str = 'Mit Circs ' + str(i+1)        new_row1[mark_str] = [Info.marksout[i]]       # Mark        new_row2[mark_str] = ['']        new_row1[encode_str] = [Info.en_codes[i]]    # EN codes from the input grid (for output to CS sheet later)        new_row2[encode_str] = ['']        new_row1[mitcircs_str] = [Info.mitcirc_codes[i]]   # Mit Circs         new_row2[mitcircs_str] = ['']    # Rest of default columns    new_row1['Creds Taken']      = [Info.creditstaken]    new_row1['Creds Passed']     = [Info.creditspassed]    new_row1['Creds Failed']     = [Info.creditsfailed]    new_row1['Creds Passed/Taken'] = [str(Info.creditspassed) + ' / ' + str(Info.creditstaken)]    new_row1['Credits Taken']      = [Info.creditstaken]    new_row1['Credits Passed']     = [Info.creditspassed]    new_row1['Credits Failed']     = [Info.creditsfailed]    new_row1['Phys/Math Creds Taken'] = [Info.creditstaken_pm]    new_row1['Creds 1']          = [Info.credsatfirst]    new_row1['Creds 2.1']          = [Info.credsatupper2]    new_row1['Creds 2.2']          = [Info.credsatlower2]    new_row1['Creds 3']          = [Info.credsatthird]    new_row1['Creds CF']          = [Info.credsatCF]    new_row1['Creds Total']        = [Info.creditstaken-Info.creditsexcluded]    new_row1['Phys Year Mark']     = [Info.phys_yearmark]    new_row1['Math Year Mark']     = [Info.math_yearmark]    new_row1['Year Mark']          = [Info.yearmarkout]    new_row1['Year Av O/P/M']      = [Info.year_opm]    new_row1['Status']             = [Info.status]    new_row1['Referred']           = [Info.referredcoursenames.rstrip(' / ')]    new_row1['Deferred']           = [Info.deferredcoursenames.rstrip(' / ')]    new_row1['Fail']               = [Info.fail]    new_row1['Pass / Fail']        = [Info.passfail]    new_row1['Fail reason']        = [Info.failreason]    if (Info.referredcoursenames == ''): # this is to ensure no trailing forward slash        new_row1['Resits']         = [Info.deferredcoursenames.rstrip(' / ')]    else:        new_row1['Resits']         = [Info.deferredcoursenames + Info.referredcoursenames.rstrip(' / ')]    temp = Info.boundary_notes + ' ' + Info.flagCF_notes + ' ' # notes    new_row1['Notes']              = [' '.join(temp.split())]  # add notes together    new_row1['Pre-Exam Board Minutes'] = [Info.preboard_notes]    new_row1['Exam Board Minutes'] = ['']         new_row2['Creds Taken']        = ['']    new_row2['Creds Passed']       = ['']    new_row2['Creds Passed/Taken'] = ['']    new_row2['Creds Failed']       = ['']    new_row2['Credits Taken']      = ['']    new_row2['Credits Passed']     = ['']    new_row2['Credits Failed']     = ['']    new_row2['Phys/Math Creds Taken'] = ['']    new_row2['Creds 1']            = ['']    new_row2['Creds 2.1']          = ['']    new_row2['Creds 2.2']          = ['']    new_row2['Creds 3']            = ['']    new_row2['Creds CF']           = ['']    new_row2['Creds Total']        = ['']    new_row2['Phys Year Mark']     = ['']    new_row2['Math Year Mark']     = ['']    new_row2['Year Mark']          = ['']    new_row2['Year Av O/P/M']      = ['']    new_row2['Status']             = ['']    new_row2['Referred']           = ['']    new_row2['Deferred']           = ['']    new_row2['Fail']               = ['']    new_row2['Pass / Fail']        = ['']    new_row2['Fail reason']        = ['']    new_row2['Resits']             = ['']    new_row2['Notes']              = ['']    new_row2['Exam Board Minutes'] = ['']    new_row2['Pre-Exam Board Minutes'] = ['']    # CF info if available    new_row1['L1CM']         = [Info.L1CM]    new_row1['L2CM']         = [Info.L2CM]    new_row1['L3CM']         = [Info.L3CM]    new_row1['L4CM']         = [Info.L4CM]    new_row1['Phys 1']         = [Info.phys1]    new_row1['Phys 2']         = [Info.phys2]    new_row1['Phys 3']         = [Info.phys3]    new_row1['Math 1']         = [Info.math1]    new_row1['Math 2']         = [Info.math2]    new_row1['Math 3']         = [Info.math3]    new_row1['Overall']        = [Info.overallmarkout]    new_row1['Phys Overall']   = [Info.overallphysmark]    new_row1['Math Overall']   = [Info.overallmathmark]    new_row1['Overall O/P/M']  = [Info.overallmark_opm]    new_row2['L1CM']           = ['']    new_row2['L2CM']           = ['']    new_row2['L3CM']           = ['']    new_row2['L4CM']           = ['']    new_row2['Phys 1']         = ['']    new_row2['Phys 2']         = ['']    new_row2['Phys 3']         = ['']    new_row2['Math 1']         = ['']    new_row2['Math 2']         = ['']    new_row2['Math 3']         = ['']    new_row2['Overall']        = ['']    new_row2['Phys Overall']   = ['']    new_row2['Math Overall']   = ['']    new_row2['Overall O/P/M']  = ['']    if (Info.finalyear == True):  # Final year students        new_row1['Honours']               = [Info.honours]        new_row1['Deg']                   = [Info.degclass]        new_row1['Deg Class']             = [Info.degclass_str]        new_row1['Deg Class Alg']         = [Info.degclass_alg]        new_row1['Deg Class Rev']         = [Info.degclass_review]        new_row1['Deg Class Actual']      = [Info.degclass_actual]  # same as alg except for promotetype B        new_row1['Award']                 = [Info.award] # *algorithmic* award        new_row1['Classification']        = [Info.classification] # *algorithmic* classification        new_row1['Award Alg']             = [''] #  will be an Excel formula        new_row1['Classification Alg']    = [''] # will be an Excel formula        new_row1['Award Actual']          = [''] # will be an Excel formula        new_row1['Classification Actual'] = [''] # will be an Excel formula        new_row1['']                      = ['']        new_row1['Award Change']          = [''] # will be an Excel formula        new_row1['Classification Change'] = [''] # will be an Excel formula                        new_row2['Honours']         = ['']        new_row2['Deg']             = ['']        new_row2['Deg Class']       = ['']        new_row2['Deg Class Alg']   = ['']        new_row2['Deg Class Rev']   = ['']        new_row2['Deg Class Actual']= ['']        new_row2['Award']           = ['']        new_row2['Classification']  = ['']        new_row2['Award Alg'] = ['']        new_row2['Classification Alg'] = ['']         new_row2['Award Actual']      = ['']         new_row2['Classification Actual'] = ['']        new_row1['']                  = ['']        new_row2['Award Change']      = [''] # will be an Excel formula        new_row2['Classification Change'] = [''] # will be an Excel formula    if (Info.classyear == 31): # Keep award/classification in for Y3 progressing as they not progress and get  BSc        new_row1['Award']                 = [''] # (but will be empty for this anyway ready for manual editing at exam board)        new_row2['Award']                 = ['']        new_row1['Classification']        = [''] # (but will be empty for this anyway ready for manual editing at exam board))        new_row2['Classification']        = ['']            if (Info.classyear == 4 and Info.mathstudent == True) : # for 4th M+P students        new_row1['Year 3']         = [Info.year3mark]        new_row2['Year 3']         = ['']    # level 3/4 credits passed for Y3/Y4 students (only for AY=2022)    if (Info.AY >= 2022 and (classyear == 31 or classyear == 32)):        new_row1['L3/L4 creds passed'] = [str(Info.credits3passed) + ' + ' + str(Info.credits4passed) + ' = ' + str(Info.credits34passed)]        new_row2['L3/L4 creds passed'] = ['']    # L3/L4 credits for Y4 credit counting    if (Info.AY >= 2025 and Info.classyear == 4):        new_row1['Y3 creds failed w/wo MCs'] = [str(Info.Y3creds_below40_mc) + '/' + str(Info.Y3creds_below40_nomc)]        new_row2['Y3 creds failed w/wo MCs'] = ['']        new_row1['Total L3/L4 creds passed'] = [Info.credits34passed]        new_row2['Total L3/L4 creds passed'] = ['']        new_row1['Total L4 creds passed'] = [Info.credits4total_passed]        new_row2['Total L4 creds passed'] = ['']        new_row1['L4 creds passed Y3+Y4'] = [str(Info.credits4total_passed-Info.credits4passed)+'+'+str(Info.credits4passed)+'='+str(Info.credits4total_passed)]        new_row2['L4 creds passed Y3+Y4'] = ['']    # Qdd boundary zone    new_row1['BZ'] = Info.boundary_zone    new_row2['BZ'] = ''            # if available add in extreme lo/hi yearmark/overall mark    if (Info.dooverall == True and (Info.finalyear == True or classyear==31)):        try:            new_row1['Year Mark lo/hi'] = [Info.yearmark_extremes_str]            new_row1['Overall lo/hi'] = [Info.overallmark_extremes_str]            new_row1['Overall lohi']    = [Info.overallmark_lohi]            new_row2['Year Mark lo/hi'] = ['']            new_row2['Overall lo/hi'] = ['']            new_row2['Overall lohi']    = ['']        except:            pass            # If a resit grid then blank some of the marks/final columns on the 2nd row    if (Info.resitgrid == True):        blank_columns = ['Status','Resits']        for col in blank_columns:            new_row1[col] = ['']            new_row2[col] = ['']                # add the new rows to the df    new_row1 = pd.DataFrame(data=new_row1)    new_row2 = pd.DataFrame(data=new_row2)    df = pd.concat([df,new_row1,new_row2], ignore_index=True, sort=False)        return df################################################################# Get maximum unit number used in a dataframe that actually contains datadef get_maxunit_number(df):    maxunit = 0  # counter    for i in range(20):  # max units will be 20        unit_str = 'Unit ' + str(i+1)        data     = df[unit_str].tolist()   # data for this unit number        if (any(data) == True): # check if any non-empty strings            maxunit += 1        return maxunit################################################################# Set output columns for output spreadsheet depending on student type/yeardef set_output_columns(Info,maxunit):    # First few columns are same for all (no Name if anonymous)    if (encode_sids == True):        columns = ['Emplid*', 'Emplid', 'Name', 'Plan']    elif (Info.anonymous == False):        columns = ['Emplid', 'Name', 'Plan']    else:        columns = ['Emplid*', 'Plan']    # if ID No. exists then add it as 1st column    if (Info.IDnumber != ''):        columns.insert(0,'ID No.')        # Units where data exist    for i in range(maxunit):        unit_str = 'Unit ' + str(i+1)        unitcode_str = 'Code ' + str(i+1)        columns.append(unit_str)        columns.append(unitcode_str)    # Credits passed/taken    columns.append('Creds Passed/Taken')  # combined column to save space    # Level 3/4 credits passed for Y3 students (for 2022 onwards)    if (Info.AY >= 2022):        if (Info.classyear == 31 or Info.classyear == 32): columns.append('L3/L4 creds passed')    # L3/L4 credits for Y4 for credit counting (from 2025 onwards)    if (Info.AY >= 2025 and classyear == 4):        columns.append('Y3 creds failed w/wo MCs')        columns.append('L4 creds passed Y3+Y4')                # Y3 credits below 40 (for 2024 onwards, Y4 only)    #if (Info.AY >= 2024 and Info.classyear == 4): columns.append('Y3 creds failed')                # Physics/maths credits if M+P student (only for <=2022)    if (Info.AY <= 2022 and Info.mathstudent == True):        columns.append('Phys/Math Creds Taken')        # Marks columns depending on years/student type    # Previous years marks (if doCF == True and not a resit grid)    if (Info.dooverall == True and Info.resitgrid == False):        if (Info.classyear == 2):            columns.append('Phys 1')        if (Info.classyear == 31 or classyear == 32):            columns.append('Phys 1')            columns.append('Phys 2')        if (Info.classyear == 4):            columns.append('Phys 1')            columns.append('Phys 2')            columns.append('Phys 3')            # Year mark    if (Info.mathstudent == True):  # Math students have O/P/M        if (Info.AY <= 2022):            columns.append('Year Av O/P/M')        else:            columns.append('Phys Year Mark')            columns.append('Math Year Mark')            columns.append('Year Mark')    else:        columns.append('Year Mark')  # default    # Overall mark only for Y3/Y4    if (Info.dooverall == True and Info.classyear != 1 and Info.classyear !=2):        if (Info.mathstudent == True): # extra columns for M+P (only for <=2022)            if (Info.AY <= 2022):                columns.append('Overall O/P/M')                columns.append('Phys Overall')                columns.append('Math Overall')            else:                columns.append('Overall')        else: # default            columns.append('Overall')    # If do_extremes == True, output extreme yearmark/overall mark    if (do_extremes == True):        #columns.append('Year Mark lo/hi')        if (Info.dooverall == True):            columns.append('Overall lo/hi')            #columns.append('Overall lohi')    # Deg Class if final year otherwise Status if not final year    if (Info.finalyear == True and Info.dooverall == True):        #columns.append('Deg Class')        columns.append('Deg Class Alg')        columns.append('Deg Class Rev')        columns.append('Deg Class Actual')        columns.append('Fail reason')        columns.append('Award')        columns.append('Classification')        columns.append('Award Alg')        columns.append('Award Actual')        columns.append('Classification Alg')        columns.append('Classification Actual')        columns.append('Award Change')        columns.append('Classification Change')    else: # always have status/fail reason        columns.append('Status')        columns.append('Fail reason')    # Keep award in for Y3 MPhys progressing    if (Info.classyear == 31):        columns.insert(columns.index('Status')+1, 'Award')   # immediately after Status            # Resits for Y1/Y2    if (Info.classyear == 1 or Info.classyear == 2):        columns.append('Resits')    # Finally add Boundary Notes if classyear==31 or above)     #if (Info.classyear == 31 or Info.classyear == 32 or Info.classyear == 4):    #    columns.append('Boundary Notes') #            # Finally add Exam Board Minutes and general notes column at the end (this is now combined with boundary_notes)    columns.append('Notes') #    columns.append('Pre-Exam Board Minutes')    columns.append('Exam Board Minutes')    # Insert BZ column before yearmark if Y3/Y4    if (classyear > 2):        idx = columns.index('Year Mark')        columns.insert(idx,'BZ')            # If resit grid remove some columns on output    #if (Info.resitgrid == True):    #    remove_columns = ['Resits']    #    remove_columns = []  # Empty (none removed)    #    for cols in remove_columns:    #        columns.remove(cols)                # Put coursenames back to replace Unit numbers if the input was that way    #unitcolumns_dict_reversed = dict([(value, key) for key, value in unitcolumns_dict.items()])    #keys = list(unitcolumns_dict_reversed.keys())    #items = list(unitcolumns_dict_reversed.items())    #for i in np.arange(len(keys)):        return columns################################################################# sort df by year mark (progressing) / overall mark (final year)# also add ID number after sortingdef sort_df(df,Info,sort_output=True):        # if sort_output = False, do not sort    if (sort_output == False):        return df    # progressing students    if (Info.resitgrid == False and Info.finalyear == False):        df = df.copy(deep=True) # to defragment (so to prevent warnings)        df["Year Mark Float"] = pd.Series(dtype=float)  # new column of floats for sorting        for i in np.arange(0,df.shape[0]-1,2): # duplicate float mark on each 2nd row            mark = df["Year Mark"].values[i].split('*') # in case of '*' in the string            if (mark[0] == ''): mark = [-1]            df.at[i,"Year Mark Float"] = float(mark[0])            df.at[i+1,"Year Mark Float"] = float(mark[0])        # finally do the sort        df.sort_values(by="Year Mark Float",ascending=False,inplace=True,kind='mergesort',ignore_index=True)        # remove extra column        df.drop(columns="Year Mark Float",inplace=True)            # graduating students    if (Info.resitgrid == False and Info.finalyear == True):        df = df.copy(deep=True) # to defragment (so to prevent warnings)        df["Overall Float"] = pd.Series(dtype=float)  # new column of floats for sorting        for i in np.arange(0,df.shape[0]-1,2): # duplicate float mark on each 2nd row            mark = df["Overall"].values[i].split('*') # in case of '*' in the string            if (mark[0] == ''): mark = [-1]            df.at[i,"Overall Float"] = float(mark[0])            df.at[i+1,"Overall Float"] = float(mark[0])        # finally do the sort        df.sort_values(by="Overall Float",ascending=False,inplace=True,kind='mergesort',ignore_index=True)        # remove extra column        df.drop(columns="Overall Float",inplace=True)    # resit grid (assumes 3-line)    if (Info.resitgrid == True):                df = df.copy(deep=True) # to defragment (so to prevent warnings)        df["Year Mark Float"] = pd.Series(dtype=float)  # new column of floats for sorting        for i in np.arange(0,df.shape[0]-1,3): # duplicate float mark on each 2nd row            mark = df["Year Mark"].values[i].split('*') # in case of '*' in the string             if (mark[0] == ''): mark = [-1]            df.at[i,"Year Mark Float"] = float(mark[0])            df.at[i+1,"Year Mark Float"] = float(mark[0])            df.at[i+2,"Year Mark Float"] = float(mark[0])        # finally do the sort        df.sort_values(by="Year Mark Float",ascending=False,inplace=True,kind='mergesort',ignore_index=True)        # remove extra column        df.drop(columns="Year Mark Float",inplace=True)            # Move "Intercal" or "Interrupt" status rows to the bottom to be clean    #rows = df[df.Status == "Intercal"]    #df.drop(index=df.loc[df["Status"] == 'Intercal'].index, inplace=True)    #df = pd.concat([df, rows])    # add "ID No." column to match df2 which is produces from this    #idnum = [] # list to populate with ID numbers    #num = 1   # ID number to start at    #for i in range(0,len(df)): # loop over each row    #    sid = df.loc[i,"Emplid"]    #    if  (sid != '' and len(sid) >= 7 and sid.isnumeric() == True): # check that looks like an SID    #        idnum.append(num)  # add to list    #        num += 1           # increment ID    #    else:    #        idnum.append('')   # add empty string to list for that row    #df["ID No."] = idnum       # Add column to DataFrame                return df################################################################# Add useful codes to end of spreadsheetdef add_codes_df(df):    code_info = np.array([['',''],                ['Key:',''], ['',''],                 #['Mit Circ','Mitigating Circumstances'],                 #['#','Mit Circs not accepted'],                #['#*','Mit Circs acc; no action'],                #['#**','Mit Circs acc; action taken'],                ['',''],                ['ACTV','Met progression criteria (BSc/MPhys)'],                ['REVW','Review (resits)'],                ['A/D', 'Deferred units'],                ['R/X','MPhys student not achieved 55%'],                ['R/BSc','MPhys student not achieved 52%'],                ['FAIL','Failed due to <40% overall or <40% in lab or <60 credits'],                ['',''],                #['XL','Absent from exam, with reason'],                ['XN','Absent from exam, no reason'],                ['X','Mark excluded'],                #['X1','Resit at first attempt'],                ['',''],                #['*', 'Carry Forward flag in year mark (ongoing mitigating circumstances)'],                ['AUD', 'Marks not being assessed'],                ['',''],                ['P(A)', 'Promotion for borderline student by stage 1 criteria'],                ['P(B)', 'Promotion for borderline student by stage 2 criteria'],                ['P(A_X)', 'Promotion for borderline studeny by 2/3 of assessed credits criteria'],                ['P(B_X)', 'Promotion for borderline student by 2/3 of asssessed credits criteria']])                #['XX_P1 (YY)', 'XX post-penalty mark, YY pre-penalty mark (>=40%)'],                #['XX_P2 (YY)', 'XX post-penalty mark, YY pre-penalty mark (30-39%)'],                #['XX_P3 (YY)', 'XX post-penalty mark, YY pre-penalty mark (<30%)'] ])        nextrarows = np.shape(code_info)[0]   # number of extra rows to add    tempdf_single = df.iloc[0:1,:].copy()  # single line temporary df    tempdf = tempdf_single.copy()  # tempdf to be added to main dataframe    while (tempdf.count()[0] <= nextrarows):  # copy extra rows if they required otherwise will not get full list of codes        tempdf = pd.concat([tempdf,tempdf_single])    tempdf[:] = ''  # blank values    for i in np.arange(nextrarows):  # add code info        tempdf.iloc[i:i+1,4] = code_info[i,0]        tempdf.iloc[i:i+1,5] = code_info[i,1]                df = pd.concat([df,tempdf])   # add df's together        return df, nextrarows################################################################# add header info lines including merged Unit cells and table header (for df2)# THIS IS NOT WORKING PROPERLY AT THE MOMENT - FIX LATERdef add_header_lines(df):    nextrarows = 3 + 2   # number of rows plus one for the merged Unit cells and one for the table header    tempdf = df.iloc[0,:].copy()  # single line temporary df    tempdf[:] = ''  # blank values    tempdf2 = tempdf.copy()    counter = 0    while (counter < nextrarows):  # copy extra rows if they required otherwise will not get full list of codes        counter += 1        tempdf = pd.concat([tempdf,tempdf2])    df = pd.concat([tempdf,df])  # add df's together        return df################################################################# Encode student IDs def encode_emplid(Info, encode_sids=False):    if (encode_sids == False): # Do nothing        return Info        sid = Info.emplid    ndigits = len(sid)    offsets = [1,2,3]*10  # long list of offsets to add to each digit *except* the last one    lastdigit = int(sid[-1])  # last digit for getting starting point of offset    sid_encoded = 'E'  # always begin with an "E" to show it is encoded        for i in range(ndigits-1):        digit = (int(sid[i]) + offsets[i] + lastdigit)%10   # add offset based on last digit then take last digit        sid_encoded += str(digit)    sid_encoded += str(lastdigit)   # add original last digit back which is needed to decode    Info.emplid_encoded = sid_encoded  # add back to Info                return Info################################################################# Add "_resit" to to outfilename (for resit grids)def add_resit_tofilename(filename, Info):    # If a resit grid, add "resit" to the filename    if (Info.resitgrid == True):        filename_list = filename.split('.')        filename = ''        for i in range(len(filename_list)-1):            filename += filename_list[i]            if (i < len(filename_list)-2):                filename += '.'        filename += '.resit.xlsx'    return filename        ################################################################# output to Excel spreadsheet (strings_to_numbers option so not to store unit numbers as text)# Note that no changes to the actual data (only formatting) should occur from this point onwards# except for adding excel formulaedef df_to_excel(df, Info, columns, nextrarows, outfilename='test.xlsx', df2=None, columns2=None):    sheet1_name = '2 Line format'     # Previous 2-line format    sheet2_name = 'CS 1 Line format'  # New CS format (1-line per student)    # See if the 2nd sheet is required (if df2 and columns2 exist)    dosheet2 = False # default    try:        if (not df2 and not columns2): dosheet2 = False    except:        dosheet2 = True   # If df2 and columns2 exist    try:        writer = pd.ExcelWriter(outfilename, engine='xlsxwriter', engine_kwargs={'options': {'strings_to_numbers': True}})        #writer = pd.ExcelWriter(outfilename, engine='xlsxwriter')    except:        print('\nERROR writing out to {0:s} Please check directory...\n'.format(outfilename))        print('If not, must be a problem using pd.ExcelWriter() - make sure it is installed etc.')        sys.exit(0)    # make dataframe with only columns that we need    df = df.filter(columns, axis=1)        # output columns to excel spredsheet directly from Data Frame    df.to_excel(writer,index=False,sheet_name=sheet1_name,columns=columns, float_format="%.1f")    df.to_excel(writer,index=False,sheet_name=sheet1_name,columns=columns)        # Change column width/formatting before finally writing out    workbook = writer.book    worksheet1 = writer.sheets[sheet1_name]   # Sheet name    format1dp = workbook.add_format({'num_format': '#0.0'})  # Add float formatting to 1.d.p.    format_right_justify = workbook.add_format({'align':'right'})  # Add right justify for yearmark/overallmark (not working because string_to_numbers)        i = 0  # column index is needed    for column_str in columns: # loop over each column        col_idx = i   # column index        format1 = None  # default is no format                # set the widths        if (column_str.find('ID N') >=0): col_width=3        elif (column_str.find('Emplid') ==0): col_width=8        elif (column_str == 'Name'): col_width=10        elif (column_str == 'Plan'): col_width=15        elif (column_str.find('Unit') >= 0): col_width=6        elif (column_str.find('Code') >= 0): col_width=6        elif (column_str.find('w/wo') >= 0): col_width=18        elif (column_str.find('Total L3/L4') >= 0): col_width=18        elif (column_str.find('Total L4') >= 0): col_width=14        elif (column_str.find('Y3+Y4') >= 0): col_width=16        elif (column_str.find('Creds') >= 0): col_width=15        elif (column_str.find('L3/L4 cred') >= 0): col_width=14        elif (column_str.find('Y3 creds') >= 0): col_width=11        elif (column_str.find('BZ') >=0): col_width=3        elif (column_str.find('Year Mark') ==0):            col_width=9            format1 = format_right_justify        elif (column_str.find('Overall') ==0):            col_width=8            format1 = format_right_justify        elif (column_str.find('Final Year Phys Mark') >=0):            col_width=16            format1 = format1dp        elif (column_str.find('Final Year Math Mark') >=0):            col_width=16            format1 = format1dp        elif (column_str.find('Year Mark lo/hi') >=0): col_width=18        elif (column_str.find('Overall lo/hi') >=0): col_width=10        elif (column_str.find('O/P/M') >=0): col_width=14        elif (column_str.find('Phys Overall') >=0): col_width=11        elif (column_str.find('Math Overall') >=0): col_width=11        elif (column_str.find('Phys Year Mark') >=0): col_width=12        elif (column_str.find('Math Year Mark') >=0): col_width=12                elif (column_str.find('Phys') >= 0): col_width=6        elif (column_str.find('Math') >= 0): col_width=7        elif (column_str.find('Year 3 Mark') >=0): col_width=8        elif (column_str.find('Status') >=0): col_width=9        elif (column_str.find('Deg Class') >= 0): col_width=13        elif (column_str.find('Resits') >= 0): col_width=40        elif (column_str.find('Mit') >= 0 or column_str.find('Sp') >=0): col_width=6        elif (column_str.find('Notes') >=0): col_width=35        elif (column_str.lower().find('reason') >=0): col_width=15        elif (column_str.lower().find('minutes') >=0): col_width=25        else: col_width=12  # default column width        # Write the format for this column        writer.sheets[sheet1_name].set_column(col_idx, col_idx, col_width+1,format1)  # Set column width and any other formatting                # Make sure year and overall marks are to 1 d.p. (e.g. 3.0 not 3)        # Doesn't work because mix of types float, strings and objects - need to convert all to floats first        #if (column_str.find('Year') >= 0 or column_str.find('Overall') >=0):        #    writer.sheets[sheet1_name].set_column(col_idx, col_idx, None, format1dp)        #    worksheet1.set_column(col_idx, col_idx, None, format1dp)        i += 1  # increment counter        # Apply 1 d.p. float to specific cells because they are overriden above due to applying to entire column    # Still not quite working so comment out action line below (background format etc not correct)    # First get list of columns that will have floats    cols_1dp = ['Phys 1', 'Phys 2', 'Phys 3', 'Math 1', 'Math 2', 'Math 3', 'Year Mark', 'Overall Mark', 'Phys Year Mark', 'Math Year Mark', 'Phys Overall', 'Math Overall']    # loop over the columns and cells containing float numbers (NOT PROPERLY IMPLEMENTED YET)    #cols_idx = [i for i, s in enumerate(columns) if columns[i] in cols_1dp] # Get column indices for unit coursename    nrows = df.count()[0]-nextrarows    for col in cols_1dp:  # loop over each column        if (col in columns):  # check to see if it exists first            col_idx_df = df.columns.get_loc(col)  # index of column in original df            col_idx    = columns.index(col)  # index of column in the output grid            for row_idx in np.arange(nrows):                temp = df.iloc[row_idx,col_idx_df]                                    #if (type(temp) != str and temp >=0): # only apply float format if it is a number of 0 or above (to leave -1s)                    #print(col, row_idx, col_idx, temp)                    #writer.sheets[sheet1_name].write_number(row_idx+1, col_idx, temp, format1dp)  # Works but overrides background colours etc.                # Make original id and name columns hidden if encode_sids option is set    # Also Award and Classification which is only really used for copying to the CS sheet (in rare cases such as P(B))    if (encode_sids == True):        col_idx = columns.index('Emplid')        worksheet1.set_column(col_idx, col_idx, None, None, {'hidden': True})        col_idx = columns.index('Name')        worksheet1.set_column(col_idx, col_idx, None, None, {'hidden': True})    if ('Award Alg' in columns): # hide column if it exists (final year)        col_idx = columns.index('Award Alg')        worksheet1.set_column(col_idx, col_idx, None, None, {'hidden': True})    if ('Award Actual' in columns): # hide column if it exists (final year)        col_idx = columns.index('Award Actual')        worksheet1.set_column(col_idx, col_idx, None, None, {'hidden': True})    if ('Classification Alg' in columns): # hide column if it exists (final year)        col_idx = columns.index('Classification Alg')        worksheet1.set_column(col_idx, col_idx, None, None, {'hidden': True})    if ('Classification Actual' in columns): # hide column if it exists (final year)        col_idx = columns.index('Classification Actual')        worksheet1.set_column(col_idx, col_idx, None, None, {'hidden': True})    if ('Award Change' in columns): # hide column if it exists (final year)        col_idx = columns.index('Award Change')        worksheet1.set_column(col_idx, col_idx, None, None, {'hidden': True})    if ('Classification Change' in columns): # hide column if it exists (final year)        col_idx = columns.index('Classification Change')        worksheet1.set_column(col_idx, col_idx, None, None, {'hidden': True})    if ('Classification' in columns): # hide column if it exists (final year)        col_idx = columns.index('Classification')        worksheet1.set_column(col_idx, col_idx, None, None, {'hidden': True})    if ('L3/L4 creds passed' in columns): # hide column if it exists (final year)        col_idx = columns.index('L3/L4 creds passed')        worksheet1.set_column(col_idx, col_idx, None, None, {'hidden': True})        # Hide "Award" in most cases but not Y3 MPhys (classyear==31) to allow manual editing    if ('Award' in columns and Info.classyear != 31): # hide column if it exists (final year) # Keep this visible on both sheets        col_idx = columns.index('Award')        worksheet1.set_column(col_idx, col_idx, None, None, {'hidden': True})    # format for grey/marged/headers    grey_colour = '#E0E0E0'    format_merge_header = workbook.add_format({'align': 'center', 'bold': True})  # bold format for merged cells    format_merge_grey = workbook.add_format({'bg_color': grey_colour, 'top':1, 'align': 'center'})    format_merge_white = workbook.add_format({'bg_color': False, 'top':1, 'align': 'center'})    format_grey_topline = workbook.add_format({'bg_color': grey_colour, 'top':1})    format_white_topline = workbook.add_format({'bg_color': False, 'top':1})    format_grey = workbook.add_format({'bg_color': grey_colour})    format_white = workbook.add_format({'bg_color': False})                # find shift for grey banding depending on number of rows per student and number of rows etc.    if (Info.resitgrid == True): rows_shift = 3    else: rows_shift = 2    cellheight = 17  # (Excel default is 15)    nrows = df.count()[0]-nextrarows    # get unit columns for merging    unit_cols_idx = [i for i, s in enumerate(columns) if 'unit' in s.lower()]  # Get columns for unit coursename    # Set format of rows including merging for unit row headers (2 columns for each unit)    if (Info.resitgrid == False):                for col in unit_cols_idx: # for each Unit column            worksheet1.merge_range(0, col, 0, col+1, columns[col], format_merge_header) # first header row        counter = 0 # counter for odd/even students        for row in range(1,nrows,rows_shift): # each row            counter += 1            if (counter % 2 == 0):                worksheet1.set_row(row, cellheight, cell_format=format_grey_topline)                worksheet1.set_row(row+1, cellheight-2, cell_format=format_grey)            else:                worksheet1.set_row(row, cellheight, cell_format=format_white_topline)                worksheet1.set_row(row+1, cellheight-2, cell_format=format_white)                                for col in unit_cols_idx: # for each Unit column                coursename = df.iloc[row-1,col]                #coursename = df.loc[row-1,columns[col]]                if (counter % 2 == 0):                    worksheet1.merge_range(row, col, row, col+1, coursename, format_merge_grey) # each unit row                else:                    worksheet1.merge_range(row, col, row, col+1, coursename, format_merge_white) # each unit row                               # Do it a little different for resit grids with 3 rows per student    elif (Info.resitgrid == True):        for col in unit_cols_idx: # for each Unit column            worksheet1.merge_range(0, col, 0, col+1, columns[col], format_merge_header) # first header row            for row in range(1,nrows,rows_shift): # each row                coursename = df.iloc[row-1,col]                #coursename = df.loc[row-1,columns[col]]                if (row % 2 == 1):                    worksheet1.set_row(row, cellheight-2, cell_format=format_grey_topline)                    worksheet1.set_row(row+1, cellheight-2, cell_format=format_grey)                    worksheet1.set_row(row+2, cellheight-2, cell_format=format_grey)                    worksheet1.merge_range(row, col, row, col+1, coursename, format_merge_grey) # each unit row                else:                    worksheet1.set_row(row, cellheight-2, cell_format=format_white_topline)                    worksheet1.set_row(row+1, cellheight-2, cell_format=format_white)                    worksheet1.set_row(row+2, cellheight-2, cell_format=format_white)                    worksheet1.merge_range(row, col, row, col+1, coursename, format_merge_white) # each unit row        # put box around any failed units in 2-line format    format_box1 = workbook.add_format({'border':6, 'bold':True})    format_box2 = workbook.add_format({'border':8, 'bold':True})    unit_strs = [unit for unit in columns if unit.find('Unit') >=0]    if (Info.resitgrid == True): # determine start/step size for values        start = 2        step = 3    else:        start = 1        step = 2    for unit_str in unit_strs:        vals = df[unit_str].to_list()        code_col = df.columns.get_loc(unit_str) + 1        codes = df.iloc[:,code_col].to_list()  # get codes in case of no mark but XN        for row_id in range(start,len(vals),step):  # re-write each mark with a box around it            col_id = df.columns.get_loc(unit_str)            try:  # if mark exists and < 40                mark = float(vals[row_id])                if (mark < 39.95):                     writer.sheets[sheet1_name].write(row_id+1,col_id, vals[row_id], format_box1)            except:                pass            try: # if no mark both times put a special box there in the first one (for MAB in 2023 e.g. HSTM no marks)                mark1 = str(vals[row_id])                mark2 = str(vals[row_id-1])                coursename = str(vals[row_id-2])                if ((mark1 == '' or mark1 == '-1') and (mark2 == '' or mark2 == '-1') and len(coursename) >8):                    writer.sheets[sheet1_name].write(row_id,col_id, vals[row_id], format_box2)            except:                pass                        try: # if no mark but XN or R2 in previous code (e.g. if A5) - this overrides any previous (different) boxes above                mark = str(vals[row_id])                if ((mark == '' or mark == '-1') and (codes[row_id].find('XN') >=0 or codes[row_id-1].find('R2') >=0)):                    writer.sheets[sheet1_name].write(row_id+1,col_id, vals[row_id], format_box1)            except:                pass                                    # if extremes exist, put box around any that are very different from the main mark or if they cross borders    all_columns = df.columns.to_list()    if ('Overall lohi' in all_columns):  # check original df columns not output columns (we don't output this variable)        col_id = columns.index('Overall lo/hi')  # index of *output* columns        vals = df["Overall lohi"].to_list()    # tell us if should be a box        vals_out = df["Overall lo/hi"].to_list()  # output        for row_id in range(len(vals)):            if (vals[row_id] != ''):                writer.sheets[sheet1_name].write(row_id+1,col_id, vals_out[row_id], format_box2)    # Optionally write a 2nd sheet with 1-line per student in CS format    if (dosheet2 == True):        startrow = 5  # number of header lines        df2.to_excel(writer,index=False,sheet_name=sheet2_name,columns=columns2, float_format="%.1f", header=True, startrow=startrow)        worksheet2 = writer.sheets[sheet2_name]   # Sheet name        # Change column width/formatting before finally writing out        worksheet2 = writer.sheets[sheet2_name]   # Sheet name        i = 0  # column index is needed        for column_str in columns2: # loop over each column            col_idx = i   # column index                    # set the widths            if (column_str.find('ID') >= 0): col_width=4            elif (column_str.find('Admit') >=0): col_width=9            elif (column_str.find('Entry') >=0): col_width=9            elif (column_str.find('Emplid') >=0): col_width=9            elif (column_str == 'Name'): col_width=20            elif (column_str == 'UF'): col_width=6            elif (column_str == 'MC'): col_width=6            elif (column_str == 'BZ'): col_width=6            elif (column_str == 'Plan'): col_width=25            elif (column_str == 'Classification'): col_width=9            elif (column_str.find('Module') >= 0): col_width=14            elif (column_str.find('Mark') == 0): col_width=5            elif (column_str.find('EN') >= 0): col_width=5            elif (column_str.find('Mit Circs') >= 0): col_width=5            elif (column_str.find('GPA') >= 0): col_width=13            elif (column_str.find('Exam') >= 0): col_width=20            elif (column_str.find('Chairs') >= 0): col_width=20            elif (column_str.find('Override') >= 0): col_width=17            elif (column_str.find('CM') >= 0): col_width=5            elif (column_str.find('Pass') >= 0): col_width=6            elif (column_str == '1st'): col_width = 4            elif (column_str == '2.1'): col_width = 4            elif (column_str == '2.2'): col_width = 4            elif (column_str == '3rd'): col_width = 4            elif (column_str == 'CF'): col_width = 4            elif (column_str == 'Fail'): col_width = 4            elif (column_str == 'Total'): col_width = 4            elif (column_str == 'Resits'): col_width = 40            else: col_width=13  # default column width            # Write the format for this column            #print(column_str, col_idx, col_width)            writer.sheets[sheet2_name].set_column(col_idx, col_idx, col_width+1,format1)  # Set column width and any other formatting            i += 1  # increment counter        # EXCEL FORMULAE!!!        # For all years - Exam Board Minutes, Notes -> dynamically copy from 2-line to CS 1-line        col_idx_id1 = columns.index('Emplid') # get column for Emplid on 1st sheet (2-Line)        col_idx_id2 = columns2.index('Emplid') # get column for Emplid on 2nd (CS 1-Line)        col_id1 = xlsxwriter.utility.xl_col_to_name(col_idx_id1)  # get column ID on 1st sheet (2-Line)        col_id2 = xlsxwriter.utility.xl_col_to_name(col_idx_id2)  # get column ID on 1st sheet (2-Line)        col_idx9 = columns2.index('Exam Board Minutes') # column on 2nd sheet        col_idx10 = columns2.index('Notes') # column on 2nd sheet                # Write formulae to sheet 2 (1-Line format) for ALL years        for i in range(startrow+1,len(dfout)+startrow+1):    # zero-indexed            row_idx = i+1  # Excel row (used in formulae)            # Exam Board Minutes (copy over from 2-Line Sheet)            formula1a = 'INDIRECT(ADDRESS(MATCH(' + col_id2 + str(row_idx) + ', \'2 Line format\'!' + col_id1 + ':' + col_id1 +',0), ' + 'MATCH(\"Exam Board Minutes\", \'2 Line format\'!1:1,0), , , \"2 Line format\"))'  # This gets the derived (algorithm) degclass            formula1 = '=\"\" & IFERROR(' + formula1a + ', \"\" )' # full formula (Exam Board Minutes)            # Notes (copy over from 2-Line Sheet)            formula2a = 'INDIRECT(ADDRESS(MATCH(' + col_id2 + str(row_idx) + ', \'2 Line format\'!' + col_id1 + ':' + col_id1 +',0), ' + 'MATCH(\"Notes\", \'2 Line format\'!1:1,0), , , \"2 Line format\"))'  # This gets the derived (algorithm) degclass            formula2 = '=\"\" & IFERROR(' + formula2a + ', \"\" )' # full formula (Notes)            # output formulae!            writer.sheets[sheet2_name].write_formula(i,col_idx9,formula1) # Output to Exam Board Minutes on 2nd sheet            writer.sheets[sheet2_name].write_formula(i,col_idx10,formula2) # Output to Notes on 2nd sheet        # Y1/Y2 only (e.g. resits -> dynamically copy from 2-line to CS 1-line)        if (Info.classyear == 1 or Info.classyear == 2):            col_idx11 = columns.index('Resits') # column number for Emplid on 1st sheet (2-line)            col_idx12 = columns2.index('Resits') # column number for Emplid on CS sheet (1-line)            col_id11 = xlsxwriter.utility.xl_col_to_name(col_idx11)  # get column ID             col_id12 = xlsxwriter.utility.xl_col_to_name(col_idx12)  # get column ID                     for i in range(startrow+1,len(dfout)+startrow+1):    # zero-indexed                row_idx = i+1  # Excel row (used in formulae)                # Resits (copy over from 2-Line Sheet)                formula1a = 'INDIRECT(ADDRESS(MATCH(' + col_id2 + str(row_idx) + ', \'2 Line format\'!' + col_id1 + ':' + col_id1 +',0), ' + 'MATCH(\"Resits\", \'2 Line format\'!1:1,0), , , \"2 Line format\"))'  # This gets the derived (algorithm) degclass                formula1 = '=\"\" & IFERROR(' + formula1a + ', \"\" )' # full formula (Exam Board Minutes)                # output formulae!                writer.sheets[sheet2_name].write_formula(i,col_idx12,formula1) # Output to Exam Board Minutes on 2nd sheet                    # Insert formulae to copy over changes from 2 Line format to CS 1 Line for - only for finalyear students        # Done using matching of Emplid/column name automatically        # Except for those that have been overriden by the algorithm (basically P(B) promotion)        if (Info.finalyear == True and Info.dooverall == True):            col_idx_id3 = columns.index('Award Alg')             col_idx_id4 = columns.index('Award Actual') #            col_idx_id5 = columns.index('Classification Alg') #            col_idx_id6 = columns.index('Classification Actual') #            col_idx_id7 = columns.index('Award Change') #            col_idx_id8 = columns.index('Classification Change') #             col_id3 = xlsxwriter.utility.xl_col_to_name(col_idx_id3)  #            col_id4 = xlsxwriter.utility.xl_col_to_name(col_idx_id4)  #            col_id5 = xlsxwriter.utility.xl_col_to_name(col_idx_id5)  #            col_id6 = xlsxwriter.utility.xl_col_to_name(col_idx_id6)  #            col_id7 = xlsxwriter.utility.xl_col_to_name(col_idx_id7)  #            col_id8 = xlsxwriter.utility.xl_col_to_name(col_idx_id8)  #            col_idx1 = columns2.index('Override Award') # column number on 2nd shhet            col_idx2 = columns2.index('Override Classification') # column number on 2nd sheet            col_idx3 = columns.index('Award Alg')            col_idx4 = columns.index('Award Actual')            col_idx5 = columns.index('Classification Alg')            col_idx6 = columns.index('Classification Actual')            col_idx7 = columns.index('Award Change')            col_idx8 = columns.index('Classification Change')                        # Write formulae to sheet 2 (1-Line format)            for i in range(startrow+1,len(dfout)+startrow+1):    # zero-indexed                row_idx = i+1  # Excel row (used in formulae)                # "Award Alg"                #formula3a = 'AN' + str(row_idx) # just gets value directly                #formula3a = 'MATCH(\"Deg Class Alg\", A1:ZZ1, 0)' # column number                #formula3a = 'ADDRESS(' + str(row_idx) + ', MATCH(' + '\"Deg Class Alg\", A1:ZZ1, 0))' # cell address                formula3a = 'INDIRECT(ADDRESS(' + str(row_idx) + ', MATCH(' + '\"Deg Class Alg\", A1:ZZ1, 0)))' # cell value!                formula3 = '=\"\" & ' + 'IFERROR(LEFT(' + formula3a + ', SEARCH(\" \", ' + formula3a + ',1)-1),' + formula3a + ')'  # better - if only 1 word                            # Award Actual                formula4a = 'INDIRECT(ADDRESS(' + str(row_idx) + ', MATCH(' + '\"Deg Class Actual\", A1:ZZ1, 0)))' # left cell value!!                formula4 = '=\"\" & ' + 'IFERROR(LEFT(' + formula4a + ', SEARCH(\" \", ' + formula4a + ',1)-1), \"\")'  # gets it!!                # Classification Alg                formula5a = 'INDIRECT(ADDRESS(' + str(row_idx) + ', MATCH(' + '\"Deg Class Alg\", A1:ZZ1, 0)))' # cell value!                formula5 = '=\"\" & ' + 'IFERROR(RIGHT(' + formula5a + ', LEN(' + formula5a + ')-SEARCH(\" \", ' + formula5a + ',1)),' + formula5a + ')'                 # Classification Actual                formula6a = 'INDIRECT(ADDRESS(' + str(row_idx) + ', MATCH(' + '\"Deg Class Actual\", A1:ZZ1, 0)))' # left cell value!!                formula6 = '=\"\" & ' + 'IFERROR(RIGHT(' + formula6a + ', LEN(' + formula6a + ')-SEARCH(\" \", ' + formula6a + ',1)), \"\")'  # gets it!!                # Award Change                formula7a = 'INDIRECT(ADDRESS(' + str(row_idx) + ', MATCH(' + '\"Award Alg\", A1:ZZ1, 0)))' # left cell value!!                formula7b = 'INDIRECT(ADDRESS(' + str(row_idx) + ', MATCH(' + '\"Award Actual\", A1:ZZ1, 0)))' # left cell value!!                formula7 = '=\"\" & IFERROR( IF( ' + formula7a + ' = ' + formula7b + ', \"\", ' + formula7b + '), \"\" )' # full formula (award)                # Classification Change                formula7a = 'INDIRECT(ADDRESS(' + str(row_idx) + ', MATCH(' + '\"Classification Alg\", A1:ZZ1, 0)))' # left cell value!!                formula7b = 'INDIRECT(ADDRESS(' + str(row_idx) + ', MATCH(' + '\"Classification Actual\", A1:ZZ1, 0)))' # left cell value!!                formula8 = '=\"\" & IFERROR( IF( ' + formula7a + ' = ' + formula7b + ', \"\", ' + formula7b + '), \"\" )' # full formula (award)                            # write formula to 1st sheet                writer.sheets[sheet1_name].write_formula(i,col_idx3,formula3) # Output to Award Alg on 1st sheet                writer.sheets[sheet1_name].write_formula(i,col_idx4,formula4) # Output to Award Actual on 1st sheet                writer.sheets[sheet1_name].write_formula(i,col_idx5,formula5) # Output to Classification Alg on 1st sheet                writer.sheets[sheet1_name].write_formula(i,col_idx6,formula6) # Output to Classification Alg on 1st sheet                writer.sheets[sheet1_name].write_formula(i,col_idx7,formula7) # Output to Award Change on 1st sheet                writer.sheets[sheet1_name].write_formula(i,col_idx8,formula8) # Output to Classification Change on 1st sheet                        # Write formulae to sheet 2 (CS 1-Line format)            for i in range(startrow+1,len(dfout2)+startrow+1):    # zero-indexed                row_idx = i+1  # Excel row (used in formulae)                        # Write general formulae                                                    # works well including matching emplid column                #formula1 = 'INDIRECT(ADDRESS(MATCH(' + col_id2 + str(row_idx) + ', \'2 Line format\'!' + col_id1 + ':' + col_id1 +',0), ' + 'MATCH(\"Deg Class Alg\", \'2 Line format\'!1:1,0), , , \"2 Line format\"))'  # This gets the derived (algorithm) degclass                #formula2 = 'INDIRECT(ADDRESS(MATCH(' + col_id2 + str(row_idx) + ', \'2 Line format\'!' + col_id1 + ':' + col_id1 + ',0), ' + 'MATCH(\"Deg Class Actual\", \'2 Line format\'!1:1,0), , , \"2 Line format\"))' # This gets the actual deg class                            # older less flexible versions                #formula1 = 'INDIRECT(ADDRESS(MATCH(B' + str(row_idx) + ', \'2 Line format\'!B:B,0), ' + 'MATCH(\"Deg Class Alg\", \'2 Line format\'!1:1,0), , , \"2 Line format\"))'  # This gets the derived (algorithm) degclass                #formula2 = 'INDIRECT(ADDRESS(MATCH(B' + str(row_idx) + ', \'2 Line format\'!B:B,0), ' + 'MATCH(\"Deg Class Actual\", \'2 Line format\'!1:1,0), , , \"2 Line format\"))' # This gets the actual deg class                # Override Award - THIS ONE WORKS!                formula1a = 'INDIRECT(ADDRESS(MATCH(' + col_id2 + str(row_idx) + ', \'2 Line format\'!' + col_id1 + ':' + col_id1 +',0), ' + 'MATCH(\"Deg Class Alg\", \'2 Line format\'!1:1,0), , , \"2 Line format\"))'  # This gets the derived (algorithm) degclass                formula1b = 'INDIRECT(ADDRESS(MATCH(' + col_id2 + str(row_idx) + ', \'2 Line format\'!' + col_id1 + ':' + col_id1 + ',0), ' + 'MATCH(\"Deg Class Actual\", \'2 Line format\'!1:1,0), , , \"2 Line format\"))' # This gets the actual deg class                formula1c = 'INDIRECT(ADDRESS(MATCH(' + col_id2 + str(row_idx) + ', \'2 Line format\'!' + col_id1 + ':' + col_id1 + ',0), ' + 'MATCH(\"Award Change\", \'2 Line format\'!1:1,0), , , \"2 Line format\"))' # This gets the actual deg award                # Override Classification - THIS ONE WORKS!                formula2a = 'INDIRECT(ADDRESS(MATCH(' + col_id2 + str(row_idx) + ', \'2 Line format\'!' + col_id1 + ':' + col_id1 +',0), ' + 'MATCH(\"Deg Class Alg\", \'2 Line format\'!1:1,0), , , \"2 Line format\"))'  # This gets the derived (algorithm) degclass                formula2b = 'INDIRECT(ADDRESS(MATCH(' + col_id2 + str(row_idx) + ', \'2 Line format\'!' + col_id1 + ':' + col_id1 + ',0), ' + 'MATCH(\"Deg Class Actual\", \'2 Line format\'!1:1,0), , , \"2 Line format\"))' # This gets the actual deg class                formula2c = 'INDIRECT(ADDRESS(MATCH(' + col_id2 + str(row_idx) + ', \'2 Line format\'!' + col_id1 + ':' + col_id1 + ',0), ' + 'MATCH(\"Classification Change\", \'2 Line format\'!1:1,0), , , \"2 Line format\"))' # This gets the actual deg classification                            formula1 = '=\"\" & IFERROR( IF( ' + formula1a + ' = ' + formula1b + ', \"\", ' + formula1c + '), \"\" )' # full formula (award)                formula2 = '=\"\" & IFERROR( IF( ' + formula2a + ' = ' + formula2b + ', \"\", ' + formula2c + '), \"\" )' # full formula (classification)                                # Write formula to 2nd sheet (CS 1-Line)                writer.sheets[sheet2_name].write_formula(i,col_idx1,formula1)  # Output to Override Award on 2nd sheet                writer.sheets[sheet2_name].write_formula(i,col_idx2,formula2) # Output to Override Classification on 2nd sheet                                                # For Y3 MPhys (classyear=31) add in formula to copy from 2-Line sheet to Override award (CS 1-line sheet)        if (Info.classyear==31):            col_idx_id1 = columns.index('Emplid') # get column for Emplid on 1st sheet (2-Line)            col_idx_id2 = columns2.index('Emplid') # get column for Emplid on 2nd (CS 1-Line)            col_idx_id3 = columns.index('Award')             col_id1 = xlsxwriter.utility.xl_col_to_name(col_idx_id1)  # get column ID on 1st sheet (2-Line)            col_id2 = xlsxwriter.utility.xl_col_to_name(col_idx_id2)  # get column ID on 1st sheet (2-Line)            col_id3 = xlsxwriter.utility.xl_col_to_name(col_idx_id3)  #            col_idx1 = columns2.index('Override Award') # column number on 2nd shhet                        # Write formulae to sheet 2 (CS 1-Line format)            for i in range(startrow+1,len(dfout2)+startrow+1):    # zero-indexed                row_idx = i+1  # Excel row (used in formulae)                        # Write general formula                # Override Award - THIS ONE WORKS!                formula1a = 'INDIRECT(ADDRESS(MATCH(' + col_id2 + str(row_idx) + ', \'2 Line format\'!' + col_id1 + ':' + col_id1 +',0), ' + 'MATCH(\"Award\", \'2 Line format\'!1:1,0), , , \"2 Line format\"))'  # This gets the derived (algorithm) degclass                formula1 = '=\"\" & IFERROR(' + formula1a + ', \"\" )' # full formula (award)                                # Write formula to 2nd sheet (CS 1-Line0                writer.sheets[sheet2_name].write_formula(i,col_idx1,formula1)  # Output to Override Award on 2nd sheet                    # Write out and finish    workbook.close()    #df.to_excel(outfilename,index=False,sheet_name=sheet1_name,columns=columns,engine='xlsxwriter')    #writer.save()  # deprecated    return None################################################################# write encoded sids to a file if encode_sids == Truedef write_encoded_sids(outfilename,all_sids, all_sids_encoded):    data = np.column_stack([all_sids, all_sids_encoded])    sidfilename = outfilename.split('.xls')[0] + '_sids.txt'    np.savetxt(sidfilename, data, fmt=['%s ','%s'])    return None################################################################# Add resit marks from 3rd row and replace marks as necessarydef get_resit_marks(Info, df, keep_input_resit_codes=False, fill_marks=False):    # determine if resitting - which means there is a 3rd row    if (len(df) != 3):        print('*ERROR: no 3rd row in input expected for resit grids...please check again...')        return Info    # add extra variables for previous marks etc. ('p_XXX')    Info.p_marks = Info.marks.copy()    Info.p_marksout = Info.marksout.copy()   # string for output marks (including potentially codes etc)    Info.p_credits = Info.credits.copy()    Info.p_codes = Info.codes2.copy()          # alternate 2-line version of the codes only for resits    Info.p_creditspassed = Info.creditspassed  # just int so no need to copy    Info.p_creditsfailed = Info.creditsfailed  # just int so no need to copy    Info.p_deferred_idx = Info.deferred_idx.copy()    Info.p_deferredcoursenames = Info.deferredcoursenames    Info.p_referred_idx = Info.referred_idx.copy()    Info.p_referredcoursenames = Info.referredcoursenames    Info.p_compensated_idx = Info.compensated_idx.copy()    Info.p_excluded_idx = Info.excluded_idx.copy()    Info.p_excludedcoursenames = Info.excludedcoursenames    Info.p_yearmark = Info.yearmark    Info.p_nomarks_idx = Info.nomarks_idx.copy()        # add variable to indicate we are working on the 3rd row (resit marks)    Info.secondpass = True        # blank variable to store just the resit marks and idx    Info.resitmarksout = ['']*len(Info.marks)    Info.resitmarks = []    Info.resit_idx = []    # also blank some other variables from the 1st pass so not to confuse later    Info.referred_idx = []    Info.referredcoursenames = ''    Info.deferred_idx = []    Info.deferredcoursenames = ''    Info.failed_idx = []    Info.excluded_idx = []    Info.excludedcoursenames = ''        # loop over each course in the output    columns = df.filter(regex='^Unit\ ',axis=1).columns.to_list()  # just unit columns    coursenames = Info.coursenames    row1 = df.iloc[0,:].to_list()    for i in range(len(Info.coursenames)):                idx = [x for x, s in enumerate(row1) if coursenames[i] in s][0]  # get index of column        data = df.iloc[:,idx].values  # get main data        code = df.iloc[2,idx+1]  # Get new codes for any courses                # add mark if available otherwise continue         mark_str = str(data[2])        # for testing non-complete grids with missing marks, optionally add in marks for checking codes/decisions etc.        if (fill_marks == True and mark_str == ''):            mark_str = '50'                if (mark_str == '' and code == ''):    # Keep original mark if nothing there unless there is a code             if (Info.p_codes[i] == 'X' or Info.p_codes[i] == '_X'):                Info.codes[i] = Info.p_codes[i]  # only exclude if 'X'        elif (mark_str == '' and len(code) > 0): # if no mark but a code (e.g. XL, XN) mark as a resit to include in output grid            Info.resit_idx.append(i)            Info.resitmarksout[i] = ''        else: # add resit data            try:  # if just a number (usually is)                Info.marks[i] = round(float(mark_str)+0.000001) # mark as a (rounded) integer                Info.resitmarks.append(Info.marks[i])                Info.resitmarksout[i] = mark_str # store for later                Info.resit_idx.append(i)            except: # if not just a number and code                if (mark_str == ''): # if empty                    Info.marks[i] = -1                    Info.resitmarksout[i] = ''                    Info.resit_idx.append(i)                elif (mark_str[0].isnumeric() == True):  # if XXC or XXR or XX_X get numerical mark                    Info.marks[i] = round(float(''.join([c for c in mark_str if c.isdigit()])))  # get only numerical values                    markcode = ''.join([c for c in mark_str if not c.isdigit()]) # get any code with the mark                    Info.resitmarksout[i] = str(Info.marks[i])  + markcode  # with markcode for reproduction                    Info.resit_idx.append(i)                    if ('C' in markcode and i not in Info.compensated_idx):  # if compensated make a note now                        Info.compensated_idx.append(i)                    #code = code # add mark code back to main code (but can change later)                else: # no numerical mark but not empty!                    print('*WARNING: no numerical (resit) mark [ {0:s} ] but not empty! Please check!...'.format(mark_str))            if i in Info.excluded_idx:        # Remove previous excluded courses now that a mark exists                #if (Info.codes[i].find('_C') < 0):  # do not exclude if previously compensated                if (i in Info.p_compensated_idx):  # do not exclude if previously compensated                    Info.excluded_idx.remove(i)                    Info.excludedcoursenames.remove(coursenames[i])            if i in Info.deferred_idx:        # Remove previous deferred courses now that a new mark exists                Info.deferred_idx.remove(i)                temp = Info.deferredcoursenames.split('/')                temp = [s for s in temp if s.find(coursenames[i]) < 0] # remove coursename from list                for j in range(len(temp)):                    Info.deferredcoursenames = temp[j] + ' / '               # For new input format (from 2024) add in Mit Circs codes for each module directly from input sheet        if (AY >= 2024):            mcc_codes = df.iloc[2,idx+2] # get the codes            if (',' in mcc_codes):  # split with , first                mcc_codes = df.iloc[2,idx+2].split(',')            elif ('/' in mcc_codes): # then try '/' because sometimes they use '/'                mcc_codes = df.iloc[2,idx+2].split('/')            if (isinstance(mcc_codes,list) and mcc_codes[0] != ''): # if multiple codes add them back and separate with '_'                for j in range(len(mcc_codes)):                    if (code == ''):                        code += mcc_codes[j] + '_'                    else:                        if (j == 0 and mcc_codes[j] not in code): # add '_' if code already exists and not already there                            code += '_' + mcc_codes[j] + '_'                        elif (mcc_codes[j] not in code): # add code if not already there                            code += mcc_codes[j] + '_'                code.replace('__', '_')  # remove extra '_' if exists                code  = code[:-1] # remove trailing '_'                code  = code.replace(' ', '') # remove any white space            else: # if just a single code add back                if (code == ''):                    code = mcc_codes                elif (mcc_codes not in code):                    code = code + '_' + mcc_codes        if (code != '' and code[-1] == '_'): code = code[:-1] # remove any final trailing '_'                    Info.codes[i] = code # add code back Info             # if keep_input_codes set to False, blank them, since they will be added in via external MCC file    # (Doesn't matter about code above since Info.codes will also have been blanked)    if (keep_input_resit_codes == False):        Info.codes = ['']*len(Info.codes)    # look for missing resit marks    # (for now, expect they will be there)                        # record courses with no mark for later     nomarks_idx = [i for i, j in enumerate(Info.marks) if j < 0]    # add the lists back to the Info object    Info.nomarks_idx = nomarks_idx    # Reset status to ACTV for the 2nd pass (so not to leave A/D for example)    Info.status = 'ACTV'        return Info################################################################# apply resit marks to be used for averages e.g. if capped, or use original mark etc.# Keep final marks array for yearmark for later, but initially output pre-capped etc. resit marksdef apply_resit_marks(Info):    # Copy actual marks to be used to another array    Info.marks_postcapped = Info.marks.copy()        # loop over each course that has been resat     for idx in Info.resit_idx:        # Decide which mark and output to use for resits        if (idx in Info.p_deferred_idx or idx not in Info.secondattempt_idx): # use new mark for previous deferrals or if R1/A1 code (i.e. 1st attempt) unless new mark is lower (and is not excluded) - see Judith email 26-Oct-2022            if (Info.p_marks[idx] > Info.marks[idx] and idx not in Info.excluded_idx):                Info.marks_postcapped[idx] = Info.p_marks[idx]            else:                Info.marks_postcapped[idx] = Info.marks[idx]        elif (idx in Info.compensated_idx and idx in Info.excluded_idx):  # if previously compensated must include in average            Info.excluded_idx.remove(idx)            Info.credweights[idx] = Info.credits[idx]        # if definitely 2nd attempt, apply resit mark caps        if (idx not in Info.p_deferred_idx and idx in Info.secondattempt_idx):            if (Info.p_marks[idx] >= 29.95):    # original mark if not under 30                 Info.marks_postcapped[idx] = Info.p_marks[idx]            elif (Info.p_marks[idx] < 29.95):                   if (Info.marks[idx] > 29.95 and idx not in Info.compensated_idx): # resit mark capped at 30 if original mark < 30 (if not compensated)                    Info.marks_postcapped[idx] = 30                                     # if OM>30 and resit < 30, put main marks back to fix referral issues later (someunitunder30 == True etc)            if (Info.marks[idx] < 29.95 and Info.p_marks[idx] >= 29.95):                Info.marks[idx] = Info.p_marks[idx]        # If lab with OM<40 and new mark is higher, likely that they did extra coursework (see Judith email 23-Apr-2024)        # So use new mark in average        mustpass_idx = [i for i, c in enumerate(Info.coursenames) if (c in mustpass)]         for idx in mustpass_idx:            if (Info.p_marks[idx] < 39.95 and Info.marks[idx] >= 39.95):                Info.marks_postcapped[idx] = Info.marks[idx]                    return Info################################################################# add 3rd row (resit) data from this student (Info) to the output student dataframe# and add other info to the 2nd row like averages/status (not 3rd)def add_resit_data_df(df,Info):    # Blank row    columns = df.columns.to_list()    new_row = {}    for col in columns:        new_row[col] = ['']    # add the rows to the df    new_row = pd.DataFrame(new_row)    df = pd.concat([df,new_row], ignore_index=True, sort=False)    # Put in resit marks into df directly where they exist into 3rd row along with any codes    idx = [x for x, name in enumerate(columns) if name.find('Unit') >= 0]    #for i in Info.resit_idx:  # only do this where there are new resit marks    for i in range(len(Info.coursenames)):        df.iloc[-1,idx[i]] = Info.resitmarksout[i]        df.iloc[-1,idx[i]+1] = Info.codes2[i]   # for 2-line format using codes2            # Put in averages and status to the 2nd row of df    idx = columns.index('Creds Passed/Taken')    df.iloc[-2,idx] = str(Info.creditspassed) + ' / ' + str(Info.creditstaken)    idx = columns.index('Year Mark')    df.iloc[-2,idx] = Info.yearmark    idx = columns.index('Year Av O/P/M')    df.iloc[-2,idx] = Info.year_opm    idx = columns.index('Status')    df.iloc[-2,idx] = Info.status    idx = columns.index('Fail reason')    df.iloc[-2,idx] = Info.failreason    idx = columns.index('Resits')    df.iloc[-2,idx] = Info.deferredcoursenames + Info.referredcoursenames.rstrip(' / ')        return df################################################################################################################################# some data definitions################################################################# Credits requiredcreditstogetMPHYS = 80creditstogetMPHYSlower = 60creditstogetMPHYS34 = 200  # from 2024 need to consider credits over Y3+Y4creditstogetMPHYSlower34 = 180  # from 2024 need to consider credits over Y3+Y4creditstogetBScgood=80creditstogetBSclower=60if (int(AY) <= 2019): creditstogetMPHYSalgA = 75 # Used for algA else: creditstogetMPHYSalgA = 80 # New rule for 2020 onwardscreditstogetalgB = 70  # Used for algB# boundaries for degree class (2 d.ps because marks are stored to 1 d.p.)boundaryfirst=69.95boundaryupper2=59.95boundarylower2=49.95boundarythird=39.95# borderlines for promotion consideration if (AY >= 2020 and AY <= 2024):    borderfirst = boundaryfirst - 3.0    borderupper2 = boundaryupper2 - 3.0    borderlower2 = boundarylower2 - 3.0    borderthird = boundarythird - 4.0else: # (from 2025, we'll deal with any of those with extended borders using the 'BZ' column in Y3 (Y4 still extended))    borderfirst = boundaryfirst - 2.0    borderupper2 = boundaryupper2 - 2.0    borderlower2 = boundarylower2 - 2.0    borderthird = boundarythird - 3.0# any students to skip - these will not appear on the grid#donotprocess=[]donotprocess=['10993251']  # 2025donotprocess_actual = []  # blank one that gets filled as they get to each student and print out at the end#define what must be passed e.g. lab, BSc dissertation.mustpass=['PHYS10180','PHYS10280',          'PHYS20180','PHYS20280',          'PHYS30180','PHYS30280',          'PHYS40181','PHYS40182']if (classyear == 32): mustpass.append('PHYS30880')  # BSc dissertation only must pass if BSc final year    # define core for purpose of triggered resits i.e.  what gets resat if a student is going to have resits anyway.# This one is for studtype=1, for most Physics studentsisphyscore=['PHYS10071','PHYS10101','PHYS10121','PHYS10191','PHYS10302','PHYS10342','PHYS10372','PHYS20101','PHYS20141','PHYS20171','PHYS20302',  # Y2  changed in 2025 (replaces PHYS20252 - Judith email 06-May-2025)'PHYS20342',  # Y2 changed in 2025 (replaces PHYS20312 - Judith email 06-May-2025)'PHYS20352']        # add must pass to core list for when lab = 39 and is allowed a second chance with essay over the summerisphyscore += mustpass        # M+P students have a different list in *addition* to the iscore list aboveismathcore=['MATH10111', 'MATH10121', 'MATH10212', 'MATH11222', 'MATH11121', 'MATH110222', 'MATH29141', 'MATH24420']# M+P Y1 students have extra non-compensatable units# Post-2023 - only 2 MATHs (20 credit) courses need to be passed (see Judith email 14-May-2022)not_compensatable=['MATH11121', 'MATH11022']# Set the core list depending on whether M+P student or notif (studtype == 1): iscore = isphyscoreelse: iscore = isphyscore + ismathcore# these are where units may have different credits for the marks vs progression (*make sure these are integers, not floats!)credweightunits={'PHYS20040':10,  # main general paper (doesn't count towards progression/resits, but does count towards marks)'PHYS20240':6,            # shorter version worth only 6 (M+P,Phys/Phil, 2nd/3rd year direct entry) 'PHYS20811':5,            # Professional development CD: changed from 9 to 5 in AY2021'PHYS20821':5,            # for the few students resitting the year this course still here'PHYS30010':10,           # General paper (doesn't count towards progression/resits, but does count towards marks)'PHYS30210':6,           # General paper (short version for M+P, Phys/Phil, 2nd/3rd year direct entry)'PHYS30811':3}             # Added back for those few students re-sitting               ##'PHYS20030':0,            # Peer-Assisted Study Sessions (PASS) - no marks, no credits, but here just in case #'ULGE21030':0,            # #'ULFR21030':0,#'ULJA21020':0,#'ULRU11010':0,#'MATH35012':0,#'COMP39112':0,#'MATH49102':0}credweightunits['PHYS30811'] = 0  # Professional development now 0 (Judith, priv. comm. 24-Jun-2022) # List of general papersgeneralpapers = {'PHYS20040', 'PHYS20240', 'PHYS30010', 'PHYS30210'}# List of units that can't be resit (other than 0 credit units which are not resitable) like lab, general papers etc.noresitlist={'PHYS20040', 'PHYS20240', 'PHYS30010', 'PHYS30210'}  # courses to completley ignore because they don't have a mark e.g. tutorials, PASS etc. ignore_courses={'MPHYS',         # not a course                'MPHYSON',       # not a course                'PHYS10000',    # tutorials/similar                'PHYS20000',    # tutorials/similar                'PHYS30000',    # tutorials/similar                'PHYS40000',    # tutorials/similar                'PHYS10010',                    'PHYS10020',                  'PHYS10030',    # PASS (no mark/credits)                'PHYS10022',                'PHYS11000',    # requested by Judith as not relevant                'PHYS21000',    # requested by Judith as not relevant                #'PHYS31000',   # Keep this in for study abroad for info (even if no marks)                #'PHYS41000',   # Keep this in for study abroad for info (even if no marks)                'PHYS20030',                'PHYS19990',    # PASS Peer=Assissted Self-Study                'PHYS29990',    # PASS Peer=Assissted Self-Study                'PHYS39990',    # PASS Peer=Assissted Self-Study                'PHYS49990',    # PASS Peer=Assissted Self-Study                'MATH S100',    # Math Study module (0 credited) [last 0 omitted on prurpose because of extra gap]                'MATH S200',    # Math Study module (0 credited) [last 0 omitted on prurpose because of extra gap]                'MATH S300',    # Math Study module (0 credited) [last 0 omitted on prurpose because of extra gap]                'MATH S400',    # Math Study module (0 credited) [last 0 omitted on prurpose because of extra gap]                'MATH    S',     # sometimes this format                }# Hard-coded study abroad students (because Plan doesn't always distinguish them!)#abroad_students = {}abroad_students = {'10820251','10826844', '10830728', '10849791', '10818157', '10821713', '10833591', '10834291', '10943429', '10669557', '10706596'} # 2025# Hard-coded interrupting students (this can be in addition to any that happen to be in the interrupt_file)interrupt_students = {}    # Hard-coded "for manual completion students" because of insufficient/incorrect informationmanual_students = {}# Hard-coded course exclusions (for are cases) - remember dictionaries need unique keys so separate courses by commas for each ID (,)manual_exclusions = {}    ############################################################################################################################################################################################# NOW THE RUNNING PART OF THE CODE############################################################################################################################################################################################# final filenamefilename = indir + filename    # get input datadfallstudents = read_data(filename,studtype)  # read in file to a Pandas dataframe and remove NaNs (old 2-line format)dfallstudents, resitgrid = check_column_names(dfallstudents) # check column names/1-3 line format and change as necessarydfallstudents = extract_students_by_type(dfallstudents,classyear, studtype, resitgrid) # extract students on progdf_Y3creds = read_Y3creds_file(Y3creds_filename) # get Y3 credits with mark < 40 for Y4 students onlydf_flagCF_notes = read_flagCF_file_multisheet(flagCF_file)  # read in Flag Carry Forward notesdfout         = make_output_df()                 # Empty output dataframe with all possible columns                       sids          = get_sids(dfallstudents)          # get student ids for all relevant studentscolumn_names  = dfallstudents.columns.to_list()  # get column namesnstudents     = len(sids)                        # Number of students to deal with################################################################# loop over SIDscounter = 0           # counter for student numberall_sids = []         # for later if neededall_sids_encoded = [] # for later if neededfor anid in sids:    # info    counter += 1    print('Processing student {0:s} ({1:d}/{2:d})'.format(anid,counter,nstudents))        if (anid in donotprocess):        print('Not processed student {0:s} (in donotprocess list)'.format(anid))          donotprocess_actual.append(anid)         continue            # do most of the work    dfstudent = get_dfstudent(dfallstudents,anid,resitgrid)         # get df for this student including unnamed columns    Info      = make_Info(dfstudent,anid,classyear, ignore_courses, AY, fill_marks=fill_marks) # Make basic Info record class using input data    Info      = add_Y3creds_data(Info,df_Y3creds)                   # Get Level 3 credits information (Y4 only)    Info      = get_manual(Info,manual_students)                    # See if student is in the "for manual completion" list    Info      = get_secondattempts(Info)                            # Determine which units are a 2nd attempt i.e. proper resit    Info      = get_credweights(Info,credweightunits,useidx=False)  # Get credit weights using credweightunits dictionary    Info      = apply_manual_exclusions(Info, manual_exclusions)    # Manually exclude (for rare cases)    Info      = exclude_courses(Info)                               # Determine excluced courses    Info      = get_math_units(Info)                                # Determine which units are maths, marks/credits/credits takens    Info      = get_core_courses(Info,isphyscore, ismathcore)       # Determine which courses are "core" including Math for M+P students    Info      = get_projectmark(Info)                               # Determine the project mark    Info      = get_passed_failed(Info,mustpass,noresitlist)        # Determine which units are passed/failed    Info      = get_referred_units(Info)                            # Determine which units are referred (resit)    Info      = cap_resit_marks(Info)                               # If R2 in input (resit), then cap the mark    Info      = get_yearmark(Info)                                  # Determine average mark for the year    Info      = get_mp_yearmark(Info)                               # Determine math/physics marks separately for M+P students year mark    Info      = get_credits_above(Info)                             # Get credits at and above each level (for promotion and CS output)    Info      = get_overallmark(Info)                               # Get overall mark if CF available    Info      = get_status(Info)                                    # Determine status code for progression/degree, removing referred courses if failed    # For finalyear students only    Info      = get_degclass(Info)                    # Get degree classification    Info      = apply_promotion(Info)                 # Apply "standard" promotion for borderline students in final year    Info      = apply_promotion_x(Info)               # Apply promotion for borderline students in final year using assessed credits    Info      = degclass_to_string(Info)              # Convert degree classification into a string for output    Info = degclass_MPhys_to_BSc(Info)                # For failed MPhys output BSc based on Y1-Y3 marks if available                    # If requested (encode_sids == True) then encode them    if (encode_sids == True):        Info  = encode_emplid(Info, encode_sids=True)        all_sids.append(Info.emplid)        all_sids_encoded.append(Info.emplid_encoded)    Info   = check_status(Info)                           # Check status against input    Info   = cleanup_nomark_students(Info)                # Cleanup output with no year mark e.g. PP students, Europe/abroad, interrupting    Info   = cleanup_manual_students(Info)                # Cleanup output for "manual" students    Info   = check_overallmarks(Info, check_marks)        # Check yearmark /overallmark against input    Info   = check_deg_award(Info, check_degree)          # Check degree award/classification against input    dfout  = add_data_df(dfout,Info,encode_sids)          # Add data to final dataframe         # for testing resits - stop before resit logic applied below    # Stop at a current student for testing only!    #if (Info.emplid_encoded == 'E22283010'):    #if (Info.emplid == '11314273'):    #    sys.exit(0)        # If resit grid then re-do the marks etc. including the new (resit) marks from the 3rd row    if (Info.resitgrid == True):                Info      = get_resit_marks(Info,dfstudent,keep_input_resit_codes=keep_input_resit_codes,fill_marks=fill_marks) # Get resit marks from 3rd row        Info      = add_MCC_data(Info,df_MCC_resit,keep_input_codes=keep_input_resit_codes)  # Add unit codes from MCC_resit file        Info      = get_manual(Info,manual_students)                # See if student is in the "for manual completion" list        Info      = get_secondattempts(Info)                        # Determine which units are a 2nd attempt i.e. proper resit                Info      = apply_resit_marks(Info)                         # Apply rules to say which resit mark to use (e.g. if capped)        Info      = get_credweights(Info,credweightunits,useidx=False)  # Get credit weights using credweightunits dictionary        Info      = exclude_courses(Info)                           # Determine excluced courses        Info      = make_codes2(Info)                               # Populate codes2 as alternative for 2-line output format        Info      = get_projectmark(Info)                           # Determine the project mark        Info      = get_passed_failed(Info,mustpass,noresitlist)    # Determine which units are passed/failed        Info      = get_referred_units(Info)                        # Determine which units are referred (resit)        Info      = apply_capped_resit_marks(Info)                  # Make pre/post-capped marks arrays and apply other rules for resits        Info      = get_yearmark(Info)                              # Determine average mark for the year        Info      = get_mp_yearmark(Info)                           # Math/physics marks separately for M+P students year mark        Info      = get_credits_above(Info)                         # Get credits at and above each level (for promotion and CS output)        Info      = get_overallmark(Info)                           # Get overall mark if marks available        Info      = get_status(Info)                                # Status code for prog/degree removing failed referred units        Info      = cleanup_manual_students(Info)                   # Cleanup output for "manual" students        dfout     = add_resit_data_df(dfout,Info)                   # Add 3rd row (resits) to final dataframe            # Stop at a current student for testing only!    #if (Info.emplid == '10704697'):    #    sys.exit(0)    #sys.exit(0)    # Final tidying up and outputdfout     = dfout.replace(np.nan, '', regex=True)  # Remove any NaNsmaxunit   = get_maxunit_number(dfout)              # Get maximum unit numbercolumns   = set_output_columns(Info, maxunit)      # Set output columns for grid depending on student type/classyeardfout     = sort_df(dfout,Info,sort_output=sort_output) # Sort by year/overall mark if not a resitgrid/sort_output=Falsedfout, nrows = add_codes_df(dfout)                 # Add useful codes to end of spreadsheetoutfilename = add_resit_tofilename(outfilename, Info) # If a resitgrid add "_resit" to outfilenamedf_to_excel(dfout, Info, columns, nrows, outfilename=outfilename) # Output to excel spreadsheetif (encode_sids == True):    write_encoded_sids(outfilename,all_sids, all_sids_encoded) # output encoded sids lookup table (encode_sids==True)# Final end statementsif (len(donotprocess_actual) > 0):    print('\nDid not process (ignored) the following students:\n')    print(donotprocess_actual)print('\nFinal output written to {0:s}'.format(outfilename))############################################################################################### End of code##############################################################################################    