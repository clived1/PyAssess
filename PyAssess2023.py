# The University of Manchester Physics and Astronomy Exam assessment code# Takes in CS exam grids (csv/xls/xlsx files) and produces output exam grids, with averages, degree classes etc.# This version is for AY2022/2023 and is a significant update of the previous version (PyAssess2022.py)# with some new rules. The program should also be able to automatically detect and run CS resit grids## This Python script requires the following to be installed (e.g. using conda or pip):# -Python v3.9 or above (tested on v3.11 which preferred)# -numpy (tested on v1.24.3)# -pandas v1.5.3 or above (tested with v2.0.1 preferred)# -xlsxwriter (tested on v3.1.0 preferred)# -openpyxl (tested on v3.1.2 preferred) ### Immediate to-do list:# ---------------------## 1. Judith email 10-May-2023:# i) CF marks in input grid from this year (no CF files necessary but will be produced anyway)# ii) But CF file still needed for M/P average (Y3 mark) so will still need to read them in?## Judith email 26-May-2023: LCM1, LCM2 files for carry forward marks. "previous term GPA" is NOT what we want and should be ignored.# GPA should match PyAssess.## 2. M/P students - output overall(+final year if available) marks as a separate column (not just O/P/M). Judith email 10-May-2023 DONE I THINK.### 3. New codes and what to output (Judith email 25-May-2023):## i) XN - as before, for info only, mark as XN            DONE OK# ii) MA3 - Y1/2 only, exclude from average, mark as X    DONE ???# iii) MA4 - Y1/2 only, resit as first attempt (deferrral), mark as R1# iv) MA8 - Y3/4 only, exclude from average, mark as X    DONE ???## v) MA9 - will be marked agains one or more units, but has no direct effect on those units. It means an unspecified borderline extension.  We need to think how to note this on the final grid.  There is no longer an MCC file (#** etc) to read in.## vi) Most other codes are for info only and should be propagated without comment e.g. MC3 (late penalty already waived), MA7 (minor element of assessment excluded from the mark).## vii) Y1/Y2 possible SR1 code. This is short for “MA3 if passed but underperformed, MA4 if failed”. This is an MCC code which should have been resolved by the exam pre-board.   So if the mark is below 40, it becomes resit as first attempt (deferral).  But if it is above 40, it depends on the marks.  I think all you can do with it is turn it into MA4 (hence R1) if the mark is below 40% and leave it (highlighted) as SR1 without further action otherwise.## viii) In Y3/4  there should be no SR codes.  If there are, or if MA3, MA4 or MA8 appear in the wrong year, it would be helpful if they could be highlighted.## ix) On the input grids, failed units have a box round them.  That is quite useful, I presume you could do that on the output grid? In Y1&2 of course the output grid will have C or R1 or R2 next to any such unit, but not in Y3&4 - only an possibly an X.## x) There will be a set of output columns required by Faculty (degree class, obviously; progress or not, resits….) but I still haven’t seen the format.## xi) There will be no Mit Circ codes/columns from this year## xii) No XL/X1 codes from 2023 (now MA4/MA8). If a student fails, just copy all the codes from the input grid (just no resits/deferral coursenames).## 4. Judith request (25-May-2023): If a student gets 69% and 80 credits at or above 70%, we used to mark them as MPhys 2.1 (PA).  It will involved much less manual editing if it is MPhys 1, which is of course the actual degree that we will award.  #While this might change, I envisage three columns: #Algorithmic classification, review column, actual classification. #The first is self-explanatory (eg MPhys 1 in this case, MPhys 2.1 if there were only 60 first-class credits)#The second would be blank if student is not borderline, PA if promoted by method A, PB if method B, CR if borderline but not automatically promoted or if the credits are inadequate - Actually MA9 could go in here too#The third would be initially the same as the first, but it could be edited by hand during the meeting if a student is promoted by the Board.### Known issues to keep in mind:# -----------------------------## 1. Repeating students doesn't work fully yet e.g. 30R and R2. e.g. see 10630849 from 2022 data (1st year Physics).#    N.B. the program gives an 'ACTV' status which may well be incorrect.# Judith email (25-May-2023):# If a student is repeating, then any mark that appears on the grid from the previous attempt at the year stands, however it was achieved, and will not again be the subject of resit.  So in the average, just take the mark. Reproduce the input (30R) in the output, with nothing in the second column. When considering what to do with any new failed units, though, check the credits - so if the new marks included two 35s, that too many and if one is core it would need to be reset.  I think….  There is a limit to what an algorithm can do!## 2. get_referred() has been re-written and still have to add back in the resit rules from the _old version. e.g. the codes will not be correct because still some code left using marksout only#### To-do list specifically for AY=2024:# -----------------------------------## 1. From AY=2024 apply Y4 max 40 credits failed over both Y3/Y4. Judith email 01/03/22: Looking forward, an issue for next year’s third year is that students are to be restricted to 40 failed credits across both years 3 and 4.  So the carry-forward file will have to have a column for credits failed in third year. ### General to-list:# ---------------# # 1. Try to get overall/year mark to 1 d.p. even if .0 (at moment outputs 84 rather than 84.0) (almost there!)### MODIFICATION HISTORY:# --------------------## 20-Mar-2023  C. Dickinson    Copied PyAssess2022.py to PyAssess2023.py for major changes# 20-Mar-2023                  Replaced pd.append (deprecated) with pd.concat # 21-Mar-2023                  Changed writer.save (Deprecated) to workbook.close() # 22-Mar-2023                  Added basics of 2 column format for units including for resits# 22-Mar-2023                  Added rule for <80 credits to fail (to catch 70 credits with no resits)# 28-Mar-2023                  Updated grey banding and merging code to look reasonable# 29-Mar-2023                  Changed RBSc borderline back to 2% from 2022 onwards# 29-Mar-2023                  Remove codes/referrals/deferrals etc. if a fail# 30-Mar-2023                  Added failreason string# 30-Mar-2023                  Changed use of yearmark for resitting borderline MPhys students# 31-Mar-2023                  Reset status/cleanup when 'PRO' in inputs# 31-Mar-2023                  Use previous marks for resits for previous deferrals when previous mark is higher/0XN (JMcG email 26-Oct-2022)# 04-Apr-2023                  Begin major re-write, particularly of get_referred_units()# 16-May-2023                  Added back M+P non-compensatable units (from 2023 only 2 Y1 MATH units non-compensatable)# 17-May-2023                  Removed trailing forward slash on resits# 17-May-2023                  Implemented abroad variable testing with hard-coded abroad_students list (correct weights) # 18-May-2023                  Attempt to fix xx.0 trailing .0 in final averages not showing (still TBC)# 25-May-2023                  Added credits34passed variable (tidy up) and put in new rule for Y31 progression (max 20 failed credits)# 30-May-2023                  Put codes back if fail, only remove resit coursenames. Fixed extracting BSc M+P students.#                              First attempt at putting in MA3/4/8 codes################################################################### importsimport pandas as pdimport xlsxwriterimport openpyxlimport numpy as npimport sysimport copy################################################################# MAIN INPUTS TO BE CHANGED################################################################# Set academic year e.g. 2021 is for 2020/21 (for filename and rules!)#AY = 2019  # for 2018/19#AY = 2021  # for 2020/2021AY = 2022  # for 2021/2022AY = 2023  # for 2022/20023# Define year (1=1st year, 2=2nd year, 31=3rd prog, 32=3rd complete ,4=4th year)classyear=32# Student type (1=Physics, 2=Math+Physics)studtype=1# Encode student IDs - if set to True (or 1) then encode the IDs, do not output names, and produce a look up table separatelyencode_sids = True# Input directory for files (default is './' for current directory)indir = './'# CF flag file - if set to '' (blank) then ignore, otherwise use this to flag mitigating yearly averages#CF_flagfile = './data2022/Flag for CF with IDs.xlsx'CF_flagfile = ''# Input and output files for each cohort# Input filename (filename) can be .csv or .xls/.xlsx - the code will automatically read it in whichever the format if(classyear==1):    filename = 'data2022/1st year exam grid_01.07.22_v3.xlsx'    filename = 'data2022/test_1st year exam grid_01.07.22_v3.xlsx'    #filename = 'resits 2021-22/Input grids/First Year_Resit Exam Grid_12.09.xlsx'        CFfilename = '' # (no CF file)        # output filename    if (studtype==1): outfilename = '1styear_Physics.' + 'AY' + str(AY) + '.xlsx'   # Physics filename    else: outfilename = '1styear_MathsPhysics.' + 'AY' + str(AY) + '.xlsx'   # M+P filenameelif (classyear == 2):    filename = 'data2022/2nd Year Exam Grid_01.07.22_v3.xlsx'    filename = 'data2022/test_2nd Year Exam Grid_01.07.22_v3.xlsx'    #filename = 'resits 2021-22/Input grids/Second Year_Resit Exam Grid_12.09.xlsx'        # If CFfilename to be used (otherwise leave as blank '' to ignore or set doCF=False below)    CFfilename = ''    #CFfilename = './data2022/2nd year carry forward.xlsx'        # output filename    if (studtype==1): outfilename = '2ndyear_Physics.' + 'AY' + str(AY) + '.xlsx'   # Physics filename    else: outfilename = '2ndyear_MathsPhysics.' + 'AY' + str(AY) + '.xlsx'   # M+P filenameelif(classyear==32):    #filename  = './data2022/3rd year exam grid_25.06.22_v2.xlsx'    filename  = './data2023/Physics_Y3.xlsx'        #CFfilename = './data2022/3rd year carry forward.xlsx'    CFfilename = ''        # output filename    if (studtype==1): outfilename = 'FinalYear_BSc_Physics.' + 'AY' + str(AY) + '.xlsx'   # Physics filename    else: outfilename = 'FinalYear_BSc_MathsPhysics.' + 'AY' + str(AY) + '.xlsx'   # M+P filename    elif (classyear == 31):    filename  = './data2022/3rd year exam grid_25.06.22_v2.xlsx'    filename  = './data2023/Physics_Y3.xlsx'        #CFfilename = './data2022/3rd year carry forward.xlsx'    CFfilename = ''        # output filename    if (studtype==1): outfilename = '3rdyear_MPhys.' + 'AY' + str(AY) + '.xlsx'   # Physics filename    else: outfilename = '3rdyear_MMath.' + 'AY' + str(AY) + '.xlsx'   # M+P filename    elif(classyear==4):    filename = './data2022/4th year exam grid_25.06.22_v2.xlsx'        CFfilename = './data2022/4th year carry forward.xlsx'        # output filename    if (studtype==1): outfilename = 'FinalYear_MPhys.' + 'AY' + str(AY) + '.xlsx'   # Physics filename    else: outfilename = 'FinalYear_MMath.' + 'AY' + str(AY) + '.xlsx'   # M+P filenameelse:    print('*ERROR: Classyear not defined correctly (should be 1, 2, 31, 32, or 4)')    sys.exit(0)################################################################# CLASS DEFINITIONS################################################################# class to include all student info, but start with most important info# and include defaults for important parametersclass StudentInfo:    def __init__(self,emplid,classyear):        # Most important inputs        self.emplid = emplid        self.classyear = classyear        # Default parameters (in case not set and is needed by a function later)        self.status          = 'ACTV'  # default status        self.mitcirc         = ''        self.anonymous       = False        self.someunitunder30 = False        self.resitstriggered = False        self.faillabprog     = False        self.fail            = False        self.failreason      = ''        self.referredcoursenames = ''        self.deferredcoursenames = ''        self.referred_idx    = []        self.deferred_idx    = []        self.excluded_idx    = []        self.compensated_idx = []        self.year3mark = -1        self.demote          = False        self.promote         = False        self.repeating       = False        self.resitgrid       = False        self.secondpass      = False        self.secondattempt_idx = []        self.abroad          = False        self.Euro            = False        ################################################################# FUNCTIONS################################################################################################################################# find the number of rows to skip before main data tabledef find_skipnrows(filename):    # read all data in first    try:        if (filename.split('.')[-1] == 'csv'): df = pd.read_csv(filename, dtype='str',encoding = "ISO-8859-1")        else: df=pd.read_excel(filename,dtype='str')    except:        print('\nERROR reading the main input file: {0:s}\nPlease check filename and/or directory and make sure it is xls/xlsx/csv format...\n'.format(filename))        print('If filename is ok, then there must be an issue with reading the file in via pandas...')        sys.exit(0)    # clean up dataframe of NaNs but leave Unnamed columns for now       df = df.replace(np.nan, '', regex=True)  # Remove NaNs    df = df.replace('\xa0', '', regex=True)  # Remove any unicode non-breakable space ('\ax0')        # find row where data starts    trycols = [1]  # try a few columns to make sure this is where the data starts    skipnrows = 0    for i in trycols:        col = df.iloc[:,i].to_list()        for j in np.arange(len(col)):            if (col[j] != ''):                nrows = j                break        if (nrows > skipnrows): skipnrows = nrows    skipnrows += 1 # to skip the required number of rows                return skipnrows################################################################# read in student data (usually from an excel (.xlsx) file but can be csv)def read_data(filename):    try:        skipnrows = find_skipnrows(filename)  # get number of rows to skip        if (filename.split('.')[-1] == 'csv'): df = pd.read_csv(filename, skiprows=skipnrows, dtype='str',encoding = "ISO-8859-1")        else: df=pd.read_excel(filename,skiprows=skipnrows,dtype='str')    except:        print('\nERROR reading the main input file: {0:s}\nPlease check filename and/or directory and make sure it is xls/xlsx/csv format...\n'.format(filename))        print('If filename is ok, then there must be an issue with reading the file in via pandas...')        sys.exit(0)    # clean up dataframe of NaNs but leave Unnamed columns for now       df = df.replace(np.nan, '', regex=True)  # Remove NaNs    df = df.replace('\xa0', '', regex=True)  # Remove any unicode non-breakable space ('\ax0')    # reindex from 0 to N to ensure no gaps    #df = df.reindex(df)        return df################################################################# Remove Unnamed ('^Unnamed') columns from the dataframedef remove_unnamed_columns(df):    return df.loc[:, ~df.columns.str.contains('^Unnamed')]   # remove Unnamed columns################################################################# Check column names are standard and change as necessarydef check_column_names(df):    columnnames = df.columns.to_list()    # check that Emplid is there    if ('Emplid' not in columnnames):        if ('id' in columnnames): df.rename(columns={'id':'Emplid'}, inplace=True)        elif ('ID' in columnnames): df.rename(columns={'ID':'Emplid'}, inplace=True)        elif ('sid' in columnnames): df.rename(columns={'sid':'Emplid'}, inplace=True)        elif ('SID' in columnnames): df.rename(columns={'SID':'Emplid'}, inplace=True)        elif ('uid' in columnnames): df.rename(columns={'uid':'Emplid'}, inplace=True)        elif ('UID' in columnnames): df.rename(columns={'UID':'Emplid'}, inplace=True)        else: print('WARNING: ''Emplid'' not in the header')                # check that Plan is there    if ('Plan' not in columnnames):        if ('Prog' in columnnames): df.rename(columns={'Prog':'Plan'}, inplace=True)        elif ('Prog.' in columnnames): df.rename(columns={'Prog.':'Plan'}, inplace=True)        elif ('Programme' in columnnames): df.rename(columns={'Programme':'Plan'}, inplace=True)        else: print('WARNING: ''Plan'' not in the header')    # for resits that have specific names converet to unit numbers    #keys = list(unitcolumns_dict.keys())    #for i in np.arange(len(keys)):    #    key = keys[i]    #    if (key in columnnames): df.rename(columns={key:'Unit {0:d}'.format(i)}, inplace=True)    return df   ################################################################# read in student data (usually from a csv file but can be excel)def read_CFflags(CF_flagfile,doCF):    # If no CF or flags then skip    if (doCF == False or CF_flagfile == ''):        return None        try:        if (filename.split('.')[-1] == 'csv'): df = pd.read_csv(CF_flagfile, dtype='str',encoding = "ISO-8859-1")        else: df=pd.read_excel(CF_flagfile,dtype='str')    except:        print('\nERROR reading the CF flasg file: {0:s}\nPlease check filename and/or directory and make sure it is xls/xlsx/csv format...\n'.format(CF_flagfile))        sys.exit(0)    # clean up dataframe of NaNs but leave Unnamed columns for now       df = df.replace(np.nan, '', regex=True)  # Remove NaNs    df = df.replace('\xa0', '', regex=True)  # Remove any unicode non-breakable space ('\ax0')        return df################################################################# extract relevant students from df to another df by type# whether normal (2 rows) or resit (3 rows) per studentdef extract_students_by_type(df,classyear,studtype):    # first check to see if there is a 3rd row (if resits) and add it if there is by getting most indices to begin with     idx = df.index[(df['Plan'].str.contains('MPhys')) | (df['Plan'].str.contains('BSc')) | (df['Plan'].str.contains('Math'))]    diff = np.diff(idx)    mindiff = diff.min()    resitgrid = False    if (mindiff == 3): resitgrid = True    elif (mindiff !=2):        print('\n*ERROR: For some reason cannot determine how many rows per student - usually due to lack of data...check inputs!\n')        sys.exit(0)                  # get indices of relevant students    if (classyear == 1 or classyear == 2 or classyear == 4):        if (studtype == 1):            idx = df.index[(df['Plan'].str.contains('MPhys')) | (df['Plan'].str.contains('BSc')) & (~df['Plan'].str.contains('Math'))]        else:            idx = df.index[(df['Plan'].str.contains('Math'))]                if(classyear==31):        if (studtype == 1):            idx = df.index[(df['Plan'].str.contains('MPhys')) & (~df['Plan'].str.contains('Math'))]        else:            idx = df.index[(df['Plan'].str.contains('MMath'))]    #  Select BScs without math    if(classyear==32):        if(studtype==1):            idx = df.index[(df['Plan'].str.contains('BSc')) & (df['Plan'].str.contains('Phys')) & (~df['Plan'].str.contains('Math'))]        else:            idx = df.index[(df['Plan'].str.contains('BSc')) & (df['Plan'].str.contains('Math'))]    # If no students, return and give warning    if (len(idx) == 0):        print('\n*ERROR: No students found - check inputs and that studtype is correct (1=Physics, 2=M+P)\n')        sys.exit(0)                # add indices for the 2nd row of each student record    idx2 = []   # array of full indices    idx = idx.to_list()  # array of the first row index    for i in range(len(idx)):        idx2.append(idx[i])        idx2.append(idx[i]+1)        if (resitgrid):  # add 3rd row index if not on next student            idx2.append(idx[i]+2)            dfstudents = df.iloc[idx2]    # extract all the relevant rows    dfstudents.reindex()          # reindex to ensure it is contiguous for later        return dfstudents, resitgrid################################################################# get all student ids from a dataframedef get_sids(df):        sids = df.loc[:,'Emplid']        if (sids.size < 1):        print('No student IDs found...check file and column for SIDs (should be the 1st column called Emplid or UID or SID or similar)')        sys.exit(0)    sids = sids.to_list()  # make a list    sids = list(filter(None,sids))    # remove empty strings    # also remove any unicode non-breaking spaces (e.g. '\xa0') which can sometimes appear out of nowhere!    # not needed now - removed at the beginning in the allstudents dataframe    #sids = [x.strip() for x in sids]  # remove any spaces ('\xa0' -> '')    #sids_cleaned = [x for x in sids if x != '']  # remove any blank elements ('')                return sids################################################################def get_dfstudent(df,sid,resitgrid):        dfstudent=df.loc[df['Emplid'] == sid]  # select row with studentID= target    index=dfstudent.index.to_list()          # get index number of this row    dfstudent1 = df.loc[df.index == index[0]]    dfstudent2 = df.loc[df.index == index[0]+1]        dfstudent = pd.concat([dfstudent1, dfstudent2])    # if resit student get 3rd row    if (resitgrid == True):        dfstudent3 = df.loc[df.index == index[0]+2]        dfstudent = pd.concat([dfstudent, dfstudent3])  # add extra row to df    dfstudent.reindex()        return dfstudent################################################################# Make Info student record class filling with basic marks etc.# Ignores courses that are in ignore_coursesdef make_Info(df,anid,classyear,ignore_courses,AY):        Info = StudentInfo(anid,classyear)            # Make Info record and add SID/classyear    Info.Plan = df["Plan"].values[0]    # Add Plan    Info.AY   = AY                      # Add academic year        # Determine if progressing or finalyear    if (classyear == 32 or classyear == 4):        Info.finalyear = True    else:        Info.finalyear = False        # Determine if M+P student    if ('Math' in Info.Plan):        Info.mathstudent = True    else:        Info.mathstudent = False            # Determine if MPhys student    if ('MP' in Info.Plan or 'Mp' in Info.Plan or 'MM' in Info.Plan):        Info.mphysstudent = True    else:        Info.mphysstudent = False    # determine if resitting - which means there is a 3rd row    if (len(df) == 3):        Info.resitgrid = True    else:        Info.resitgrid = False    # Determine if an "abroad" student (usually in Y3) via programme name    # but also have to hard-code some because we can't always tell (e.g. plan MPhys Physics can go abroad)    if ('MPhys' in Info.Plan and 'Math' not in Info.Plan and 'Study' in Info.Plan):        Info.abroad = True    if ('3A' in Info.Plan or '[A]' in Info.Plan): # Physics with Study in Europe        Info.abroad = True        Info.Euro   = True    # Make sure all abroad students are identidied from separate (hard-coded) list    # (because we can't always tell (e.g. plan MPhys Physics can go abroad)     if (Info.emplid in abroad_students):        Info.abroad = True            # add in simple information from input data    columns = df.columns.to_list() # get columns    if ("Name" in columns):        Info.Name = df["Name"].values[0] # add Name if available    else: Info.anonymous = True  # anonymous file    # Credits taken/passed    if ("Units\nTaken" in columns): Info.UnitsTaken = df["Units\nTaken"].values[0]    if ("Units\nPassed" in columns): Info.UnitsTaken = df["Units\nPassed"].values[0]    # Mit Circ/Sp if exists    mitcirc_name = [s for s in columns if ('Mit' in s or 'Sp' in s)] # get name of column if it exists    if (mitcirc_name): Info.mitcirc = df[mitcirc_name[0]].values[0]        # add all the Unit information including codes    columns = df.filter(regex='^Unit\ ',axis=1).columns.to_list()  # just unit columns    coursenames = []    coursenamesout = []    marks = []    marksout = []   # string for output marks (including potentially codes etc)    credits = []    codes = []        # loop over each Unit column    for col in columns:        data = df.loc[:,col].values  # get main data        coursename = data[0][0:9] # coursename is first 10 characters        if (len(coursename) < 5 or coursename in ignore_courses):  # move on if blank            continue                     # credits        lbindex = data[0].find('(')        rbindex = data[0].find(')')        thiscredit = int(data[0][lbindex + 1:rbindex])                # Get codes for any courses        idx = df.columns.get_loc(col)  # get indices of column with potential codes        code = df.iloc[1,idx+1]                # add mark and get code string        mark_str = str(data[1])        try:  # if just a number (usually is)            mark = round(float(mark_str)+0.000001) # mark as a (rounded) integer            markout = str(mark) # *** keep as integer in the end (remove str()) when this is not used later                except: # if not just a number and code            if (mark_str == ''): # if empty                mark = -1            elif (mark_str[0].isnumeric() == True):  # if XXC or XXR or XX_X get numerical mark                mark = round(float(''.join([c for c in mark_str if c.isdigit()])))  # get only numerical values                code = ''.join([c for c in mark_str if not c.isdigit()]) + code # add any code to the main code (e.g. X, or C)                markout = str(mark)  # without code as this will be put back later via codes                if (Info.resitgrid == False): Info.repeating = True     # Likely repeating student (if not resit grid) so make a note            else: # no numerical mark                mark = -1                if (thiscredit > 0 or coursename in generalpapers): # warning only if is going to be non-0 credit weighted                    print('*WARNING: No mark for {0:s} ({1:s})'.format(coursename,mark_str))                elif (thiscredit == 0):                    markout = 'AUD'   # likely a student has signed up but not taking the exam                            # If no mark, mark as a blank and add any code back (e.g. 'PRO')         if (mark == -1):            markout = ''        #    code = mark_str                # Append the values to the individual lists if it is a real course        coursenamesout.append(data[0])  # Keep original coursename + credits for output        coursenames.append(coursename)          marks.append(mark)  # mark        marksout.append(markout) # marksout        credits.append(thiscredit)        codes.append(code)    # Enforce position/ordering of some courses for clearer output later    if (classyear == 4):        try:            idx = coursenames.index('PHYS40181')  # If exists put in 1st columnn            if (idx and idx != 0):                coursenamesout.insert(0,coursenamesout[idx])                coursenames.insert(0,coursenames[idx])                marks.insert(0,marks[idx])                marksout.insert(0,marksout[idx])                credits.insert(0,credits[idx])                codes.insert(0,codes[idx])                del coursenamesout[idx+1]                del coursenames[idx+1]                del marks[idx+1]                del marksout[idx+1]                del credits[idx+1]                del codes[idx+1]        except:            pass        try:            idx = coursenames.index('PHYS40182')  # If exists put in 2nd columnn            if (idx and idx != 1):                coursenamesout.insert(1,coursenamesout[idx])                coursenames.insert(1,coursenames[idx])                marks.insert(1,marks[idx])                marksout.insert(1,marksout[idx])                credits.insert(1,credits[idx])                codes.insert(1,codes[idx])                del coursenamesout[idx+1]                del coursenames[idx+1]                del marks[idx+1]                del marksout[idx+1]                del credits[idx+1]                del codes[idx+1]        except:            pass            if (classyear == 32 or classyear == 31):        try:            idx = coursenames.index('PHYS30010')  # If exists put in 1st columnn            if (not idx): idx = coursenames.index('PHYS30210')  # If exists put in 1st columnn            if (idx and idx != 0):                coursenamesout.insert(0,coursenamesout[idx])                coursenames.insert(0,coursenames[idx])                marks.insert(0,marks[idx])                marksout.insert(0,marksout[idx])                credits.insert(0,credits[idx])                codes.insert(0,codes[idx])                del coursenamesout[idx+1]                del coursenames[idx+1]                del marks[idx+1]                del marksout[idx+1]                del credits[idx+1]                del codes[idx+1]        except:            pass        try:            idx = coursenames.index('PHYS30180')  # If exists put in 2nd columnn            if (not idx): idx = coursenames.index('PHYS30280')  # If exists put in 2nd columnn            if (idx and idx != 1):                coursenamesout.insert(1,coursenamesout[idx])                coursenames.insert(1,coursenames[idx])                marks.insert(1,marks[idx])                marksout.insert(1,marksout[idx])                credits.insert(1,credits[idx])                codes.insert(1,codes[idx])                del coursenamesout[idx+1]                del coursenames[idx+1]                del marks[idx+1]                del marksout[idx+1]                del credits[idx+1]                del codes[idx+1]        except:            pass        try:            idx = coursenames.index('PHYS30880')  # If exists put in 3rd columnn            if (idx and idx != 2):                coursenamesout.insert(2,coursenamesout[idx])                coursenames.insert(2,coursenames[idx])                marks.insert(2,marks[idx])                marksout.insert(2,marksout[idx])                credits.insert(2,credits[idx])                codes.insert(2,codes[idx])                del coursenamesout[idx+1]                del coursenames[idx+1]                del marks[idx+1]                del marksout[idx+1]                del credits[idx+1]                del codes[idx+1]        except:            pass    # add the lists back to the Info object    Info.coursenamesout = coursenamesout    Info.coursenames = coursenames    Info.marks       = marks    Info.marksout    = marksout    Info.credits     = credits    Info.codes       = codes    # Store indices of courses with no mark    Info.nomarks_idx = [i for i, j in enumerate(marks) if j < 0]        # If already compensated (for resit grid) then note it    if (Info.resitgrid == True):        idx = [x for x, s in enumerate(Info.codes) if s.find('C') >=0]         for i in idx:            if i not in Info.compensated_idx:                Info.compensated_idx.append(i)                    return Info################################################################# Determine which units are 2nd attempts i.e. proper resits that can't be taken again# for now, this is only for resit grids with a secondpass as we rarely have codes (usually repeating students)def get_secondattempts(Info):    # put previous attempts in an array when doing second pass (For resit grids)    if (Info.secondpass == True):        Info.p_secondattempt_idx = Info.secondattempt_idx.copy()        Info.secondattempt_idx = []                # loop over each unit and find where it is a 2nd attempt based on previous codes        for idx in range(len(Info.codes)):            if ((Info.p_codes[idx].find('R') >=0 and Info.p_codes[idx].find('R1') < 0) or Info.p_codes[idx].find('A2') >=0):                Info.secondattempt_idx.append(idx)                    # if not a resit grid, then see if there is a code with the main mark    else:        for idx in range(len(Info.codes)):            if ( (Info.codes[idx].find('R') >=0 and Info.codes[idx].find('R1') < 0) or Info.codes[idx].find('A2') >=0):                    Info.secondattempt_idx.append(idx)                    return Info################################################################# Get CarryForward data from xls file (if doCF == True)def get_CF_data(doCF, CFfilename):    # do nothing if doCF == False or no CFfilename or if resit grid    if (doCF == False or CFfilename == ''):        return None    # Read in data    try:        skipnrows = find_skipnrows(CFfilename)  # get number of rows to skip        if (CFfilename.split('.')[-1] == 'csv'):            df_CF = pd.read_csv(CFfilename, skiprows=skipnrows, dtype='str', engine='python')        else:            df_CF = pd.read_excel(CFfilename, skiprows=skipnrows, dtype='str')    except:        print('\nERROR reading Carry Forward file: {0:s}\nPlease check filename and/or directory...\n'.format(CFfilename))        sys.exit(0)    df_CF = df_CF.replace(np.nan, '', regex=True)  # Remove NaNs    df_CF = df_CF.replace('\xa0', '', regex=True)  # Remove any unicode non-breakable space ('\ax0')        return df_CF################################################################# add CF data to Info from df_CF already read-indef add_CF_data(Info,df_CF, anid, doCF):    if (doCF == False):  # do nothing if no CF file        Info.CF = False        return Info        selected = df_CF.loc[df_CF['Emplid'] == anid]   # get student data from 1st column        # Check if empty - if so, stop and give warning - usually, CF file not correct or not used (doCF should be 0)    # Put in -1 marks so that code will continue    if (selected.empty):        print('*WARNING: Cannot find student {0:s} in CF file (but file read in ok)... '.format(anid))        #print('***If no relevant CF file, set doCF = False or set CFfilename = '' to ignore carry forwards')        Info.CF = False        Info.phys1 = -1        Info.phys2 = -1        Info.phys3 = -1        Info.math1 = -1        Info.math2 = -1        Info.math3 = -1        Info.year3mark = -1        return Info    else:        Info.CF = True        # get index number of this row and extract the numbers    selectedindex = selected.index    data=df_CF.iloc[selectedindex].values    data=data.flatten()    ndata = np.size(data)        if (ndata < 9):        print('*WARNING: < 9 columns in CF file')        print('***If no relevant CF file, set doCF = False or set CFfilename = '' to ignore carry forwards')            outnames = ['phys1','phys2','phys3','math1','math2','math3']            # loop over each column to get Phys/Math marks from columns 4-9    cols = [3,4,5,6,7,8]  # 6 columns expected after the first 3    for i in cols:        outname = outnames[i-cols[0]]        try:    setattr(Info,outname, float(data[i]))  # set the number if can be converted to float        except: setattr(Info,outname,-1)               # if string or empty set to -1        # get Year 3 mark for 4th year M+P students from column 10 (if it exists)    if (Info.classyear == 4 and Info.mathstudent == True):        if (ndata < 10):            print('Year3mark does not seem to appear in the CF file (no column 10?)! Doing straight average of M+P in 3rd year for now which is incorrect!')            Info.year3mark = (Info.phys3+Info.math3)/2 # incorrect - not a straight average (in case no year3 mark available)        else:            try: Info.year3mark = float(data[9])            except:                Info.year3mark = (Info.phys3+Info.math3)/2 # incorrect - not a straight average (in case no year3 mark available)                print('Using straight Phys/Math average because year3mark is not available in CF file which is not correct!')                                return Info################################################################# get credit weights from coursename or credweights dictionary if 0# will run through all courses# unless idx set to list of indices to re-do (e.g. if compensated later need to put credweights back for these only)def get_credweights(Info,credweightunits,useidx=False):    credits = Info.credits.copy()  # get credits    marks   = Info.marks.copy()    # marks in case missing (which is -1)        # loop over those that are zero using supplied useidx or all zeroes if not    if (useidx):        idx = list([useidx])        credweights = Info.credweights.copy()   # take existing credweights    else:        credweights = credits.copy()  # does not exist yet so take credits as default        idx = [i for i, j in enumerate(credits) if j == 0]    # loop over relevant idx    for i in idx:        coursename = Info.coursenames[i]        if (useidx):            credweights[i] = credits[i]   # if possible compensation put it back to original credits                        if (credits[i] == 0):              try:                credweights[i] = credweightunits[coursename]  # set to correct weight otherwise remains as 0            except:                pass  # no need to give a warning now                Info.credweights = credweights  # Add back to Info                    return Info################################################################# get core/non-core courses for physics and mathdef get_core_courses(Info,isphyscore, ismathcoure):    coursenames     = Info.coursenames.copy()        # Physics core courses    physcore_idx = [i for i in range(len(coursenames)) if coursenames[i] in isphyscore]  # get indices where core courses         # Math core courses (N.B. Y1 all math courses are core only for AY<=2022)    if (Info.mathstudent == True):        mathcore_idx = [i for i in range(len(coursenames)) if coursenames[i] in ismathcore]  # get indices where specific core courses     # Add back to Info    Info.physcore_idx = physcore_idx    if (Info.mathstudent == True):        Info.mathcore_idx    = mathcore_idx   # extra variable only relevant for Math/Phys students        Info.core_idx        = physcore_idx + mathcore_idx  # all core course indices (M+P students)    else:         Info.core_idx    = physcore_idx   # Physics students (no MATHs core)            return Info################################################################# determine exluded courses from year mark including which ones to be deferred or with no markdef exclude_courses(Info):        # find where codes exist    codes = Info.codes    idx = [i for i in range(len(codes)) if codes[i] != '']  # get indices where codes exist    # Blank variables unless already set and set credweights to 0 if no mark and previously excluded    excluded_idx = []    excludedcoursenames = []    deferred_idx = []    deferredcoursenames = ''    deferredcredits = 0    creditsexcluded = 0            # loop over each code and excluded if required    # But first exclude courses with no marks from year average    nomarks_idx = Info.nomarks_idx    if (len(nomarks_idx) > 0):        for i in nomarks_idx:            excluded_idx.append(i)            excludedcoursenames.append(Info.coursenames[i])            creditsexcluded += Info.credits[i]            Info.credweights[i] = 0   # do not include in year average        # loop over each code    for i in idx:        # MA3: Y1/Y2 only, exclude from average -> X        if (codes[i] == 'MA3'):            excluded_idx.append(i)            excludedcoursenames.append(Info.coursenames[i])            creditsexcluded += Info.credits[i]            Info.credweights[i] = 0            codes[i] = 'X'                    # MA8: Y3/Y4 only, exclude from average -> X        elif (codes[i] == 'MA8'):            excluded_idx.append(i)            excludedcoursenames.append(Info.coursenames[i])            creditsexcluded += Info.credits[i]            Info.credweights[i] = 0            codes[i] = 'X'        # MA4: Y1/Y2 only, resit as first attempt (deferral) -> R1        elif (codes[i] == 'MA4'):            excluded_idx.append(i)            excludedcoursenames.append(Info.coursenames[i])            creditsexcluded += Info.credits[i]            Info.credweights[i] = 0            # Defer if Y1/Y2 and if resittable (credits>0)            if ((Info.classyear == 1 or Info.classyear == 2) and Info.credits[i] > 0):                if (i not in Info.secondattempt_idx):   # if not already a 2nd attempt                    Info.codes[i] = Info.codes[i] + '_D'                    deferred_idx.append(i)                    deferredcoursenames += Info.coursenames[i] + '[1] / '                    deferredcredits += Info.credits[i]                else:                    Info.referred_idx.append(i)                    Info.referredcoursenames += Info.coursenames[i] + ' / '                    # X = exclude from year mark        elif (codes[i] == 'X' or codes[i] == '_X' or codes[i].find('X_C') >=0): # includes 'X_C' for 2nd pass (resits)            excluded_idx.append(i)            excludedcoursenames.append(Info.coursenames[i])            creditsexcluded += Info.credits[i]            Info.credweights[i] = 0        # XL = Absent from exam with reason: excludes from the calculation of the year mark and flags as a resit at 1st attempt (deferred)        elif (codes[i].find('XL') >= 0):            excluded_idx.append(i)            excludedcoursenames.append(Info.coursenames[i])            creditsexcluded += Info.credits[i]            Info.credweights[i] = 0            # Defer if Y1/Y2 and if resittable (credits>0)            if ((Info.classyear == 1 or Info.classyear == 2) and Info.credits[i] > 0):                if (i not in Info.secondattempt_idx):   # if not already a 2nd attempt                    Info.codes[i] = Info.codes[i] + '_D'                    deferred_idx.append(i)                    deferredcoursenames += Info.coursenames[i] + '[1] / '                    deferredcredits += Info.credits[i]                else:                    Info.referred_idx.append(i)                    Info.referredcoursenames += Info.coursenames[i] + ' / '                            # X1 = Deferall in Y1/Y2 (same as XL)         elif (codes[i].find('X1') >= 0):            excluded_idx.append(i)            excludedcoursenames.append(Info.coursenames[i])            creditsexcluded += Info.credits[i]            Info.credweights[i] = 0            # Defer if Y1/Y2 and if resittable (credits>0)            if ((Info.classyear == 1 or Info.classyear == 2) and Info.credits[i] > 0):                if (i not in Info.secondattempt_idx):  # if not already a 2nd attempt                    Info.codes[i] = Info.codes[i] + '_D'                    deferred_idx.append(i)                    deferredcoursenames += Info.coursenames[i] + '[1] / '                    deferredcredits += Info.credits[i]                else:                    Info.referred_idx.append(i)                    Info.referredcoursenames += Info.coursenames[i] + ' / '                            # XN = Missed with no reason - do NOT exclude!        elif (codes[i].find('XN') >= 0):            pass        # R1/A1 means exclude and treat as a resit at first attempt next time        elif (codes[i].find('R1') >= 0 or codes[i].find('A1') >=0 and i not in Info.secondattempt_idx and i not in Info.compensated_idx): # and not already excluded            excluded_idx.append(i)            excludedcoursenames.append(Info.coursenames[i])            creditsexcluded += Info.credits[i]            Info.credweights[i] = 0                        # Defer if Y1/Y2 and if resittable (credits>0)            if ((Info.classyear == 1 or Info.classyear == 2) and Info.credits[i] > 0):                deferred_idx.append(i)                deferredcoursenames += Info.coursenames[i] + '[1] / '                deferredcredits += Info.credits[i]        # Add extras back to Info    Info.excluded_idx        = excluded_idx    Info.excludedcoursenames = excludedcoursenames    Info.creditsexcluded     = creditsexcluded    Info.deferred_idx        = deferred_idx    Info.deferredcoursenames = deferredcoursenames    Info.deferredcredits     = deferredcredits        return Info################################################################# Function to determine MATH units and marks/credits and also math credits takendef get_math_units(Info):    math_units = []    coursenames = Info.coursenames    idx = [i for i in range(len(coursenames)) if 'MATH' in coursenames[i]]  # get indices if MATH unit    idx2 = [i for i in range(len(coursenames)) if 'MATH' not in coursenames[i]]  # get indices if not MATH unit    # Physics/math credits taken    mathcreditstaken = np.sum(np.array(Info.credits)[idx])    physcreditstaken = np.sum(np.array(Info.credits)[idx2])        # Add back to Info    Info.math_units_idx = idx    Info.phys_units_idx = idx2    Info.mathcreditstaken = mathcreditstaken    Info.physcreditstaken = physcreditstaken    Info.creditstaken = mathcreditstaken + physcreditstaken        return Info################################################################# Determine the overall project mark for S1/S2 or both# taking into account special cases for non-standard projects (Phys/Phil and M+P)def get_projectmark(Info):    # If not Y3/Y4 then skip this function    if (Info.classyear == 1 or Info.classyear == 2):        return Info        # taking into account special cases for non-standard projects (Phys/Phil and M+P)    # or with only 1 project    coursenames = Info.coursenames    project1mark = -1    # -1 means no mark       project2mark = -1    # -1 means no mark        # BSc dissertation for 3rd years    if ('PHYS30880' in coursenames):        idx = coursenames.index('PHYS30880')        project1mark = Info.marks[idx]        project1cred = Info.credits[idx]            if ('PHYS40181' in coursenames and 'PHYS40182' in coursenames):        idx = coursenames.index('PHYS40181')        project1mark = Info.marks[idx]      # S1        project1cred = Info.credits[idx]        idx = coursenames.index('PHYS40182')        project2mark = Info.marks[idx]      # S2        project2cred = Info.credits[idx]            elif ('PHYS40181' in coursenames and 'PHYS40182' not in coursenames):        idx = coursenames.index('PHYS40181')        project1mark = Info.marks[idx]      # S1        project1cred = Info.credits[idx]    elif ('PHYS40181' not in coursenames and 'PHYS40182' in coursenames):        idx = coursenames.index('PHYS40182')        project2mark = Info.marks[idx]      # S2        project2cred = Info.credits[idx]                    # for Phys/Phil who do an essay for one project - only worth 10 credits c.f. 20 credits for physics    if ('PHIL40000' in coursenames and project1mark==-1):        idx = coursenames.index('PHIL40000')        project1mark = Info.marks[idx]        project1cred = Info.credits[idx]    elif ('PHIL40000' in coursenames and project2mark==-1):        idx = coursenames.index('PHIL40000')        project2mark = Info.marks[idx]        project2cred = Info.credits[idx]            # for Math/Phys Math projects only 15 credits c.f. 20 credits for physics    if ('MATH40011' in coursenames and project1mark==-1):        idx = coursenames.index('MATH40011')        project1mark = Info.marks[idx]        project1cred = Info.credits[idx]    if ('MATH40022' in coursenames and project2mark==-1):        idx = coursenames.index('MATH40022')        project2mark = Info.marks[idx]        project2cred = Info.credits[idx]            # combine S1/S2 project marks    if (project1mark >=0 and project2mark >=0):        projectmark = ((project1mark*project1cred)+(project2mark*project2cred))/float(project1cred+project2cred)        projectcred = project1cred+project2cred    elif (project1mark >=0 and project2mark == -1):        projectmark = project1mark        projectcred = project1cred    elif (project2mark >=0 and project1mark == -1):        projectmark = project2mark        projectcred = project2cred    elif (project1mark == -1 and project2mark == -1):        projectmark = 0        projectcred = 0            # Add to Info    Info.projectmark = round(projectmark+0.000001)    Info.projectcred = projectcred    return Info################################################################# Find which units are passed/faileddef get_passed_failed(Info,mustpass,noresitlist):    Info.faillabprog = False # default is False in case allowed to resit 2nd time (e.g. 'A2')    marks = Info.marks.copy()  # get numerical marks    Info.someunitunder30 = False # default (and to reset on 2nd pass for resits)        # get passed marks/credits    passed_idx = [i for i in range(len(marks)) if marks[i] >= 39.95]  # passed marks                if (len(passed_idx) > 0):        creditspassed = np.sum(np.array(Info.credits)[passed_idx])  # Sum of passed credits    else:        creditspassed = 0    # also get Y3 unit credits passed (needed for BSc criteria) for Y3 students (also do for Y4)    if (Info.classyear == 31 or Info.classyear == 32 or Info.classyear == 4):        passed3_idx = [i for i in range(len(marks)) if (marks[i] >= 39.95 and Info.coursenames[i][4] == '3')]        # Level 4 also include level 6 courses (for Philosophy)        passed4_idx = [i for i in range(len(marks)) if (marks[i] >= 39.95 and (Info.coursenames[i][4] == '4' or Info.coursenames[i][4] == '6'))]         if (len(passed3_idx) > 0):            credits3passed = np.sum(np.array(Info.credits)[passed3_idx]) # Sum of passed Y3 courses        else:            credits3passed = 0        if (len(passed4_idx) > 0):            credits4passed = np.sum(np.array(Info.credits)[passed4_idx]) # Sum of passed Y4 courses        else:            credits4passed = 0                    Info.passed3_idx = passed3_idx        Info.credits3passed = int(credits3passed)        Info.passed4_idx = passed4_idx        Info.credits4passed = int(credits4passed)        Info.credits34passed = Info.credits3passed + Info.credits4passed            # get nominally failed marks/credits    failed_idx = [i for i in range(len(marks)) if (marks[i] < 39.95 and marks[i] >= 0 and i not in Info.excluded_idx)]  # failed marks        # Get sum of "failed" credits    if (len(failed_idx) > 0):        creditsfailed = np.sum(np.array(Info.credits)[failed_idx])  # Sum of "failed" credits    else:        creditsfailed = 0    # Store locations of units in 30-39 range for possible compensation     units30_39_idx = [i for i in range(len(marks)) if (marks[i] >= 29.95 and marks[i] < 39.95)]           # loop through nominally failed courses and determine outcome at end    for i in failed_idx:        # has this course been failed when it must be passed i.e. lab,  project? (but not if A2/R2 code for resits)        if (Info.coursenames[i] in mustpass):            Info.faillabprog = True        #if any course is < 30%, resits triggered for 1st/2nd year (also trigger resits later)        if(marks[i]<29.95 and Info.coursenames[i] not in noresitlist and Info.credits[i] > 0 and i not in Info.excluded_idx):            if (Info.secondpass == True and Info.p_marks[i] >=29.95): # If 2nd pass, consider original mark first to prevent unncessary referrals                Info.someunitunder30 = False            else:                Info.someunitunder30 = True                            # Add back to Info    Info.passed_idx = passed_idx    Info.creditspassed = int(creditspassed)    Info.failed_idx = failed_idx    Info.creditsfailed = int(creditsfailed)    Info.units30_39_idx = units30_39_idx    return Info################################################################# Determine which units are to be referred (resit) or can be compensated# ***RE-WRITTEN (STILL IN PROGRESS) - NOT ADDED RESIT/SECOND ATTEMPT CRITERIA!def get_referred_units(Info):        # If not Y1/Y2 then skip this function (no resits in Y3/Y4)    if (Info.classyear != 1 and Info.classyear != 2):        return Info        # blank variables in case this is being ran twice (for resit grids) but keep record of resits at 2nd attempt to keep for later    if (Info.secondpass == True):        keep_referred_idx = [idx for idx in Info.referred_idx if idx in Info.secondattempt_idx]        Info.referred_idx = []  # blank them        Info.referredcoursenames = '' # blank them        #Info.compensated_idx = []  # do not blank here!     # If definetly not a fail    if (Info.faillabprog==0 and (Info.creditsfailed-Info.deferredcredits <= 40)):        # if not more than 40 credits < 40% and none below 30%, they can all be compensated (except Y1 MATHs for M)        if (Info.someunitunder30==0):            for idx in Info.units30_39_idx:                if (idx not in Info.excluded_idx):                    Info.compensated_idx.append(idx) # compensated automatically for Physics students        # if any mark <30% must be resat and triggers resits of any core course 30-39% (if <40 credits 30-39%)        if (Info.someunitunder30==1):            Info.resitstriggered = True            for idx in Info.failed_idx: # loop through all failed courses                if (idx not in Info.excluded_idx and Info.credits[idx] != 0): # if not excluded                    if (Info.marks[idx] < 29.95):  # if <30% must be resat                        Info.referred_idx.append(idx)                    elif (idx in Info.units30_39_idx and idx in Info.core_idx): # if 30-39 resit if core course                        Info.referred_idx.append(idx)                    elif (idx not in Info.excluded_idx and idx not in Info.referred_idx): # else will be compensated (not for 0-credit units)                        if (idx not in Info.compensated_idx): Info.compensated_idx.append(idx)                            # Else if > 40 credits at 30-39%, all core units must be resat    elif ((Info.creditsfailed-Info.deferredcredits) > 40 and len(Info.failed_idx) >0):        Info.resitstriggered = True        for idx in Info.failed_idx:  # loop through all failed courses            if (Info.marks[idx] < 29.95 and idx not in Info.excluded_idx and Info.credits[idx] !=0): # courses < 30% must be resat                Info.referred_idx.append(idx)              elif (idx in Info.core_idx and idx not in Info.excluded_idx and Info.credits[idx] !=0):  # only for core courses                Info.referred_idx.append(idx)              elif (idx not in Info.deferred_idx and idx not in Info.excluded_idx and Info.credits[idx] !=0): # else must be compensated as an option                if (idx not in Info.compensated_idx): Info.compensated_idx.append(idx)                    # If Maths+Physics student, some MATHs courses in Y1 not compensatable and must be resat    # (pre-2023: all MATHs in 1st year, post-2023 two modules - see Judith McGovern email 14-May-2022     if (Info.mathstudent == True and Info.classyear == 1):        if (Info.AY <= 2022):  # all MATHs units in 1st year non-compensatable            for idx in Info.compensated_idx:                if (idx in Info.math_units_idx):                    Info.compensated_idx.remove(idx)                    Info.referred_idx.append(idx)        elif (Info.AY > 2022): # post 2023 onwards: only 2 MATHs modules (listed in not_compensatable dictionary)            for idx in Info.compensated_idx:                if (Info.coursenames[idx] in not_compensatable):                    Info.compensated_idx.remove(idx)                    Info.referred_idx.append(idx)                        # Now put back any previous referred coursenames at 2nd attempt into the referred idx list     if (Info.secondpass == True):        for idx in keep_referred_idx:  # put back only referred that are 2nd attempt            if (idx not in Info.referred_idx):                Info.referred_idx.append(idx)    # Deal with any resit marks < 30 (failed) but OM 30-39 - do not need to be resat    #if (Info.secondpass == True)                    # apply referred coursenames and any missing R codes     for idx in Info.referred_idx:        Info.referredcoursenames += Info.coursenames[idx] + ' / '  # add referred coursenames        if (Info.codes[idx].find('R') < 0):            Info.codes[idx] += '_R' # to indicate resit    # Apply any missing compensated unit codes    for idx in Info.compensated_idx:        if (Info.codes[idx].find('C') < 0):            Info.codes[idx] += '_C' # to indicate compensated    # Remove any leading '_' to the code if it exists    for i in range(len(Info.codes)):        if (len(Info.codes[i]) > 0 and Info.codes[i][0] == '_'): Info.codes[i] = Info.codes[i][1:]        #if (len(Info.p_codes[i]) > 0 and Info.p_codes[i][0] == '_'): Info.p_codes[i] = Info.p_codes[i][1:]    return Info################################################################# Determine which units are to be referred (resit) or can be compensateddef get_referred_units_old(Info):        # If not Y1/Y2 then skip this function (no resits in Y3/Y4)    if (Info.classyear != 1 and Info.classyear != 2):        return Info        # blank variables in case this is being ran twice (for resit grids) but keep record of resits at 2nd attempt to keep for later    if (Info.secondpass == True):        keep_referred_idx = [idx for idx in Info.referred_idx if idx in Info.secondattempt_idx]        Info.referred_idx = []  # blank them        Info.referredcoursenames = '' # blank them        #Info.compensated_idx = []  # do not blank here            # if not more than 40 credits < 40% and none below 30%, they can all be compensated (except Y1 math)    if (Info.someunitunder30==0 and Info.faillabprog==0 and (Info.creditsfailed-Info.deferredcredits <= 40)):        for idx in Info.units30_39_idx:            if (idx in Info.compensated_idx and Info.secondpass == True): # if already compensated (resitgrid) then just carry on after putting codes in                Info.marksout[idx] = Info.marksout[idx] + Info.codes[idx]            if (Info.classyear == 1 and Info.mathstudent == True and idx in Info.math_units_idx and idx not in Info.deferred_idx and idx not in Info.excluded_idx):                if (Info.secondpass == True and idx in Info.secondattempt_idx): # If fail at 2nd attempt, a fail overall                    Info.failed_idx.append(idx)                    Info.fail = True                    Info.status = 'FAIL'                    print('Fail due to failed 2nd attempts')                else:                    Info.referred_idx.append(idx)   # Any Y1 math units are referred for M+P students (but only if not resat already!)            elif (idx not in Info.deferred_idx and idx not in Info.excluded_idx and Info.credits[idx] !=0):                if (Info.marksout[idx].find('C') < 0): Info.marksout[idx] = Info.marksout[idx] + '_C'  # add code to show it is compensated                if (Info.codes[idx].find('C') < 0): Info.codes[idx] = Info.codes[idx] + '_C'                if (idx not in Info.compensated_idx): Info.compensated_idx.append(idx)                if (Info.codes[idx].find('XN') > 0): # only if not excluded                    Info = get_credweights(Info,credweightunits,useidx=idx)     # put credit weight back in case it has been zeroed    # if any mark <30% must be resat and triggers resits of any core course 30-39% (if <40 credits 30-39%)    if (Info.someunitunder30==1 and Info.faillabprog==0 and (Info.creditsfailed-Info.deferredcredits <= 40)):        Info.resitstriggered = True        for idx in Info.failed_idx: # loop through all failed courses            if (Info.marks[idx] < 29.95 and idx not in Info.excluded_idx and Info.credits[idx] != 0):  # if <30% must be resat                if (Info.secondpass == True and idx in Info.secondattempt_idx): # If 2nd attempt and is failed, then is a fail!                    Info.status = 'FAIL'                    print('Fail due to failed 2nd attempts')                    Info.fail = True                    Info.progress= False                else:                    Info.referred_idx.append(idx)            elif (idx in Info.units30_39_idx and idx in Info.core_idx and idx not in Info.excluded_idx and Info.credits[idx] !=0): # if 30-39 resit if core course                if (Info.secondpass == True):                    if (Info.p_codes[idx].find('C') <0 and idx not in Info.secondattempt_idx): # check if not allowed to compensate for 2nd pass or if already resat                        Info.referred_idx.append(idx)                    elif (idx not in Info.deferred_idx and Info.credits[idx] !=0 and idx not in Info.referred_idx):        # else will be compensated (not for 0-credit units)                        if (Info.marksout[idx].find('C') < 0): Info.marksout[idx] = Info.marksout[idx] + '_C'                        if (Info.codes[idx].find('C') < 0): Info.codes[idx] = Info.codes[idx] + '_C'                        if (idx not in Info.compensated_idx): Info.compensated_idx.append(idx)                            # if > 40 credits at 30-39%, all core units must be resat    if ((Info.creditsfailed-Info.deferredcredits) > 40 and len(Info.failed_idx) >0):        Info.resitstriggered = True        for idx in Info.failed_idx:  # loop through all failed courses            if (Info.secondpass == True and idx in Info.secondattempt_idx and idx not in Info.excluded_idx): # if 2nd attempt, and is failed, then is a fail!                Info.status='FAIL'                print('Fail due to failed 2nd attempts')                Info.fail = True                Info.progress = False                Info.resitstriggered=False            elif (Info.marks[idx] < 29.95 and idx not in Info.excluded_idx and Info.credits[idx] !=0): # courses < 30% must be resat                Info.referred_idx.append(idx)              elif (idx in Info.core_idx and idx not in Info.excluded_idx and Info.credits[idx] !=0):  # only for core courses                Info.referred_idx.append(idx)              elif (idx not in Info.deferred_idx and idx not in Info.excluded_idx and Info.credits[idx] !=0): # else must be compensated as an option                if (idx not in Info.compensated_idx): Info.compensated_idx.append(idx)                if (Info.marksout[idx].find('C') < 0): Info.marksout[idx] = Info.marksout[idx] + '_C'                if (Info.codes[idx].find('C') < 0): Info.codes[idx] = Info.codes[idx] + '_C'                        # add any other codes already in the input    for idx in range(len(Info.marks)):        if ((Info.codes[idx].find('R') >= 0 and Info.marksout[idx].find('R') <0) or (Info.codes[idx].find('A') >=0 and Info.marksout[idx].find('A') <0)):   # put main code if exists including 1st pass            Info.marksout[idx] += Info.codes[idx]                # Now put back any previous referred coursenames at 2nd attempt into the referred idx list     if (Info.secondpass == True):        for idx in keep_referred_idx:  # put back only referred that are 2nd attempt            if (idx not in Info.referred_idx):                Info.referred_idx.append(idx)    # Deal with any resit marks < 30 (failed) but OM 30-39 - do not need to be resat    #if (Info.secondpass == True)                    # apply referred coursenames and codes to output marks     for idx in Info.referred_idx:        Info.referredcoursenames += Info.coursenames[idx] + ' / '  # add referred coursenames        #if (Info.codes[idx].find('R') >= 0):   # put main code if exists        #    Info.marksout[idx] += Info.codes[idx]        if (Info.secondpass == True):  # for resits only            if (Info.p_codes[idx].find('R') >= 0 and Info.marksout[idx].find('R') < 0): # put p_code if not e.g. R1, R2                Info.marksout[idx] += Info.p_codes[idx]        if (Info.marksout[idx].find('R') < 0 and Info.marksout[idx].find('A2') < 0): # if not already in marksout, add _R to indicate resit            Info.marksout[idx] = Info.marksout[idx] + '_R'                    return Info################################################################# make precapped/poscapped marks arrays, and also apply any other rules for resitsdef apply_capped_resit_marks(Info):    # only apply if 2nd pass (resit)     if (Info.secondpass == True):        # if a course is excluded due to missing but is referred (for 2nd attempt) then still include in average        for idx in Info.referred_idx:            if (idx in Info.excluded_idx): # do not exclude if XL but is a referall (e.g. R2) and use original mark/credits                Info.excluded_idx.remove(idx)                Info.excludedcoursenames.remove(Info.coursenames[idx])                Info.credweights[idx] = Info.credits[idx]                Info.marks_postcapped[idx] = Info.p_marks[idx]   # apply marks to postcapped array        # use capped resit marks         Info.marks_precapped = Info.marks.copy() # to store just in case needed        Info.marks = Info.marks_postcapped.copy() # replace marks with correct (capped) resit marks    return Info################################################################# get overall average year markdef get_yearmark(Info):    # get arrays            marks = np.array(Info.marks.copy())    credweights = np.array(Info.credweights.copy())    # get credits    sumcredweights = np.sum(credweights)    Info.sumcredweights = sumcredweights    # do calculation    if (sumcredweights > 0):        Info.yearmark = round(np.sum(marks*credweights)/sumcredweights + 0.000001,1)  # round to 1 d.p.    else:        Info.yearmark = -1  # if no marks        return Info################################################################# get overall average year mark for Physics and Math separately including overall year mark (for M+P students only)def get_mp_yearmark(Info):        marks       = np.array(Info.marks.copy())    credweights = np.array(Info.credweights.copy())  # Needed for separate Physics/Math averages    credits     = np.array(Info.credits.copy())      # Needed for year average for weighting of Physics/Math        # Physics    idx = Info.phys_units_idx    physcredweights = np.sum(credweights[idx])    if (physcredweights > 0):        phys_yearmark = np.sum(marks[idx]*credweights[idx])/physcredweights  # do not round yet    else:        phys_yearmark = 0.0            # Math    idx = Info.math_units_idx    mathcredweights = np.sum(credweights[idx])    if (mathcredweights > 0):        math_yearmark = np.sum(marks[idx]*credweights[idx])/mathcredweights  # do not round yet    else:        math_yearmark = 0.0        # Overall year mark replaced by weighted average of M+P separately using original credit weightings (for M+P students only)    # Exclude deferred credits from the credit M+P credit split (Judith email 06-Jul-2022 but won't be an issue for future years)    if (Info.mathstudent):        phys_units_idx = Info.phys_units_idx.copy()        math_units_idx    = Info.math_units_idx.copy()        excluded_idx = Info.excluded_idx.copy()            # get physics/maths units omitting excluded ones        phys_assessed_credits_idx = [idx for idx in phys_units_idx if idx not in excluded_idx]        math_assessed_credits_idx = [idx for idx in math_units_idx if idx not in excluded_idx]        sumcredits_phys = np.sum(credits[phys_assessed_credits_idx])        sumcredits_math    = np.sum(credits[math_assessed_credits_idx])        if ( (sumcredits_phys+sumcredits_math) == 0):  # just to catch when 0 credits            yearmark = 0        else:            yearmark           = (phys_yearmark*sumcredits_phys + math_yearmark*sumcredits_math)/(sumcredits_phys+sumcredits_math)        Info.yearmark      = round(yearmark+0.000001,1)  # only add back to Info if math student (round to 1 d.p.)            # Add back to Info    Info.physcredweights = physcredweights    Info.mathcredweights    = mathcredweights    Info.phys_yearmark   = round(phys_yearmark+0.000001,1)  # round to 1 d.p.    Info.math_yearmark      = round(math_yearmark+0.00001,1)      # round to 1 d.p.    # If missing marks (-1) put back as intger (-1) rather than -1.0    if (Info.yearmark < 0): Info.yearmark = -1    if (Info.phys_yearmark < 0): Info.phys_yearmark = -1    if (Info.math_yearmark < 0): Info.math_yearmark = -1             # Add O/P/M string and physics/math credist taken string for output    Info.year_opm           = str(Info.yearmark) + ' / ' + str(Info.phys_yearmark) + ' / ' + str(Info.math_yearmark)     Info.creditstaken_pm    = str(Info.physcreditstaken) + ' / ' + str(Info.mathcreditstaken)        return Info################################################################# Get overall mark based on years availabledef get_overallmark(Info,doCF):    overallmark=-1    overallmathmark=-1    overallphysmark=-1        # If no Carry Forward, then can only do this years mark and get out    if (doCF == False):        Info.overallmark = overallmark        Info.overallphysmark = overallphysmark        Info.overallmathmark   = overallmathmark        Info.overallmark_opm   = ''                return Info        # BSc    if ('BSc' in Info.Plan and 'Math' not in Info.Plan):                if(Info.phys1<0 and Info.phys2>0): overallmark=0.3333*Info.phys2+0.6666*Info.yearmark # no first year mark, so direct entry        elif(Info.phys1<0 and Info.phys2<0): overallmark = Info.yearmark  # no first or second year mark, so direct entry (also 1st year)        elif(Info.phys1>0 and Info.phys2<0): overallmark = 0.25*Info.phys1 + 0.75*Info.yearmark  # for 2nd years when CF file available        else: overallmark = 0.1*Info.phys1+0.3*Info.phys2+0.6*Info.yearmark        overallphysmark = overallmark                         #  MPHYS    if ('MPhys' in Info.Plan and 'Math' not in Info.Plan):        if (Info.phys1>0 and Info.phys2>0 and Info.phys3<0): overallmark = (0.06/0.625)*Info.phys1 + (0.19/0.625)*Info.phys2 + (0.375/0.625)*Info.yearmark # 3rd year progressing        elif (Info.phys1 < 0 and Info.phys2 > 0 and Info.classyear == 31): overallmark = (0.19/0.565)*Info.phys2 + (0.375/0.565)*Info.yearmark # 3rd year progressing (no 1st year mark)        elif (Info.phys1 < 0 and Info.phys2 > 0 and Info.phys3 > 0): overallmark = 0.2*Info.phys2+ 0.4*Info.phys3 + 0.4*Info.yearmark  # no first  year mark, so direct entry        elif (Info.phys1 < 0 and Info.phys2 < 0 and Info.phys3>0): overallmark = 0.5*Info.phys3 + 0.5*Info.yearmark  # no first or second year mark, so direct entry (4th year)        elif (Info.phys1 < 0 and Info.phys2 < 0 and Info.phys3<0): overallmark = Info.yearmark  # only 4th year mark available        elif (Info.phys1>0 and Info.phys2<0): overallmark = (0.06/0.25)*Info.phys1 + (0.19/0.25)*Info.yearmark   # 2nd year when CF file available         else: overallmark = 0.06 * Info.phys1 + 0.19 * Info.phys2 + 0.375 * Info.phys3 + 0.375*Info.yearmark   # 4th year default              # MPHYS study in    if (Info.abroad == True):         if (Info.phys1>0 and Info.phys2<0): overallmark = (0.08/0.31)*Info.phys1 + (0.23/0.31)*Info.yearmark   # 2nd year when CF available         elif (Info.phys1>0 and Info.phys2>0 and Info.phys3<0): overallmark = (0.08/0.54)*Info.phys1 + (0.23/0.54)*Info.phys2 + (0.23/0.54)*Info.yearmark   # 3rd year        else: overallmark = 0.08 * Info.phys1 + 0.23 * Info.phys2 + 0.23 * Info.phys3 + 0.46*Info.yearmark     # 4th year    # Phys Europe 4th year - requires [3A] or [A] to be added to the program code to differentiate them.    if (Info.Euro == True):        overallmark = 0.08 * Info.phys1 + 0.23 * Info.phys2 + 0.23 * Info.phys3 + 0.46 * Info.yearmark    overallphysmark = overallmark  # log physics mark    # BSc M/P    if ('BSc' in Info.Plan and 'Math' in Info.Plan):        if (Info.phys1<0 and Info.phys2>0): # no first year mark, so direct entry            overallmark=0.3333*(Info.phys2+Info.math2)/2.+0.6666*Info.yearmark             overallphysmark = 0.3333 * Info.phys2 + 0.6666 * Info.phys_yearmark             overallmathmark = 0.3333 * Info.math2 + 0.6666 * Info.math_yearmark        elif (Info.phys1>0 and Info.phys2<0): # 2nd year students when CF file available             overallmark = 0.25*(Info.phys1+Info.math1)/2. + 0.75*Info.yearmark            overallphysmark = 0.25*Info.phys1 + 0.75*Info.phys_yearmark            overallmathmark = 0.25*Info.math1 + 0.75*Info.math_yearmark        else:            overallmark= 0.1*(Info.phys1+Info.math1)/2. + 0.3*(Info.phys2+Info.math2)/2. +0.6*Info.yearmark            overallphysmark = 0.1*Info.phys1 + 0.3*Info.phys2 + 0.6*Info.phys_yearmark            overallmathmark = 0.1*Info.math1 + 0.3*Info.math2 + 0.6*Info.math_yearmark    # MPHYS M/P.    if ('Phys' in Info.Plan and 'Math' in Info.Plan and 'BSc' not in Info.Plan):        if (Info.phys1 < 0 and Info.phys2 > 0): # no first  year mark, so direct entry            overallmark = 0.2*(Info.phys2+Info.math2)/2.+ 0.4*Info.year3mark + 0.4*Info.yearmark              overallmathmark = 0.2*Info.math2 + 0.4*Info.math3 + 0.4*Info.math_yearmark            overallphysmark = 0.2*Info.phys2+ 0.4*Info.phys3 + 0.4*Info.phys_yearmark        elif (Info.phys1 < 0 and Info.phys2 < 0): # no first or second year mark, so direct entry            overallmark = 0.5*Info.year3mark + 0.5*Info.yearmark              overallphysmark = 0.5*Info.phys3 + 0.5*Info.phys_yearmark            overallmathmark = 0.5*Info.math3 + 0.5*Info.math_yearmark        elif (Info.phys1>0 and Info.phys2<0):  # 2nd years when CF file available             overallmark = 0.06/0.25 * (Info.phys1+Info.math1)/2. + 0.19/0.25*Info.yearmark            overallmathmark =  0.06/0.25 * Info.math1 + 0.19/0.25 * Info.math_yearmark            overallphysmark = 0.06/0.25 * Info.phys1 + 0.19/0.25 * Info.phys_yearmark        elif (Info.phys1>0 and Info.phys2>0 and Info.phys3<0): # 3rd years            overallmark = (0.06/0.625)*(Info.phys1+Info.math1)/2. + (0.19/0.625)*(Info.phys2+Info.math2)/2. + (0.375/0.625)*Info.yearmark            overallmathmark =  (0.06/0.625)*Info.math1 + (0.19/0.625)*Info.math2 + (0.375/0.625)*Info.math_yearmark            overallphysmark = (0.06/0.625)*Info.phys1 + (0.19/0.625)*Info.phys2 + (0.375/0.625)*Info.phys_yearmark        else: # 4th years            overallmark = 0.06 * (Info.phys1+Info.math1)/2. + 0.19 * (Info.phys2+Info.math2)/2. + 0.375 * Info.year3mark + 0.375*Info.yearmark            overallmathmark =  0.06 * Info.math1 + 0.19*Info.math2 + 0.375*Info.math3 + 0.375*Info.math_yearmark            overallphysmark = 0.06 * Info.phys1 + 0.19 * Info.phys2 + 0.375 * Info.phys3 + 0.375*Info.phys_yearmark    # Add back to Info    Info.overallmark         = round(overallmark+0.000001,1)    Info.phys_overallmark = round(overallphysmark+0.000001,1)    Info.math_overallmark    = round(overallmathmark+0.000001,1)    # also output O/P/M    Info.overallmark_opm = str(Info.overallmark) + ' / ' + str(Info.phys_overallmark) + ' / ' + str(Info.math_overallmark)        return Info################################################################# get status for progression# remove referred/deferred info if already faileddef get_status(Info):    if (Info.fail == False): # unless a fail for another reason 'ACTV' default status to begin with        Info.status = 'ACTV'          # borderlines for MPhys students    if (Info.AY<=2019):        rbsc_upper = 52.95        rx_upper   = 54.95    elif (Info.AY>2019 and Info.AY<2022):        rbsc_upper = 51.95  # changed due to COVID after 2019 (used in 2020/2021)        rx_upper   = 54.95    elif (Info.AY>=2022): # from 2023 back to normal        rbsc_upper = 52.95         rx_upper   = 54.95            if (len(Info.deferred_idx) > 0):        Info.status = 'A/D'         # student with deferrals    if (len(Info.referred_idx) > 0):         Info.status = 'REVW'        # student with resits (REVW trumps A/D)            # MPhys borderline/move to BSc students (for Y2/3 and above)    if (Info.mphysstudent == True and Info.classyear != 1 and Info.classyear != 4 and Info.classyear != 31 and len(Info.referred_idx) == 0 and len(Info.deferred_idx) == 0):        # For most students including 1st pass and 2nd pass when deferrals        if (Info.yearmark < rbsc_upper):            Info.status = 'R/BSc'        elif (Info.yearmark < rx_upper):            Info.status = 'R/X'        # If no deferrals on 2nd pass, use previous (June) mark (Judith email 15-Sep-2022)        if (Info.secondpass == True):                yearmark = Info.p_yearmark # (previous mark in June)                if (yearmark < rbsc_upper):                    Info.status = 'R/BSc'                elif (yearmark < rx_upper):                    Info.status = 'R/X'    # Y3->Y4 progression    if (Info.classyear == 31):        # set credits passed and limits        creditspassed = Info.creditspassed        if (Info.AY >= 2022): creditspassed = Info.credits34passed  # only level 3/4/6 courses from 2022 onwards count        min_credits = 80        if (Info.AY >= 2023): min_credits = 100  # New rule that min 20 credits to fail (because max 40 over Y3/Y4)                if (Info.faillabprog==False and creditspassed>=min_credits and Info.yearmark>=49.95 and Info.overallmark>=49.95):            Info.status   = 'ACTV'            Info.fail     = False            Info.progress = True        elif (Info.faillabprog==False and creditspassed>=min_credits and (Info.yearmark>=47.95 and Info.overallmark>=47.95) ):  # borderline goes to review            Info.status   = 'REVW'            Info.fail     = False            Info.progress = False        elif (Info.faillabprog==False and creditspassed>=60):  # borderline wtih fewer credits goes to review for BSc            if (Info.overallmark>59.95 and creditspassed>=80): Info.status = 'REVW BSc 2:1'            elif (Info.overallmark>49.95 and creditspassed>=80): Info.status = 'REVW BSc 2:2'            elif (Info.overallmark>39.95 and creditspassed>=60): Info.status = 'REVW BSc 3'            else:                Info.status   = 'FAIL'                Info.failreason = '<MPhys fail (<50%) and not enough marks/credits for BSc 3'                Info.fail     = True                Info.progress = False        else:  # MPhys Fail -> BSc            Info.status   = 'FAIL->BSc'            Info.fail     = True            Info.progress = False            if (Info.faillabprog == True):   Info.failreason = 'MPhys fail (lab/project) -> BSc'            elif (creditspassed < 100):      Info.failreason = 'MPhys fail (credits) -> BSc'            elif (Info.overallmark < 49.95): Info.failreason = 'MPhys fail (<50%) -> BSc'                            # Additional requirement for M+P students to get >45% M+P separately to progress in 3rd year to progress    if (Info.mathstudent == True and Info.classyear == 31):         if (Info.faillabprog == False and (Info.phys_yearmark<45 or Info.math_yearmark<45)): # >45% M+P separately            if (Info.classyear==31):                       if (Info.overallmark>boundaryupper2): Info.status = 'REVW BSc 2:1'                elif (Info.overallmark>boundarylower2): Info.status = 'REVW BSc 2:2'                elif (Info.overallmark>boundarythird): Info.status = 'REVW BSc 3'                else: # if not borderline, then is a fail                    Info.status = 'FAIL'                    Info.failreason = '<45% separately in Math/Phys and not borderline'                    Info.fail = True                    Info.progress = False                    if (Info.faillabprog == True):  # student has failed lab        Info.status = 'FAIL'        Info.failreason = 'failed lab/project/generalpaper'    # Y1/Y2 if < 80 credits (if > 60, may be able to resit as per below)    if ( (Info.classyear == 1 or Info.classyear == 2) and ((Info.creditspassed+Info.deferredcredits) < 80) and len(Info.referred_idx) == 0):        Info.fail = True        Info.progress = False        Info.status = 'FAIL'        Info.failreason = '<80 credits'    # If yearmark < 40% or fewer than 60 credits, then fail     if ((Info.creditspassed + Info.deferredcredits) < 60):        Info.fail   = True        Info.status = 'FAIL'        Info.failreason = '< 60 credits'            # For 2nd attempts that are failed or no mark for a resit then is a fail (unless codes say is first attempt or can be excluded)    if (Info.secondpass == True):        for idx in Info.secondattempt_idx:            if (Info.marks[idx] < 29.95 and idx not in Info.excluded_idx and idx not in Info.referred_idx):                Info.fail = True                Info.progress = False                Info.status = 'FAIL'                Info.failreason = 'Failed (<30%) 2nd attempt resits'    # If 'PRO' in the marks likely the full marks are not in so just change fail to ACTV unless definitely deferred units    if ('PRO' in Info.codes):        Info.status = 'ACTV'        Info.fail   = False        Info.progress = True        Info.failreason = ''    elif (hasattr(Info,'p_codes') and 'PRO' in Info.p_codes):        Info.status = 'ACTV'        Info.fail   = False        Info.progress = True        Info.failreason = ''    # if it looks like a repeating student remove _R, _C etc. and  reset status and output to screen for info    # (these would normally be put in the donotprocesslist)    if (Info.finalyear == False and Info.resitgrid == False and Info.repeating == True):        Info.status = ''        Info.codes = ['']*len(Info.codes)        Info.compensated_idx = []        Info.referred_idx = []        Info.referredcoursenames = ''        Info.deferred_idx = []        Info.repeating = True        print('Looks like a repeating student (XXC or 30R marks etc.) therefore details will be incorrect (marks should still be ok)')       # In general, if a fail, referrals/deferalls and print out the fail reason (but keep unit codes there for information)    if (Info.fail == True):         if (Info.resitgrid == False or (Info.resitgrid == True and Info.secondpass == True) ): # but not if 1st pass for resit grid             #Info.codes = ['']*len(Info.codes)            #Info.compensated_idx = []            #Info.referred_idx = []            Info.referredcoursenames = ''            #Info.deferred_idx = []            Info.deferredcoursenames = ''            print('Fail due to ' + Info.failreason)            return Info################################################################# get degree classification based on overall mark for finalyear students# also, include promotion if relevantdef get_degclass(Info):    # If not final year    if (Info.finalyear == False):        return Info    fail = 0  # Not a fail by default    demote = 0  # Not demoted by default (this is for deciding whether promotion cann be applied later)    creditspassed = Info.creditspassed  # credits passed        # BSc    if (classyear == 32):                    # get appropriate number of credits passed        if (AY >= 2022): creditspassed = Info.credits34passed # must be Y3 or Y4 courses (from 2022 onwards)                    if  creditspassed>=creditstogetBScgood and Info.overallmark>=boundaryfirst:            honours=1            degclass=4        elif creditspassed >= creditstogetBSclower and creditspassed <=creditstogetBScgood and Info.overallmark >= boundaryfirst:            honours = 1            degclass = 3            demote = 1        elif creditspassed>=creditstogetBScgood and Info.overallmark>=boundaryupper2 and Info.overallmark<boundaryfirst:            honours = 1            degclass = 3        elif creditspassed>=creditstogetBSclower and creditspassed <=creditstogetBScgood and Info.overallmark>=boundaryupper2 and Info.overallmark<boundaryfirst:            honours = 1            degclass = 2            demote = 1        elif creditspassed>=creditstogetBScgood and Info.overallmark>=boundarylower2 and Info.overallmark<boundaryupper2:            honours = 1            degclass = 2        elif creditspassed>=creditstogetBSclower and creditspassed<creditstogetBScgood and Info.overallmark>=boundarylower2 and Info.overallmark<boundaryupper2:            honours = 1            degclass = 1            demote = 1        elif creditspassed >= creditstogetBSclower and Info.overallmark >= boundarythird:            honours = 1            degclass = 1        elif creditspassed >= creditstogetBSclower:            honours =0            degclass=0            demote = 1        else: # Fail            honours=0            degclass=-1            fail = 1            demote = 1        # MPhys    if (classyear == 4):        if  creditspassed>=creditstogetMPHYS and Info.overallmark>=boundaryfirst:            honours=1            degclass=4        elif creditspassed >= creditstogetMPHYSlower and creditspassed <=creditstogetMPHYS and Info.overallmark >= boundaryfirst:            honours = 1            degclass = 3            demote = 1        elif creditspassed>=creditstogetMPHYS and Info.overallmark>=boundaryupper2 and Info.overallmark<boundaryfirst:            honours = 1            degclass = 3        elif creditspassed>=creditstogetMPHYSlower and creditspassed <=creditstogetMPHYS and Info.overallmark>=boundaryupper2 and Info.overallmark<boundaryfirst:            honours = 1            degclass = 2            demote = 1        elif creditspassed>=creditstogetMPHYS and Info.overallmark>=boundarylower2 and Info.overallmark<boundaryupper2:            honours = 1            degclass = 2        else: # Fail            honours=0            degclass=-1            fail = 1            demote = 1                              # Put back into Info    Info.honours  = honours    Info.degclass = degclass    Info.fail     = fail    Info.demote   = demote    return Info################################################################# Apply promotion to borderline students in final yeardef apply_promotion(Info):    if (Info.finalyear == False or Info.demote == True):  # if not final year or has been demoted for not enough credits, continue        return Info    # determine if borderline or not    if( (Info.overallmark >= borderfirst and Info.overallmark < boundaryfirst) or (Info.overallmark >= borderupper2 and Info.overallmark < boundaryupper2) or (Info.overallmark >= borderlower2 and Info.overallmark < boundarylower2) or (Info.overallmark>=borderthird and Info.overallmark<boundarythird)):        Info.borderline = True        Info.promote    = False    else:   # Just carry on if not borderline        Info.borderline = False        Info.promote = False        return Info    # If borderline see if can be promoted    if (Info.borderline == True):        # Get credits credits in each class        marks = Info.marks.copy()        idx = [i for i, v in enumerate(marks) if v >= boundaryfirst] # 1st        Info.credsatfirst = sum([Info.credits[i] for i in idx])        idx = [i for i, v in enumerate(marks) if (v >= boundaryupper2 and v < boundaryfirst)]  #2:1        Info.credsatupper2 = sum([Info.credits[i] for i in idx])        idx = [i for i, v in enumerate(marks) if (v >= boundarylower2 and v < boundaryupper2)] #2:2        Info.credsatlower2 = sum([Info.credits[i] for i in idx])        idx = [i for i, v in enumerate(marks) if (v >= boundarythird and v < boundarylower2)]  #3rd        Info.credsatthird = sum([Info.credits[i] for i in idx])        # credits above each class        Info.credsaboveupper2 = Info.credsatfirst + Info.credsatupper2        Info.credsabovelower2 = Info.credsaboveupper2 + Info.credsatlower2        Info.credsabovethird  = Info.credsabovelower2 + Info.credsatthird                # Apply algorithm A        if (Info.classyear == 32):  # BSc            if(Info.degclass==3 and Info.credsatfirst>=creditstogetBScgood):                Info.promote=True            if(Info.degclass==2 and Info.credsaboveupper2>=creditstogetBScgood):                Info.promote=True            if(Info.degclass==1 and Info.credsabovelower2>=creditstogetBScgood):                Info.promote=True        else: # MPhys            if (Info.degclass == 3 and Info.credsatfirst >= creditstogetMPHYSalgA):                Info.promote = True            if (Info.degclass == 2 and Info.credsaboveupper2 >= creditstogetMPHYSalgA):                Info.promote = True            if (Info.degclass == 1 and Info.credsabovelower2 >= creditstogetMPHYSalgA):                Info.promote = True        # If A is successful, promote and return        if (Info.promote == True):            Info.promotetype = 'A'            Info.degclass += 1            return Info        # if A doesn't work, try algorithm B        if(Info.classyear == 32):  # BSc            if(Info.degclass==3 and Info.credsatfirst >= creditstogetalgB and Info.projectmark>=boundaryfirst and Info.yearmark>Info.overallmark):                Info.promote=True            if(Info.degclass==2 and Info.credsaboveupper2 >= creditstogetalgB and Info.projectmark>=boundaryupper2 and Info.yearmark>Info.overallmark):                Info.promote=True            if(Info.degclass==True and Info.credsabovelower2 >= creditstogetalgB and Info.projectmark>=boundarylower2 and Info.yearmark>Info.overallmark):                Info.promote=True        else: # MPhys            if (Info.degclass==3 and Info.credsatfirst >= creditstogetalgB and Info.projectmark>=boundaryfirst and Info.yearmark > Info.overallmark):                Info.promote = True            if (Info.degclass==2 and Info.credsaboveupper2 >= creditstogetalgB and Info.projectmark>=boundaryupper2 and Info.yearmark > Info.overallmark):                Info.promote = True            if (Info.degclass==1 and Info.credsabovelower2 >= creditstogetalgB and Info.projectmark>=boundarylower2 and Info.yearmark > Info.overallmark):                Info.promote = True        # If B is successful, promote and return        if (Info.promote == True):            Info.promotetype = 'B'            Info.degclass += 1            return Info    return Info################################################################# If not already promoted, try applying promotion to borderline students in final year using 2/3 of assessed credits (output P(A_X)/P(B_X) to indicate this# (see Judith email 30-Jun-2022)def apply_promotion_x(Info):    if (Info.finalyear == False or Info.demote == True):  # if not final year or has been demoted for not enough credits, continue        return Info    if (Info.promote == True):     # if already promoted, don't need to do anything        return Info        # determine if borderline or not    if( (Info.overallmark >= borderfirst and Info.overallmark < boundaryfirst) or (Info.overallmark >= borderupper2 and Info.overallmark < boundaryupper2) or (Info.overallmark >= borderlower2 and Info.overallmark < boundarylower2) or (Info.overallmark>=borderthird and Info.overallmark<boundarythird)):        Info.borderline = True        Info.promote    = False    else:   # Just carry on if not borderline        Info.borderline = False        Info.promote = False        return Info    # If borderline see if can be promoted    if (Info.borderline == True):        # Get credits credits in each class         marks = Info.marks.copy()        idx = [i for i, v in enumerate(marks) if v >= boundaryfirst] # 1st        Info.credsatfirst = sum([Info.credits[i] for i in idx])        idx = [i for i, v in enumerate(marks) if (v >= boundaryupper2 and v < boundaryfirst)]  #2:1        Info.credsatupper2 = sum([Info.credits[i] for i in idx])        idx = [i for i, v in enumerate(marks) if (v >= boundarylower2 and v < boundaryupper2)] #2:2        Info.credsatlower2 = sum([Info.credits[i] for i in idx])        idx = [i for i, v in enumerate(marks) if (v >= boundarythird and v < boundarylower2)]  #3rd        Info.credsatthird = sum([Info.credits[i] for i in idx])        # credits above each class        Info.credsaboveupper2 = Info.credsatfirst + Info.credsatupper2        Info.credsabovelower2 = Info.credsaboveupper2 + Info.credsatlower2        Info.credsabovethird  = Info.credsabovelower2 + Info.credsatthird        # get assessed credits only        assessedcredits = Info.creditstaken - Info.creditsexcluded # (this includes missing marks!)        creditstogetalgA_x = 0.6667 * assessedcredits        if (creditstogetalgA_x > 80): creditstogetalgA_x = 80  # don't have more than 80 (e.g. if taken 125+credits)                # Apply algorithm A        if (Info.classyear == 32):  # BSc            if(Info.degclass==3 and Info.credsatfirst>=creditstogetalgA_x):                Info.promote=True            if(Info.degclass==2 and Info.credsaboveupper2>=creditstogetalgA_x):                Info.promote=True            if(Info.degclass==1 and Info.credsabovelower2>=creditstogetalgA_x):                Info.promote=True        else: # MPhys            if (Info.degclass == 3 and Info.credsatfirst >= creditstogetalgA_x):                Info.promote = True            if (Info.degclass == 2 and Info.credsaboveupper2 >= creditstogetalgA_x):                Info.promote = True            if (Info.degclass == 1 and Info.credsabovelower2 >= creditstogetalgA_x):                Info.promote = True        # If A is successful, promote and return        if (Info.promote == True):            Info.promotetype = 'A_X'            Info.degclass += 1            return Info        creditstogetalgB_x = creditstogetalgA_x - 10   # -10 credits for alg B (usually 70 if no non-assessed courses)                # if A doesn't work, try algorithm B        if(Info.classyear == 32):  # BSc            if(Info.degclass==3 and Info.credsatfirst >= creditstogetalgB_x and Info.projectmark>=boundaryfirst and Info.yearmark>Info.overallmark):                Info.promote=True            if(Info.degclass==2 and Info.credsaboveupper2 >= creditstogetalgB_x and Info.projectmark>=boundaryupper2 and Info.yearmark>Info.overallmark):                Info.promote=True            if(Info.degclass==True and Info.credsabovelower2 >= creditstogetalgB_x and Info.projectmark>=boundarylower2 and Info.yearmark>Info.overallmark):                Info.promote=True        else: # MPhys            if (Info.degclass==3 and Info.credsatfirst >= creditstogetalgB_x and Info.projectmark>=boundaryfirst and Info.yearmark > Info.overallmark):                Info.promote = True            if (Info.degclass==2 and Info.credsaboveupper2 >= creditstogetalgB_x and Info.projectmark>=boundaryupper2 and Info.yearmark > Info.overallmark):                Info.promote = True            if (Info.degclass==1 and Info.credsabovelower2 >= creditstogetalgB_x and Info.projectmark>=boundarylower2 and Info.yearmark > Info.overallmark):                Info.promote = True        # If B is successful, promote and return        if (Info.promote == True):            Info.promotetype = 'B_X'            Info.degclass += 1            return Info    return Info################################################################# convert degree class to a string for output griddef degclass_to_string(Info):    # deg classification    degclass_dict = {        4:"1",        3:"2:1",        2:"2:2",        1:"3",        0:"Ord.",        -1:"Fail",        -2:"NOT SET!!!"}    # degree type    degstr = Info.Plan.split('(')[0] + ' '    # Add to Info, keeping original class if promoted and add promotion string if necessary    if (Info.promote == True):        Info.degclass_str = degstr + degclass_dict[Info.degclass-1] + ' P(' + Info.promotetype + ')'    else:        Info.degclass_str = degstr + degclass_dict[Info.degclass] #             return Info################################################################# If MPhys fail, see if can get BSc based on Y1-Y3 marksdef degclass_MPhys_to_BSc(Info):    # If 4th year MPhys fail, output BSc based on Y1-Y3 marks     # Only fail if less than 2 years worth of marks    if (Info.classyear == 4 and Info.finalyear == True and Info.fail == True):        Info2 = copy.deepcopy(Info)  # make temporary Info to trick functions that it is BSc not MPhys        Info2.classyear = 32    # Convert to a BSc student         plan = Info.Plan        Info2.Plan = plan.replace('BSc','MPhys') # Convert to a BSc student        if (Info.mathstudent == False): Info2.yearmark = Info.phys3   # 3rd year mark is now finalyear mark        else: Info2.yearmark = Info.year3mark                         # Average Phys/Math for M+P students        Info2.phys3 = -1              # set this back to -1        Info.math3  = -1              # set this back to -1        Info2 = get_overallmark(Info2,doCF)  # Get overall mark if CF available        newoverallmark = Info2.overallmark    # new overall mark        Info.newoverallmark = round(newoverallmark+0.00001,1)  # add to Info        if (newoverallmark>boundaryfirst): Info.degclass_str = 'BSc 1' + ' (' + str(newoverallmark) + '%)'        elif (newoverallmark>boundaryupper2): Info.degclass_str = 'BSc 2:1' + ' (' + str(newoverallmark) + '%)'        elif (newoverallmark>boundarylower2): Info.degclass_str = 'BSc 2:2' + ' (' + str(newoverallmark) + '%)'        elif (newoverallmark>boundarythird): Info.degclass_str = 'BSc 3' + ' (' + str(newoverallmark) + '%)'        else: Info.degclass_str = 'MPhys Fail'        # Check that there are at least 2 years of marks otherwise it is still a fail (chat with Judith 30-Jun-2022)        markyears = [Info.phys1, Info.phys2, Info.phys3]        idx = [i for i, x in enumerate(markyears) if x < 0]        if (len(idx) > 1):            Info.degclass_str = 'Fail (<2 years BSc marks)'                return Info################################################################# cleanup PP/study in Europe/abroad status/deg/overall mark if not avaialbledef cleanup_nomark_students(Info):    # If no courses listed at all so no credits taken, don't show averages/fail    if (Info.creditstaken <= 0):        Info.degclass_str = ''        Info.status = 'No marks'        Info.yearmark = -1        Info.overallmark = -1            # If PP or Stufy in Europe/abroad student with no final year marks but still may have a coursename in the list with credits    if (('PP' in Info.Plan or 'Eu' in Info.Plan) and Info.yearmark < 0):        Info.degclass_str = 'ACTV'        Info.status = 'ACTV'        Info.fail = False        Info.overallmark = -1    # If study abroad and have PHYS31000/PHYS41000 with no marks, indicate in output as "Intercal" (Judith email 01-Jul-2022)    # Also PP students via PHYS30810 etc. (probably better than above)    abroadunits_idx = np.array([i for i, names in enumerate(Info.coursenames) if ('PHYS31000' in names or 'PHYS41000' in names or 'PHYS30810' in names or 'PHYS40810' in names)])    if (len(abroadunits_idx) > 0):        marks = np.array(Info.marks)        markstotal = np.sum(marks[abroadunits_idx])        if (markstotal < 0):            Info.degclass_str = 'Intercal'            Info.status = 'Intercal'            Info.fail = False            Info.overallmark = -1            return Info################################################################# make basic output dataframe def make_output_df():    # make list of all possible columns    columns = ['Emplid', 'Emplid*','Name', 'Plan', 'Unit 1', 'Code 1', 'Unit 2', 'Code 2', 'Unit 3', 'Code 3', 'Unit 4', 'Code 4', 'Unit 5', 'Code 5', 'Unit 6', 'Code 6', 'Unit 7', 'Code 7', 'Unit 8', 'Code 8', 'Unit 9', 'Code 9', 'Unit 10', 'Code 10', 'Unit 11', 'Code 11', 'Unit 12', 'Code 12', 'Unit 13', 'Code 13', 'Unit 14', 'Code 14', 'Unit 15', 'Code 15', 'Unit 16', 'Code 16', 'Unit 17', 'Code 17', 'Unit 18', 'Code 18', 'Unit 19', 'Code 19', 'Unit 20', 'Code 20', 'Credits Taken', 'Credits Passed', 'Year Mark', 'Overall', 'Year Av O/P/M', 'Status', 'Referred', 'Deferred','Resits', 'Mit Circ']        # make dataframe    df = pd.DataFrame(columns=columns)    return df################################################################# add column data from this student (Info) to the output student dataframedef add_data_df(df,Info,doCF,encode_sids):    # First few columns    if (encode_sids == True):        new_row1 = {'Emplid': [Info.emplid], 'Emplid*': [Info.emplid_encoded], 'Name': [Info.Name], 'Plan': [Info.Plan]}        new_row2 = {'Emplid': [''], 'Emplid*': [''], 'Name': [''], 'Plan': ['']}    elif (Info.anonymous == False):        new_row1 = {'Emplid': [Info.emplid], 'Name': [Info.Name], 'Plan': [Info.Plan]}        new_row2 = {'Emplid': [''], 'Name': [''], 'Plan': ['']}    else:        new_row1 = {'Emplid*': [Info.emplid_encoded], 'Plan': [Info.Plan]}        new_row2 = {'Emplid*': [''], 'Plan': ['']}            # Add each unit that exists - 2 columns per unit (mark and code)    for i in range(len(Info.coursenamesout)):           unit_str = 'Unit ' + str(i+1)        unitcode_str = 'Code ' + str(i+1)        new_row1[unit_str] = [Info.coursenamesout[i]]        new_row2[unit_str] = [Info.marksout[i]]      # Just mark with 2 column output        new_row1[unitcode_str] = ['']        new_row2[unitcode_str] = [Info.codes[i]]            # Rest of default columns    new_row1['Creds Taken']      = [Info.creditstaken]    new_row1['Creds Passed']     = [Info.creditspassed]    new_row1['Creds Passed/Taken'] = [str(Info.creditspassed) + ' / ' + str(Info.creditstaken)]    new_row1['Phys/Math Creds Taken'] = [Info.creditstaken_pm]    new_row1['Phys Year Mark']     = [Info.phys_yearmark]    new_row1['Math Year Mark']     = [Info.math_yearmark]    new_row1['Year Mark']          = [Info.yearmark]    new_row1['Year Av O/P/M']      = [Info.year_opm]    new_row1['Status']             = [Info.status]    new_row1['Mit Circ']           = [Info.mitcirc]    new_row1['Referred']           = [Info.referredcoursenames.rstrip(' / ')]    new_row1['Deferred']           = [Info.deferredcoursenames.rstrip(' / ')]    if (Info.referredcoursenames == ''): # this is to ensure no trailing forward slash        new_row1['Resits']             = [Info.deferredcoursenames.rstrip(' / ')]    else:        new_row1['Resits']             = [Info.deferredcoursenames + Info.referredcoursenames.rstrip(' / ')]            new_row2['Creds Taken']      = ['']    new_row2['Creds Passed']     = ['']    new_row2['Creds Passed/Taken'] = ['']    new_row2['Phys/Math Creds Taken'] = ['']    new_row2['Phys Year Mark']          = ['']    new_row2['Math Year Mark']          = ['']    new_row2['Year Mark']          = ['']    new_row2['Year Av O/P/M']      = ['']    new_row2['Status']             = ['']    new_row2['Mit Circ']           = ['']    new_row2['Referred']           = ['']    new_row2['Deferred']           = ['']    new_row2['Resits']             = ['']    # CF info if available    if (doCF == True):        new_row1['Phys 1']         = [Info.phys1]        new_row1['Phys 2']         = [Info.phys2]        new_row1['Phys 3']         = [Info.phys3]        new_row1['Math 1']         = [Info.math1]        new_row1['Math 2']         = [Info.math2]        new_row1['Math 3']         = [Info.math3]        new_row1['Overall']        = [Info.overallmark]        new_row1['Phys Overall']   = [Info.phys_overallmark]        new_row1['Math Overall']   = [Info.math_overallmark]        new_row1['Overall O/P/M']  = [Info.overallmark_opm]                    new_row2['Phys 1']         = ['']        new_row2['Phys 2']         = ['']        new_row2['Phys 3']         = ['']        new_row2['Math 1']         = ['']        new_row2['Math 2']         = ['']        new_row2['Math 3']         = ['']        new_row2['Overall']        = ['']        new_row2['Phys Overall']   = ['']        new_row2['Math Overall']   = ['']        new_row2['Overall O/P/M']  = ['']        if (Info.finalyear == True):  # Final year students            new_row1['Honours']    = [Info.honours]            new_row1['Fail']       = [Info.fail]            new_row1['Deg']        = [Info.degclass]            new_row1['Deg Class']  = [Info.degclass_str]            new_row2['Honours']    = ['']            new_row2['Fail']       = ['']            new_row2['Deg']        = ['']            new_row2['Deg Class']  = ['']                    if (Info.classyear == 4 and Info.mathstudent == True) : # for 4th M+P students            new_row1['Year 3']         = [Info.year3mark]            new_row2['Year 3']         = ['']    # level 3/4 credits passed for Y3/Y4 students (only for AY=2022)    if (Info.AY == 2022 and (Info.classyear == 31 or Info.classyear == 32 or Info.classyear == 4)):        new_row1['L3/L4 creds passed'] = [str(Info.credits3passed) + ' + ' + str(Info.credits4passed) + ' = ' + str(Info.credits34passed)]        new_row2['L3/L4 creds passed'] = ['']    # If a resit grid then blank some of the marks/final columns on the 2nd row    if (Info.resitgrid == True):        blank_columns = ['Status','Resits']        for col in blank_columns:            new_row1[col] = ['']            new_row2[col] = ['']                # add the new rows to the df    new_row1 = pd.DataFrame(data=new_row1)    new_row2 = pd.DataFrame(data=new_row2)    df = pd.concat([df,new_row1,new_row2], ignore_index=True, sort=False)    return df################################################################# Get maximum unit number used in a dataframe that actually contains datadef get_maxunit_number(df):    maxunit = 0  # counter    for i in range(20):  # max units will be 20        unit_str = 'Unit ' + str(i+1)        data     = df[unit_str].tolist()   # data for this unit number        if (any(data) == True): # check if any non-empty strings            maxunit += 1        return maxunit################################################################# Set output columns for output spreadsheet depending on student type/yeardef set_output_columns(Info,maxunit,doCF):    # First few columns are same for all (no Name if anonymous)    if (encode_sids == True):        columns = ['Emplid*', 'Emplid', 'Name', 'Plan']    elif (Info.anonymous == False):        columns = ['Emplid', 'Name', 'Plan']    else:        columns = ['Emplid*', 'Plan']            # Units where data exist    for i in range(maxunit):        unit_str = 'Unit ' + str(i+1)        unitcode_str = 'Code ' + str(i+1)        columns.append(unit_str)        columns.append(unitcode_str)    # Credits passed/taken    columns.append('Creds Passed/Taken')  # combined column to save space    # Level 3/4 credits passed for Y3/Y4 students (only for 2022)    if (Info.AY == 2022):        if (classyear == 31 or classyear == 32 or classyear == 4): columns.append('L3/L4 creds passed')        # Physics/maths credits if M+P student    #if (Info.mathstudent == True):    #    columns.append('Phys/Math Creds Taken')        # Marks columns depending on years/student type    # Previous years marks (if doCF == True and not a resit grid)    if (doCF == True and Info.resitgrid == False):        if (Info.classyear == 2):            columns.append('Phys 1')        if (Info.classyear == 31 or Info.classyear == 32):            columns.append('Phys 1')            columns.append('Phys 2')        if (Info.classyear == 4):            columns.append('Phys 1')            columns.append('Phys 2')            columns.append('Phys 3')    # Previous math marks if M+P student    if (Info.mathstudent == True and doCF == True):        if (Info.classyear == 2):            columns.append('Math 1')        if (Info.classyear == 31 or Info.classyear == 32):            columns.append('Math 1')            columns.append('Math 2')        if (Info.classyear == 4):            columns.append('Math 1')            columns.append('Math 2')            columns.append('Math 3')             # Year mark    if (Info.mathstudent == True):  # Math students have O/P/M        if (Info.AY <= 2022):            columns.append('Year Av O/P/M')        else:            columns.append('Phys Year Mark')            columns.append('Math Year Mark')            columns.append('Year Mark')    else:        columns.append('Year Mark')  # default    # Overall mark only for Y3/Y4    if (doCF == True and classyear != 1 and classyear !=2):        if (Info.mathstudent == True): # extra columns for M+P            if (Info.AY <= 2022):                columns.append('Overall O/P/M')            else:                columns.append('Phys Overall')                columns.append('Math Overall')                columns.append('Overall')        else: # default            columns.append('Overall')            # Mit Circ    columns.append('Mit Circ')    # Deg Class if final year otherwise Status if not final year    if (doCF == True and Info.finalyear == True):        columns.append('Deg Class')    else:        columns.append('Status')    # Resits for Y1/Y2    if (Info.classyear == 1 or Info.classyear == 2):        columns.append('Resits')    # If resit grid remove some columns on output    #if (Info.resitgrid == True):    #    remove_columns = ['Resits']    #    remove_columns = []  # Empty (none removed)    #    for cols in remove_columns:    #        columns.remove(cols)                # Put coursenames back to replace Unit numbers if the input was that way    #unitcolumns_dict_reversed = dict([(value, key) for key, value in unitcolumns_dict.items()])    #keys = list(unitcolumns_dict_reversed.keys())    #items = list(unitcolumns_dict_reversed.items())    #for i in np.arange(len(keys)):        return columns################################################################# sort df by year mark (progressing) / overall mark (final year)def sort_df(df,Info):    # progressing students    if (Info.finalyear == False):        for i in np.arange(0,df.shape[0]-1,2): df["Year Mark"].values[i+1] = df["Year Mark"].values[i]        df.sort_values(by="Year Mark",ascending=False,inplace=True,kind='mergesort')        for i in np.arange(0,df.shape[0]-1,2): df["Year Mark"].values[i+1] = ''        # graduating students    if (Info.finalyear == True):        for i in np.arange(0,df.shape[0]-1,2): df["Overall"].values[i+1] = df["Overall"].values[i]        df.sort_values(by="Overall",ascending=False,inplace=True,kind='mergesort')        for i in np.arange(0,df.shape[0]-1,2): df["Overall"].values[i+1] = ''    return df################################################################# Add useful codes to end of spreadsheetdef add_codes_df(df):    code_info = np.array([['',''],                ['Key:',''], ['',''],                 ['Mit Circ','Mitigating Circumstances'],                 ['#','Mit Circs not accepted'],                ['#*','Mit Circs acc; no action'],                ['#**','Mit Circs acc; action taken'],                ['',''],                ['ACTV','Met progression criteria (BSc/MPhys)'],                ['REVW','Review (resits)'],                ['A/D', 'Deferred units'],                ['R/X','MPhys student not achieved 55%'],                ['R/BSc','MPhys student not achieved 52%'],                ['FAIL','Failed due to <40% overall or <40% in lab or <60 credits'],                ['',''],                ['XL','Absent from exam, with reason'],                ['XN','Absent from exam, no reason'],                ['X','Mark excluded'],                ['X1','Resit at first attempt'],                ['',''],                ['*', 'Carry Forward flag in year mark (ongoing mitigating circumstances)'],                ['AUD', 'Marks not being assessed'],                ['',''],                ['P(A)', 'Promotion for borderline student by stage 1 criteria'],                ['P(B)', 'Promotion for borderline student by stage 2 criteria'],                ['P(A_X)', 'Promotion for borderline studeny by 2/3 of assessed credits criteria'],                ['P(B_X)', 'Promotion for borderline student by 2/3 of asssessed credits criteria']])                #['XX_P1 (YY)', 'XX post-penalty mark, YY pre-penalty mark (>=40%)'],                #['XX_P2 (YY)', 'XX post-penalty mark, YY pre-penalty mark (30-39%)'],                #['XX_P3 (YY)', 'XX post-penalty mark, YY pre-penalty mark (<30%)'] ])        nextrarows = np.shape(code_info)[0]   # number of extra rows to add    tempdf_single = df.iloc[0:1,:].copy()  # single line temporary df    tempdf = tempdf_single.copy()  # tempdf to be added to main dataframe    while (tempdf.count()[0] <= nextrarows):  # copy extra rows if they required otherwise will not get full list of codes        tempdf = pd.concat([tempdf,tempdf_single])    tempdf[:] = ''  # blank values    for i in np.arange(nextrarows):  # add code info        tempdf[columns[4]][i:i+1] = code_info[i,0]        tempdf[columns[5]][i:i+1] = code_info[i,1]    df = pd.concat([df,tempdf])   # add df's together        return df, nextrarows################################################################# Encode student IDs def encode_emplid(Info):    sid = Info.emplid    ndigits = len(sid)    offsets = [1,2,3]*10  # long list of offsets to add to each digit *except* the last one    lastdigit = int(sid[-1])  # last digit for getting starting point of offset    sid_encoded = 'E'  # always begin with an "E" to show it is encoded        for i in range(ndigits-1):        digit = (int(sid[i]) + offsets[i] + lastdigit)%10   # add offset based on last digit then take last digit        sid_encoded += str(digit)    sid_encoded += str(lastdigit)   # add original last digit back which is needed to decode    Info.emplid_encoded = sid_encoded  # add back to Info                return Info################################################################# Apply CF flags if CF_flagfile availabledef apply_CFflags(dfout,df_CFflags,doCF):    # If no data, do nothing    if (CF_flagfile == '' or doCF == False):        return dfout    # Print statement    print('Applying CF flags...')        # get data from CF flag file    flags_sid = df_CFflags.iloc[:,1].values  # 2nd column    flags_year = df_CFflags.loc[:,"Year"].values     nflags = len(flags_sid)    # loop through each row in CF flag file    for i in range(nflags):        sid = flags_sid[i]        year = str(flags_year[i])        idx = dfout[dfout.loc[:,'Emplid'] == sid].index.values  # row index of student        # skip if no matching student        if (len(idx) < 1):            continue                # edit the mark in the appropriate column by adding a '*'        if (year == '2'): column = 'Phys 2'        if (year == '3'): column = 'Phys 3'        markout = dfout.loc[idx[0]][column]        markout = str(markout) + '*'        dfout.loc[idx[0], column] = markout            return dfout################################################################# Add "_resit" to to outfilename (for resit grids)def add_resit_tofilename(filename, Info):    # If a resit grid, add "resit" to the filename    if (Info.resitgrid == True):        filename_list = filename.split('.')        filename = ''        for i in range(len(filename_list)-1):            filename += filename_list[i]            if (i < len(filename_list)-2):                filename += '.'        filename += '.resit.xlsx'    return filename        ################################################################# output to Excel spreadsheet (strings_to_numbers option so not to store unit numbers as text)def df_to_excel(df, Info, columns, nextrarows, outfilename='test.xlsx',sheet_name='Sheet 1'):        try:        writer = pd.ExcelWriter(outfilename, engine='xlsxwriter', engine_kwargs={'options': {'strings_to_numbers': True}})    except:        print('\nERROR writing out to {0:s} Please check directory...\n'.format(outfilename))        print('If not, must be a problem using pd.ExcelWriter() - make sure it is installed etc.')        sys.exit(0)        # output columns to excel spredsheet directly from Data Frame    df.to_excel(writer,index=False,sheet_name=sheet_name,columns=columns, float_format="%.1f")    # Change column width/formatting before finally writing out    workbook = writer.book    worksheet = writer.sheets[sheet_name]   # Sheet name    format1dp = workbook.add_format({'num_format': '#0.0'})  # Add float formatting to 1.d.p.    i = 0  # column index is needed    for column_str in columns: # loop over each column        col_idx = i   # column index        format1 = None  # default is no format                # set the widths        if (column_str.find('Emplid') >=0): col_width=9        elif (column_str == 'Name'): col_width=25        elif (column_str == 'Plan'): col_width=20        elif (column_str.find('Unit') >= 0): col_width=6        elif (column_str.find('Code') >= 0): col_width=6        elif (column_str.find('Creds') >= 0): col_width=15        elif (column_str.find('L3/L4 cred') >= 0): col_width=14        elif (column_str.find('Final Year Phys Mark') >=0):            col_width=16            format1 = format1dp        elif (column_str.find('Final Year Math Mark') >=0):            col_width=16            format1 = format1dp        elif (column_str.find('O/P/M') >=0): col_width=14        elif (column_str.find('Phys Overall') >=0): col_width=11        elif (column_str.find('Math Overall') >=0): col_width=11        elif (column_str.find('Phys Year Mark') >=0): col_width=12        elif (column_str.find('Math Year Mark') >=0): col_width=12                elif (column_str.find('Overall') >=0):            col_width=8            format1 = format1dp        elif (column_str.find('Phys') >= 0): col_width=6        elif (column_str.find('Math') >= 0): col_width=7        elif (column_str.find('Year 3 Mark') >=0): col_width=8        elif (column_str.find('Year Mark') >=0):            col_width=9            format1 = format1dp        elif (column_str.find('Status') >=0): col_width=8        elif (column_str.find('Deg Class') >= 0): col_width=15        elif (column_str.find('Resits') >= 0): col_width=35        elif (column_str.find('Mit') >= 0 or column_str.find('Sp') >=0): col_width=6        else: col_width=12  # default column width        # Write the format for this column        writer.sheets[sheet_name].set_column(col_idx, col_idx, col_width,format1)  # Set column width and any other formatting        # Make sure year and overall marks are to 1 d.p. (e.g. 3.0 not 3)        # Doesn't work because mix of types float, strings and objects - need to convert all to floats first        #if (column_str.find('Year') >= 0 or column_str.find('Overall') >=0):        #    writer.sheets[sheet_name].set_column(col_idx, col_idx, None, format1dp)        #    worksheet.set_column(col_idx, col_idx, None, format1dp)        i += 1  # increment counter            # Apply 1 d.p. float to specific cells because they are overriden above due to applying to entire column    # Still not quite working so comment out action line below (background format etc not correct)    # First get list of columns that will have floats    cols_1dp = ['Phys 1', 'Phys 2', 'Phys 3', 'Math 1', 'Math 2', 'Math 3', 'Year Mark', 'Overall Mark', 'Phys Year Mark', 'Math Year Mark', 'Phys Overall', 'Math Overall']    # loop over the columns and cells containing float numbers    #cols_idx = [i for i, s in enumerate(columns) if columns[i] in cols_1dp] # Get column indices for unit coursename    nrows = df.count()[0]-nextrarows    for col in cols_1dp:  # loop over each column        if (col in columns):  # check to see if it exists first            col_idx_df = df.columns.get_loc(col)  # index of column in original df            col_idx    = columns.index(col)  # index of column in the output grid            for row_idx in np.arange(nrows):                temp = df.iloc[row_idx,col_idx_df]                                    #if (type(temp) != str and temp >=0): # only apply float format if it is a number of 0 or above (to leave -1s)                    #print(col, row_idx, col_idx, temp)                    #writer.sheets[sheet_name].write_number(row_idx+1, col_idx, temp, format1dp)  # Works but overrides background colours etc.                # Make original id and name columns hidden if encode_sids option is set    if (encode_sids == True):        col_idx = columns.index('Emplid')        worksheet.set_column(col_idx, col_idx, None, None, {'hidden': True})        col_idx = columns.index('Name')        worksheet.set_column(col_idx, col_idx, None, None, {'hidden': True})    # format for grey/marged/headers    format_merge_header = workbook.add_format({'align': 'center', 'bold': True})  # bold format for merged cells    format_merge_grey = workbook.add_format({'bg_color': '#E0E0E0', 'top':1, 'align': 'center'})    format_merge_white = workbook.add_format({'bg_color': False, 'top':1, 'align': 'center'})    format_grey_topline = workbook.add_format({'bg_color': '#E0E0E0', 'top':1})    format_white_topline = workbook.add_format({'bg_color': False, 'top':1})    format_grey = workbook.add_format({'bg_color': '#E0E0E0'})    format_white = workbook.add_format({'bg_color': False})        # find shift for grey banding depending on number of rows per student and number of rows etc.    if (Info.resitgrid == True): rows_shift = 3    else: rows_shift = 2    cellheight = 17  # (Excel default is 15)    nrows = df.count()[0]-nextrarows    # get unit columns for merging    unit_cols_idx = [i for i, s in enumerate(columns) if 'Unit' in s]  # Get columns for unit coursename            # Set format of rows including merging for unit row headers (2 columns for each unit)    if (Info.resitgrid == False):        for col in unit_cols_idx: # for each Unit column            worksheet.merge_range(0, col, 0, col+1, columns[col], format_merge_header) # first header row        counter = 0 # counter for odd/even students        for row in range(1,nrows,rows_shift): # each row            counter += 1            if (counter % 2 == 0):                worksheet.set_row(row, cellheight, cell_format=format_grey_topline)                worksheet.set_row(row+1, cellheight-2, cell_format=format_grey)            else:                worksheet.set_row(row, cellheight, cell_format=format_white_topline)                worksheet.set_row(row+1, cellheight-2, cell_format=format_white)                                for col in unit_cols_idx: # for each Unit column                coursename = df.iloc[row-1,col]                if (counter % 2 == 0):                    worksheet.merge_range(row, col, row, col+1, coursename, format_merge_grey) # each unit row                else:                    worksheet.merge_range(row, col, row, col+1, coursename, format_merge_white) # each unit row                               # Do it a little different for resit grids with 3 rows per student    if (Info.resitgrid == True):        for col in unit_cols_idx: # for each Unit column            worksheet.merge_range(0, col, 0, col+1, columns[col], format_merge_header) # first header row            for row in range(1,nrows,rows_shift): # each row                coursename = df.iloc[row-1,col]                if (row % 2 == 1):                    worksheet.set_row(row, cellheight-2, cell_format=format_grey_topline)                    worksheet.set_row(row+1, cellheight-2, cell_format=format_grey)                    worksheet.set_row(row+2, cellheight-2, cell_format=format_grey)                    worksheet.merge_range(row, col, row, col+1, coursename, format_merge_grey) # each unit row                else:                    worksheet.set_row(row, cellheight-2, cell_format=format_white_topline)                    worksheet.set_row(row+1, cellheight-2, cell_format=format_white)                    worksheet.set_row(row+2, cellheight-2, cell_format=format_white)                    worksheet.merge_range(row, col, row, col+1, coursename, format_merge_white) # each unit row        # Write out and finish    workbook.close()    #df.to_excel(outfilename,index=False,sheet_name=sheet_name,columns=columns,engine='xlsxwriter')    #writer.save()  # deprecated    return None################################################################# write encoded sids to a file if encode_sids == Truedef write_encoded_sids(outfilename,all_sids, all_sids_encoded):    data = np.column_stack([all_sids, all_sids_encoded])    sidfilename = outfilename.split('.xls')[0] + '_sids.txt'    np.savetxt(sidfilename, data, fmt=['%s ','%s'])    return None################################################################# Add resit marks from 3rd row and replace marks as necessarydef get_resit_marks(Info, df):    # determine if resitting - which means there is a 3rd row    if (len(df) != 3):        print('*ERROR: no 3rd row in input...please check again...')        return Info    # add extra variables for previous marks etc. ('p_XXX')    Info.p_marks = Info.marks.copy()    Info.p_marksout = Info.marksout.copy()   # string for output marks (including potentially codes etc)    Info.p_credits = Info.credits.copy()    Info.p_codes = Info.codes.copy()    Info.p_creditspassed = Info.creditspassed  # just int so no need to copy    Info.p_creditsfailed = Info.creditsfailed  # just int so no need to copy    Info.p_deferred_idx = Info.deferred_idx.copy()    Info.p_deferredcoursenames = Info.deferredcoursenames    Info.p_referred_idx = Info.referred_idx.copy()    Info.p_referredcoursenames = Info.referredcoursenames    Info.p_compensated_idx = Info.compensated_idx.copy()    Info.p_excluded_idx = Info.excluded_idx.copy()    Info.p_excludedcoursenames = Info.excludedcoursenames    Info.p_yearmark = Info.yearmark        # add variable to indicate we are working on the 3rd row (resit marks)    Info.secondpass = True        # blank variable to store just the resit marks and idx    Info.resitmarksout = ['']*len(Info.marks)    Info.resitmarks = []    Info.resit_idx = []    # also blank some other variables from the 1st pass so not to confuse later    Info.referred_idx = []    Info.referredcoursenames = ''    Info.deferred_idx = []    Info.deferredcoursenames = ''    Info.failed_idx = []        # loop over each course in the output    columns = df.filter(regex='^Unit\ ',axis=1).columns.to_list()  # just unit columns    coursenames = Info.coursenames    row1 = df.iloc[0,:].to_list()    for i in range(len(Info.coursenames)):                idx = [x for x, s in enumerate(row1) if coursenames[i] in s][0]  # get index of column        data = df.iloc[:,idx].values  # get main data        code = df.iloc[2,idx+1]  # Get new codes for any courses        Info.codes[i] = code # put back into Info                # add mark if available otherwise continue        mark_str = str(data[2])        if (mark_str == ''):    # Keep original mark             if (Info.p_codes[i] == 'X' or Info.p_codes[i] == '_X'):                Info.codes[i] = Info.p_codes[i]  #only exclude if 'X'        else:            Info.resit_idx.append(i)          # store idx of resat marks            Info.marks[i] = int(mark_str)     # put in resit mark for now            Info.resitmarks.append(Info.marks[i]) # store actual resit mark for later            Info.resitmarksout[i] = mark_str  # store for later                    if i in Info.excluded_idx:        # Remove previous excluded courses now that a mark exists                if (Info.codes[i].find('_C') < 0):  # do not exclude if previously compensated                    Info.excluded_idx.remove(i)                    Info.excludedcoursenames.remove(coursenames[i])            if i in Info.deferred_idx:        # Remove previous deferred courses now that a new mark exists                Info.deferred_idx.remove(i)                temp = Info.deferredcoursenames.split('/')                temp = [s for s in temp if s.find(coursenames[i]) < 0] # remove coursename from list                for j in range(len(temp)):                    Info.deferredcoursenames = temp[j] + ' / '                                    # record courses with no mark for later     nomarks_idx = [i for i, j in enumerate(Info.marks) if j < 0]    # add the lists back to the Info object    Info.nomarks_idx = nomarks_idx    #print(Info.marks)        return Info################################################################# apply resit marks to be used for averages e.g. if capped, or use original mark etc.# Keep final marks array for yearmark for later, but initially output pre-capped etc. resit marksdef apply_resit_marks(Info):    # Copy actual marks to be used to another array    Info.marks_postcapped = Info.marks.copy()        # loop over each course that has been resat     for idx in Info.resit_idx:        # Decide which mark and output to use for resits        if (idx in Info.p_deferred_idx or idx not in Info.secondattempt_idx): # use new mark for previous deferrals or if R1/A1 code (i.e. 1st attempt) unless new mark is lower (and is not excluded) - see Judith email 26-Oct-2022            if (Info.p_marks[idx] > Info.marks[idx] and idx not in Info.excluded_idx):                Info.marks_postcapped[idx] = Info.p_marks[idx]            else:                Info.marks_postcapped[idx] = Info.marks[idx]        elif (idx in Info.compensated_idx and idx in Info.excluded_idx):  # if previously compensated must include in average            Info.excluded_idx.remove(idx)            Info.credweights[idx] = Info.credits[idx]        elif (Info.p_marks[idx] >= 29.95):    # original mark if not under 30             Info.marks_postcapped[idx] = Info.p_marks[idx]        elif (Info.p_marks[idx] < 29.95):               if (Info.marks[idx] > 30):    # resit mark capped at 30 if original mark < 30                Info.marks_postcapped[idx] = 30             # if OM>30 and resit < 30, put main marks to 30 to fix referral issues later (someunitunder30 == True etc)        #if (Info.marks[idx] < 29.95 and Info.p_marks[idx] >= 29.95):        #    Info.marks[idx] = Info.p_marks[idx]            return Info################################################################# add 3rd row (resit) data from this student (Info) to the output student dataframe# and add other info to the 2nd row like averages/status (not 3rd)def add_resit_data_df(df,Info):    # Blank row    columns = df.columns.to_list()    new_row = {}    for col in columns:        new_row[col] = ['']    # add the rows to the df    new_row = pd.DataFrame(new_row)    df = pd.concat([df,new_row], ignore_index=True, sort=False)    # Put in resit marks into df directly where they exist into 3rd row along with any codes    idx = [x for x, name in enumerate(columns) if name.find('Unit') >= 0]    for i in Info.resit_idx:  # only do this where there are new resit marks        df.iloc[-1,idx[i]] = Info.resitmarksout[i]        df.iloc[-1,idx[i]+1] = Info.codes[i]            # Put in averages and status to the 2nd row of df    idx = columns.index('Creds Passed/Taken')    df.iloc[-2,idx] = str(Info.creditspassed) + ' / ' + str(Info.creditstaken)    idx = columns.index('Year Mark')    df.iloc[-2,idx] = Info.yearmark    idx = columns.index('Year Av O/P/M')    df.iloc[-2,idx] = Info.year_opm    idx = columns.index('Status')    df.iloc[-2,idx] = Info.status    idx = columns.index('Resits')    df.iloc[-2,idx] = Info.deferredcoursenames + Info.referredcoursenames.rstrip(' / ')        return df################################################################################################################################# some data definitions################################################################# Credits requiredcreditstogetMPHYS = 80creditstogetMPHYSlower = 60creditstogetBScgood=80creditstogetBSclower=60if (int(AY) <= 2019): creditstogetMPHYSalgA = 75 # Used for algA else: creditstogetMPHYSalgA = 80 # New rule for 2020 onwardscreditstogetalgB = 70  # Used for algB# boundaries for degree class (2 d.ps because marks are stored to 1 d.p.)boundaryfirst=69.95boundaryupper2=59.95boundarylower2=49.95boundarythird=39.95# borderlines for promotion consideration if (AY == 2020 or AY == 2021 or AY == 2022):    borderfirst = boundaryfirst - 3.0    borderupper2 = boundaryupper2 - 3.0    borderlower2 = boundarylower2 - 3.0    borderthird = boundarythird - 4.0else:    borderfirst = boundaryfirst - 2.0    borderupper2 = boundaryupper2 - 2.0    borderlower2 = boundarylower2 - 2.0    borderthird = boundarythird - 3.0# any students to skip# For 2021 to omit exception students (see Suzanne's email 11-Jun-2021 and Y2 issues xls file and Judith email 08-Jul-2021) if (int(AY) == 2021): donotprocess=['10304702','10301241','10341954','9954785','9976148','9914290']   # IDs should be strings! else: donotprocess=[]donotprocess_actual = []  # blank one that gets filled as they get to each student and print out at the end    # define core for purpose of triggered resits i.e.  what gets resat if a student is going to have resits anyway.# This one is for studtype=1, for most Physics studentsisphyscore={'PHYS10071','PHYS10101','PHYS10121','PHYS10191','PHYS10302','PHYS10342','PHYS10352','PHYS10372','PHYS20101','PHYS20141','PHYS20171','PHYS20252','PHYS20312','PHYS20352'}# M+P students have a different list in *addition* to the iscore list aboveismathcore={'MATH10111', 'MATH10121', 'MATH10212', 'MATH11222', 'MATH11121', 'MATH110222', 'MATH20111', 'MATH20401', 'MATH29142'}# M+P Y1 students have extra non-compensatable units# Pre-2023 - all MATHs courses in Y1 must be passed (non-compensatable)# Post-2023 - only 2 MATHs (20 credit) courses need to be passed (see Judith email 14-May-2022)not_compensatable={'MATH11121', 'MATH11022'}# Set the core list depending on whether M+P student or notif (studtype == 1): iscore = isphyscoreelse: iscore = isphyscore.union(ismathcore)#define what must be passed e.g. lab, BSc dissertation.mustpass={'PHYS10180','PHYS10280',          'PHYS20180','PHYS20280',          'PHYS30180','PHYS30280','PHYS30880',          'PHYS40181','PHYS40182'}# these are where units may have different credits for the marks vs progression (*make sure these are integers, not floats!)credweightunits={'PHYS20040':10,  # main general paper (doesn't count towards progression/resits, but does count towards marks)'PHYS20240':6,            # shorter version worth only 6 (M+P,Phys/Phil, 2nd/3rd year direct entry) 'PHYS20811':5,            # Professional development CD: changed from 9 to 5 in AY2021'PHYS20821':5,            # for the few students resitting the year this course still here'PHYS30010':10,           # General paper (doesn't count towards progression/resits, but does count towards marks)'PHYS30210':6,           # General paper (short version for M+P, Phys/Phil, 2nd/3rd year direct entry)'PHYS30811':3}             # Added back for those few students re-sitting               ##'PHYS20030':0,            # Peer-Assisted Study Sessions (PASS) - no marks, no credits, but here just in case #'ULGE21030':0,            # #'ULFR21030':0,#'ULJA21020':0,#'ULRU11010':0,#'MATH35012':0,#'COMP39112':0,#'MATH49102':0}if (int(AY) <= 2020): credweightunits['PHYS20811'] = 9  # Professional development CD: changed from 9 to 5 in AY2021if (int(AY) >= 2022): credweightunits['PHYS30811'] = 0  # Now 0 (Judith, priv. comm. 24-Jun-2022) # List of general papersgeneralpapers = {'PHYS20040', 'PHYS20240', 'PHYS30010', 'PHYS30210'}noresitlist={}  # any units that can't be resit (other than 0 credit units (which are not resitable) like lab etc.)# courses to completley ignore because they don't have a mark e.g. tutorials, PASS etc. ignore_courses={'MPHYS',         # not a course                'MPHYSON',       # not a course                'PHYS10000',    # tutorials/similar                'PHYS20000',    # tutorials/similar                'PHYS30000',    # tutorials/similar                'PHYS40000',    # tutorials/similar                'PHYS10010',                    'PHYS10020',                  'PHYS10030',    # PASS (no mark/credits)                'PHYS10022',                'PHYS11000',    # requested by Judith as not relevant                'PHYS21000',    # requested by Judith as not relevant                #'PHYS31000',   # Keep this in for study abroad for info (even if no marks)                #'PHYS41000',   # Keep this in for study abroad for info (even if no marks)                'PHYS20030',                'PHYS19990',    # PASS Peer=Assissted Self-Study                'PHYS29990',    # PASS Peer=Assissted Self-Study                'PHYS39990',    # PASS Peer=Assissted Self-Study                'PHYS49990',    # PASS Peer=Assissted Self-Study                'MATH S100',    # Math Study module (0 credited) [last 0 omitted on prurpose because of extra gap]                'MATH S200',    # Math Study module (0 credited) [last 0 omitted on prurpose because of extra gap]                'MATH S300',    # Math Study module (0 credited) [last 0 omitted on prurpose because of extra gap]                'MATH S400',    # Math Study module (0 credited) [last 0 omitted on prurpose because of extra gap]                'MATH    S',     # sometimes this format                }# Hard-coded study abroad students (because Plan doesn't always distinguish them!)if (AY == 2023):    abroad_students = {'10139041', '10448445' ,'10513047', '10255376', '10292015', '10453321', '10441740', '10449626', '10519706'}else:    abroad_students = {}    ############################################################################################################################################################################################# NOW THE RUNNING PART OF THE CODE############################################################################################################################################################################################# final filenamefilename = indir + filename# Do Carry Forward or not depending on CFfilename, OR, manually set to False to ignore CFif (CFfilename != ''): doCF = Trueelse:                  doCF = Falseif (AY == 2019 and classyear == 2): doCF = False  # no 2nd year carry forward available in 2018/19#doCF = False  # to manually override if no CF available (usually - just comment out this line with a '#' at the front)    # get input datadfallstudents = read_data(filename)              # read in file to a Pandas dataframe and remove NaNsdfallstudents = check_column_names(dfallstudents)# check column names are as expected and change as necessarydfallstudents, resitgrid = extract_students_by_type(dfallstudents,classyear, studtype) # extract relevant students on programme and determine if resit griddf_CF         = get_CF_data(doCF, CFfilename)    # Get CarryForward data from separate file (if exists and doCF==True)dfout         = make_output_df()                 # Empty output dataframe with all possible columns                       sids          = get_sids(dfallstudents)          # get student ids for all relevant studentscolumn_names  = dfallstudents.columns.to_list()  # get column namesnstudents     = len(sids)                        # Number of students to deal withdf_CFflags    = read_CFflags(CF_flagfile, doCF)  # If CF_flagfile exists and doCF==True, read in the data for later################################################################# loop over SIDscounter = 0           # counter for student numberall_sids = []         # for later if neededall_sids_encoded = [] # for later if neededfor anid in sids:    # info    counter += 1    print('Processing student {0:s} ({1:d}/{2:d})'.format(anid,counter,nstudents))        if (anid in donotprocess):        print('Not processed student {0:s} (in donotprocess list)'.format(anid))          donotprocess_actual.append(anid)         continue            # do most of the work    dfstudent = get_dfstudent(dfallstudents,anid,resitgrid)      # get df for this student including unnamed columns    Info      = make_Info(dfstudent,anid,classyear, ignore_courses, AY) # Make basic Info record class using input data    Info      = get_secondattempts(Info)                         # Determine which units are a 2nd attempt i.e. proper resit    Info      = add_CF_data(Info,df_CF, anid, doCF)                 # Add CF data to Info    Info      = get_credweights(Info,credweightunits,useidx=False)  # Get credit weights using credweightunits dictionary    Info      = exclude_courses(Info)                               # Determine excluced courses    Info      = get_math_units(Info)                                # Determine which units are maths, marks/credits/credits takens    Info      = get_core_courses(Info,isphyscore, ismathcore)   # Determine which courses are "core" including Math for M+P students    Info      = get_projectmark(Info)                               # Determine the project mark    Info      = get_passed_failed(Info,mustpass,noresitlist)        # Determine which units are passed/failed    Info      = get_referred_units(Info)                            # Determine which units are referred (resit)    Info      = get_yearmark(Info)                                 # Determine average mark for the year    Info      = get_mp_yearmark(Info)                              # Determine math/physics marks separately for M+P students year mark    Info      = get_overallmark(Info,doCF)                         # Get overall mark if CF available    Info      = get_status(Info)                                    # Determine status code for progression/degree, removing referred courses if failed        # For finalyear students only    if (Info.finalyear):        Info      = get_degclass(Info)                    # Get degree classification        Info      = apply_promotion(Info)                 # Apply "standard" promotion for borderline students in final year        Info      = apply_promotion_x(Info)               # Apply promotion for borderline students in final year using assessed credits        Info      = degclass_to_string(Info)              # Convert degree classification into a string for output                if (Info.classyear == 4):            Info = degclass_MPhys_to_BSc(Info)            # For failed MPhys output BSc based on Y1-Y3 marks if available    # If requested (encode_sids == True) then encode them    if (encode_sids == True):        Info   = encode_emplid(Info)        all_sids.append(Info.emplid)        all_sids_encoded.append(Info.emplid_encoded)    Info   = cleanup_nomark_students(Info)                # Cleanup output with no year mark e.g. PP students, Europe/abroad    dfout  = add_data_df(dfout,Info,doCF,encode_sids)     # Add data to final dataframe (including CF if doCF==True)    #sys.exit(0)        # for testing resits - stop before resit logic applied below    #if (Info.emplid_encoded == 'E55402593'):    #    sys.exit(0)        # If resit grid then re-do the marks etc. including the new (resit) marks from the 3rd row    if (Info.resitgrid == True):        Info      = get_resit_marks(Info,dfstudent)                  # Get resit marks from 3rd row of df as necessary        Info      = get_secondattempts(Info)                         # Determine which units are a 2nd attempt i.e. proper resit        Info      = apply_resit_marks(Info)                          # Apply rules to say which resit mark to use (e.g. if capped)        Info      = get_credweights(Info,credweightunits,useidx=False)  # Get credit weights using credweightunits dictionary        Info      = exclude_courses(Info)                               # Determine excluced courses        Info      = get_projectmark(Info)                               # Determine the project mark        Info      = get_passed_failed(Info,mustpass,noresitlist)        # Determine which units are passed/failed        Info      = get_referred_units(Info)                            # Determine which units are referred (resit)        Info      = apply_capped_resit_marks(Info)                     # Make pre/post-capped marks arrays and apply any other rules for resits        Info      = get_yearmark(Info)                                 # Determine average mark for the year        Info      = get_mp_yearmark(Info)                              # Math/physics marks separately for M+P students year mark        Info      = get_overallmark(Info,doCF)                         # Get overall mark if CF available        Info      = get_status(Info)                                    # Status code for prog/degree removing failed referred courses        dfout     = add_resit_data_df(dfout,Info)                       # Add 3rd row (resits) to final dataframe    # Stop at a current student for testing    #if (anid == '10630652'): #     #if (Info.emplid_encoded == 'E22765850'):    #if (Info.emplid == '10445273'):    #    sys.exit(0)        # Final tidying up and outputdfout     = dfout.replace(np.nan, '', regex=True)  # Remove any NaNsdfout     = apply_CFflags(dfout,df_CFflags,doCF)   # Add CF flags if availabledfout     = dfout.replace(np.nan, '', regex=True)  # Remove any NaNsmaxunit   = get_maxunit_number(dfout)                                # Get maximum unit numbercolumns   = set_output_columns(Info, maxunit,doCF)                   # Set output columns for grid depending on student type/classyear if (Info.resitgrid == False):    dfout     = sort_df(dfout,Info)        # Sort students by year mark (progressing)/overall mark (final year) if not a resitgriddfout, nrows = add_codes_df(dfout)                                   # Add useful codes to end of spreadsheetoutfilename = add_resit_tofilename(outfilename, Info)                # If a resitgrid add "_resit" to outfilenamedf_to_excel(dfout, Info, columns, nrows, outfilename=outfilename,sheet_name='Sheet 1') # Output to excel spreadsheetif (encode_sids == True): write_encoded_sids(outfilename,all_sids, all_sids_encoded)  # output encoded sids lookup table (encode_sids==True)    # Final end statementsif (len(donotprocess_actual) > 0):    print('\nDid not process (ignored) the following students:\n')    print(donotprocess_actual)print('\nFinal output written to {0:s}'.format(outfilename))############################################################################################### End of code##############################################################################################    