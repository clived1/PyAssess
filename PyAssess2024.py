# The University of Manchester Physics and Astronomy Exam assessment code# Takes in CS exam grids (csv/xls/xlsx files) and produces output exam grids, with averages, degree classes etc.# This version is for AY2023/2024 # The program should also be able to automatically detect and run CS resit grids## This Python script requires the following to be installed (e.g. using conda (preferred) or pip):# -Python v3.9 or above (tested on v3.11 which is preferred)# -numpy (tested on v1.24.3)# -pandas v1.5.3 or above (tested with v2.0.1 preferred)# -xlsxwriter (tested on v3.1.0 preferred)# -openpyxl (tested on v3.1.2 preferred) ### Immediate to-do list:# ---------------------##### Known issues to keep in mind/future work:# ----------------------------------------## 1. My original query was whether, after deciding that the student cannot progress and so considering them for a BSc, all the BSc rules were being applied - PA if borderline, for instance, or conversely should their degree class be reduced because they don’t have 80 L3/4 credits (or 60 for a third?)  In the case of the Y3 MMathPhys student with 40 L3/4 it would seem not.## NO - setting Info.finalyear = True and adding classyear=31 to the final functions still causes issues because it is not the same as classyear=32. So will need to do more work to get this going (although in principle can take out some of the code in get_status because it can go through get_degclass()).## 2. If active filters are on the excel spreadsheet, it won't read in - you need to clear the filters, save, then try again.## 3. If a level 3 or higher course in Y1/Y2, it will still put it down as a referral. One way around this would be to add a function that adds any level 3 or higher courses to mustpass### General (background) to-list:# -----------------------------# # 1. Try to get overall/year mark to 1 d.p. even if .0 (at moment outputs 84 rather than 84.0). Probably need to remove strings_to_numbers, add ignore_errors, and then can do this using yearmarkout/overallmarkout. Can also improve highlighting of inconsistent marks with a * to the left of the number.## 2. Force the ordering to put Interrupt/Intercal/for completion status students right at the bottom (they are already are but a bit mixed).## 3. Thank you for adding the “fail reason”.  Actually that would be very useful if it were not just for fail, but for any case where the award does not tally with the marks (eg on BSc list a mark of 55% but BSc 3 because only 70 level 3&4 credits, or non-progression on the Y3 MPhys because of <100 overall credits.)  I don’t know how hard that would be to do, it’s not crucial.## 4. In df_to_excel() change df.iloc to df.loc for getting coursenames (both normal and resit for loops)## 5. Sort doesn't work with resits### MODIFICATION HISTORY:# --------------------## 20-Mar-2023  C. Dickinson    Copied PyAssess2022.py to PyAssess2023.py for major changes# 20-Mar-2023                  Replaced pd.append (deprecated) with pd.concat # 21-Mar-2023                  Changed writer.save (Deprecated) to workbook.close() # 22-Mar-2023                  Added basics of 2 column format for units including for resits# 22-Mar-2023                  Added rule for <80 credits to fail (to catch 70 credits with no resits)# 28-Mar-2023                  Updated grey banding and merging code to look reasonable# 29-Mar-2023                  Changed RBSc borderline back to 2% from 2022 onwards# 29-Mar-2023                  Remove codes/referrals/deferrals etc. if a fail# 30-Mar-2023                  Added failreason string# 30-Mar-2023                  Changed use of yearmark for resitting borderline MPhys students# 31-Mar-2023                  Reset status/cleanup when 'PRO' in inputs# 31-Mar-2023                  Use previous marks for resits for previous deferrals when previous mark is higher/0XN (JMcG email 26-Oct-2022)# 04-Apr-2023                  Begin major re-write, particularly of get_referred_units()# 16-May-2023                  Added back M+P non-compensatable units (from 2023 only 2 Y1 MATH units non-compensatable)# 17-May-2023                  Removed trailing forward slash on resits# 17-May-2023                  Implemented abroad variable testing with hard-coded abroad_students list (correct weights) # 18-May-2023                  Attempt to fix xx.0 trailing .0 in final averages not showing (still TBC)# 25-May-2023                  Added credits34passed variable (tidy up) and put in new rule for Y31 progression (max 20 failed credits)# 30-May-2023                  Put codes back if fail, only remove resit coursenames. Fixed extracting BSc M+P students.#                              First attempt at putting in MA3/4/8 codes# 31-May-2023                  CF information can now be read in from main file (Info.dooverall=True)# 10-Jun-2023                  First implementation of 2nd sheet in CS format# 12-Jun-2023                  SR 1 codes. Also warning statements if SR/MA codes when not Y1/Y2# 13-Jun-2023                  Added new Deg Class columns (Judith email 25-May-2023) and added boxes to failed units in output# 14-Jun-2023                  Removed unnecessary columns from M+P output. Put in some extra columns for CS 1-line output# 15-Jun-2023                  Added extra columns to CS 1-line output and start the CS on line 7          # 19-Jun-2023                  Added Excel formulam into CS 1-line output to copy over degree class if changed in 2-line grid# 20-Jun-2023                  Added CF/fail credits for CS format#                              Added extreme lo/hi yearmark/overall mark columns/boxes # 21-Jun-2023                  Added reading in of (optional) MCC file for unit codes#                              Added finding of A vs MA codes e.g. MA3 is same as A3 and added codes2 for 2-Line output only#                              Can read and combine multiple sheets on the MCC file# 22-Jun-2023                  Fixed output boxes for overall lo/hi mark# 23-Jun-2023                  Added degclass_actual and changes for promotetype A/B#                              XN codes and A8 details.#                              Fixed yearmark for M+P students (straight average from AY=2023)#                              Looks for "pyassess" in sheet name otherwise assumes the first one# 24-Jun-2023                  Ensure repeating students average is correct (separate L1CM etc. from phys1 in Info etc.)#                              Removed 'intercal' for PP last year students#                              Fixed overall mark for M+P students in Y3 with direct entry to Y2# 25-Jun-2023                  Changed overall mark for Y1-Y3 to all use BSc (3-year weights) -> simplified get_overallmark#                              Added new PP variables and to ignore PHYS30810(120) and creditstaken now correct# 26-Jun-2023                  More PP variables (e.g. PPaway) and fixed output for basic cases in Y3/Y4#                              Fixed level34credits for BSc/MPhys (not used for Y3 progressing students)#                              Added fail reason and fixed some bugs# 27-Jun-2023                  Allows multiple MCC files to be read in and concatenated#                              Implement interrupting students from an Excel file#                              Added ID No. to 2-line sheet to match CS-sheet. Added info into columns including orig EN codes from input.#                              Made the excel formulae for Override cells more general to find and match Emplid col id# 28-Jun-2023                  Re-write of Excel formula for award/classification and some bug fixes!#                              Added reading in of Notes files and added extra column# 29-Jun-2023                  Few bug fixes from recent updates#                              Fixed CS output sheet in a number of ways (columns, formulae for "Award" for classyear=31 etc.)#                              Fixed bug allowing A8s back into 2-line format.# 02-Jul-2023                  Added formulae for Exam Board Minutes and Notes. Added "MC" column for CS sheet. Removed gap in degclass_str# 03-Jul-2023                  Fixed MPhys failreason when progression MPhys->BSc when failed lab/project#                              Output "PRO" or code only mark to output grid#                              Fixed check_extremes to better flag marks over boundaries/borders# 05-Jul-2023                  Fixed bug with MPhys->BSc when BSc in CS award string and also when outright fail#                              Added option to cleanup_marks() for codes that we don't trust yet (blank the record if so)# 06-Jul-2023                  Turned off input MCC codes to be sure (never uses input codes unless a line is commented out by hand)#                              Removed output codes when a student is a straight fail or interrupting/intercal (keep originals on CS sheet)#                              Fixed orig_codes to only have MCC codes#                              Removed fail for <80 credits if missing marks#                              Added resits column to CS sheet and formula to copy over automatically from 2-line sheet#                              Blank status if >=40 credits worth of missing marks, blank fail, give reason# 10-Jul-2023                  Code _R goes to _R1 or _R2 and tidied up "C" codes.#                              Commented out using CM marks (e.g. L1CM) for defining repeating students because is often not the case#                              Added repeating students to MANUAL COMPLETION list# 11-Jul-2023                  Orig_en_codes and en_codes to allow new en_codes to be added to CS 1-line sheet (C, R1, R2)#                              EN codes remain if in manual completion list#                              Removed XN from A3/A4/A8 in EN codes on 1-line output#                              Creds at each level (for CS 1-line sheet) now takes into account excluded courses# 12-Jul-2023                  Added manual_students and Info.manual for manual completion students# 13-Jul-2023                  Fixed adding '_C' for compensated in all cases and remove empty space in codes#                              Removed unnecessary yearmark>40% progression criteria# 28-Aug-2023                  Added keep_input_codes variable to allow to keep input codes if no MCC file#                              Fixed row+1 to allow resit grids to output correct coursenames# 29-Aug-2023                  Put back many criteria for resit grids - mostly putting back lines into get_referred() for 2021/2022 data# 30-Aug-2023                  More resit updates for 2021/2022 data#                              Fixed updating R/X/R/BSc use of previous/new yearmark for updating status# 31-Aug-2023                  More resit fixes to make Y1/Y2 2021-2022 data work correctly again# 01-Sep-2023                  More resit fixes to make Y1/Y2 2021-2022 data working - now correct for majority of cases# 07-Sep-2023                  Some bug fixes to work on Y3 BSc-MAB file (see Judith email 07-Sep-2023).# 08-Sep-2023                  Fixed several typo bugs introduced yesterday!#                              Added keep_input_resit_codes variable and add_MCC_data() to resits part#                              Allow multiple codes per unit when reading in df_MCC# 09-Sep-2023                  Resit_idx/nomarks_idx when no mark/code on input but code in MCC file#                              Fixed referalls for resits#                              Added boxes for no marks but with XN code#                              Fixed A3/A4/A5 ordering and codes#                              L1C unit code - exclude from average# 10-Sep-2023                  Fixed A3/A4/A5 ordering and output codes#                              Added boxes around R1/R2 with no mark# 11-Sep-2023                  Fixed A3 exceptions including when A4 and passed#                              Clear out codes when a fail (resit 2nd pass)                             #                              Added get_manual for resits (2nd pass)#                              Made cleanup_manual_students from previous function to allow for use in resits#                              Put back in excluding nomark units if no 'XN' in codes or 'A5' # 18-Sep-2023                  Updated get_resit_marks to be able to take in a code next to the mark (similar to make_Info())#                              Fixed ordering in get_referred() to allow compensation for previously compensated units #                              This version now checked against "official" (final) resit output grid# 28-May-2024                  Resits - previously excluded marks, with no new mark, are still excluded in new average# 30-May-2024                  Resits - make sure compensated units use new mark when OM<30 and new mark >30# 30-May-2024                  Resits - make sure compensated units use new mark when OM<30 and new mark > 30 when compensated determined later# 30-May-2024                  Resits - if lab mark <40 but new mark>40 use new mark# 31-May-2024                  Added read_data_oneline to read in new 1-line file and added reformatting into check_column_names()# 03-Jun-2024                  Fixed Mit Circ columns in check_column_names() and added Mit Circ codes to main code variable in Make_Info()# 09-Jun-2024                  Fixed check_column_names() to only look for mark columns immediately after a module column only# 14-Jun-2024                  Fixed column indexing in df_to_excel when encode_sids=False#                              A8 -> X rather than adding to it# 16-Jun-2024                  A1 - outputs [1opt] in the deferred coursenames for these cases#                              L1C/L2C/L3C from previous year is exluded unless current year#                              Read in Y3creds_below40 file and add data to Info#                              Added new logic to get_degclass using Y3+Y4 credits passed for Y4# 17-Jun-2024                  Added functions for reading in flagCF file and adding it to the output (combined with Boundary Notes)#                              check_status() used to check against input grid for certain circumstances (e.g. if withdrawn/interrupting)#                              check_overallmarks() to check yearmark/overallmark against input grid (prints warning only at moment)# 18-Jun-2024                  Changed XN_A3/XN_A4/XN_A8 -> XL/XL_R1 and removed them from the XN list#                              cap_resit_marks() - cap marks if R2 in input grid and remove code#                              Added fill_marks option to fill in missing marks (for testing only)# 19-Jun-2024                  Some fixes to codes2 for A4/A8 with/without XN etc.#                              Added check_deg_award() to check degree award/classification against input grid (prints warning only at moment)#                              Added manual_exclusions() dictionary to allow manual exclusions of specific student/courses (for rare cases)# 20-Jun-2024                  Added if/else statements for different files for Physics/M+P students#                              If R2 on input grid, output actual mark (+"cap") while still using capped (30) mark#                              Fixed degclass_alg when PB or PA_X/PB_X, show this in review but output original deg class in both alg and actual#                              moved code from exclude_courses() to make_codes2()#                              Removed blanking of codes2 when mark ok and not deferred/referred to allow other codes to be reproduced (e.g. C3)# 21-Jun-2024                  Added '***' to grid if yearmark/overallmark/degclass_alg not consistent with input#                              Added Y3 creds failed for Y4 (and hide L3/L4 creds passed)#                              Added failreason for MPhys->BSc# 22-Jun-2024                  Removed warning about "A" codes since these can now exist (only reproduces code no action)                             # 23-Jun-2024                  Turned off '* if yearmark/overallmark <=0.1 (only gives warning if >0.1 difference)          #                              Fixed bug in yearmark comparison #                              Changed borderlines back to 3/4% for 2024# 24-Jun-2024                  Updated degree award check to look for lower case both ways so to not output ones that give warnings basically correct#                              Added check for 'XXX' in input classification so not to output error if a fail as this is equivalent#                              Only give status check warning if ACTV (not if REVW for clarity)#                              Add '**' if deg award not consistent with input# 25-Jun-2024                  Updated get_status() for Y3 MPhys prog students to put in correct rules for MPhys->BSc# 28-Jun-2024                  Fixed compensation_idx for when marks 30-39 but not a core course#                              Don't blank referrals/deferrals if lab mark = 39 and have enough credits and add to resits list#                              Re-wrote sort_df algorithm to sort by floats# 29-Jun-2024                  Rejigged lab mark = 39 to add referral, R2 code and no compensation code etc.# 30-Jun-2024                  Fixed triggered resits to work#                              Fixed missing trailing '/' in resit list#                              Added 'C1' to be treated same as R1/A1# 03-Jul-2024                  Moved cap_resit_marks() to later on so to use actual mark for credits/compensation before capping#                              Added optional sheet_name=0 for skip_nrows in case data not in first sheet# 05-Jul-2024                  Added sort_output option and read in ID from input rather than creating my own# 26-Jul-2024                  Consolidated read_data_online() into a single read_data()#                              check_column determines if resitgrid or not and adds extra rows if 1-line input#                              Added extra check for previously compensated units for resit grids# 29-Jul-2024                  Added level 3/higher courses to mustpass if not Y1/Y2 to ensure must be passed# 31-Jul-2024                  Modified read_data() to take 1st sheet if no matches#                              Modified check_columns for 3-line resit CS-faculty input grids# 06-Aug-2024                  Extra lines in exclude_courses() for resitgrids A3/A4/A5 to not exclude if previously a referral#                              Fixed capping of resit marks at 30 (if compensated)# 12-Aug-2024                  Fixed trailing '_' in codes2 for referrals#                              Fixed codes2 for resits when no mark to ensure R1/R2 in codes if in resit list#################################################################### importsimport pandas as pdimport xlsxwriter#import openpyxl # (not used at the moment but needs to be installed for reading xlsx with pandas)import numpy as npimport sysimport copy################################################################# MAIN INPUTS TO BE CHANGED################################################################# Set academic year e.g. 2021 is for 2020/21 (for filename and rules!)#AY = 2019  # for 2018/19#AY = 2021  # for 2020/2021#AY = 2022  # for 2021/2022AY = 2023  # for 2022/2023AY = 2024  # for 2023/2024# Define year (1=1st year, 2=2nd year, 31=3rd prog, 32=3rd complete ,4=4th year)classyear=2# Student type (1=Physics, 2=Math+Physics)studtype=1# Encode student IDs - if set to True (or 1) then encode the IDs, do not output names, and produce a look up table separatelyencode_sids = False# For testing non-complete grids with many missing marks, optionally fill the marks in (default=False)fill_marks = False# Keep input codes (default should be false, since they are replaced by separate MCC codes file)keep_input_codes = True  # Use True for resits (but put keep_input_resit_codes = False) N.B. Doesn't matter if no MCC file (use True)keep_input_resit_codes = True # for the resits (If False, it uses MCC_resit_filename, if True blanks them, use False if not sure)# sort the output by score (yearmark/overall mark/status). If False, keeps same ordering as input (IDs will still match eitherway)sort_output = False# do extreme marks - if set to True, compute extreme lo/hi year/overall marks for missing marks# for now, only works for Y3/Y4 final year students (switched off in get_extremes)if (classyear == 32 or classyear == 4 or classyear ==31): do_extremes = Trueelse: do_extremes = Falsedo_extremes = False    # Input directory for files (default is './' for current directory)indir = './'# CF flag file - if set to '' (blank) then ignore, otherwise use this to flag mitigating yearly averages#CF_flagfile = './data2022/Flag for CF with IDs.xlsx'CF_flagfile = ''# MCC file containing unit codes from Mit Circs which will always override any in the main input file # This can be multiple files, separated by commas - but they must have reasonable headers# (must have 'Id' in one column 'Unit' for the unit code and "EN" or "MCC" for the codes)# (also if multiple sheets each sheet should have the same names)# If set to '' ignores these (will also remove input codes from input grid unless keep_input_codes == True) # MCC_filename = ''#MCC_filename = './data2023/NO_MCC_CODES.xlsx'    # request from Judith to see averages without any MCC codes#MCC_filename = './data2023/Y3 & Y4 Ratified MCC Codes.xlsx'#MCC_filename = './data2023/test_MCC_codes.xlsx'#MCC_filename = './data2023/Y1 Ratified MCC Codes.xlsx,./data2023/Y2 - Ratified MCC Codes.xlsx'# Resit MCC Filename - just for resitsMCC_resit_filename = ''#MCC_resit_filename = './resits2023/PHYS_1221_Resit_Mitigating_Circumstances_Recommendations_UPDATE.xlsx'# Read in file for Y4 for students to get number of credits with marks < 40 to add to those in Y4Y3creds_below40_filename = './data2024/4th Year with 3rd Yr Units Below 40.xlsx'# Interrupting students file - list of students interrupting so will be at bottom of the grid with "Interupt" in status/deg class# If set to '', only students in interrupting_students array will be treatedinterrupt_filename = ''#interrupt_filename = './data2023/List of interruptions 270623.xlsx'# Boundary Notes file - file containing student IDs and notes (E.g. for borderlines or other exceptions)# This goes into Boundary Notes at the end of the 2-line format sheet# format is simply 2 columns and must be 2 columns. Can be multiple files separated by commasboundary_notes_filename = ''#boundary_notes_filename = './data2023/Borderline Decisions_GRADUATING.xlsx,./data2023/Borderline Decisions_PROGRESSING.xlsx'# Flag Carry Forward file - file containing students IDs and notes (e.g. for borderlines or other exceptions)# (very similar to boundary notes above)# format is simply 2 columns and must be 2 columns. Can be multiple files separated by commasflagCF_file = ''#flagCF_file = './data2024/Flag Carry Forward PyAssess.xlsx'# Input and output files for each cohort# Input filename (filename) can be .csv or .xls/.xlsx - the code will automatically read it in whichever the format if(classyear==1):    #filename = 'data2022/1st year exam grid_01.07.22_v3.xlsx'    #filename = 'resits 2021-22/Input grids/First Year_Resit Exam Grid_12.09_edited.xlsx'    #filename = 'data2023/Y1 - Input Grid.xlsx'    #filename = 'resits2023/PHYS_1221_Y1_RESIT_07.09.2023_StyleA_PLUS.xlsx'    if (studtype==1): filename = 'data2024/PHYS_1231_S2_Y1_Exam_Grids.xlsx'    else: filename = 'data2024/PHYS_1231_S2_Y1_MP_Exam_Grids.xlsx'    filename = 'resits2023/PHYS_1221_Y1_RESIT_07.09.2023_StyleA_PLUS.xlsx'    filename = 'resits2023/PHYS_1221 _Y1_Exam_Grids_Resit_08.09.2023.xlsx.xlsx'        CFfilename = '' # (no CF file)        # output filename    if (studtype==1): outfilename = '1styear_Physics.' + 'AY' + str(AY) + '.xlsx'   # Physics filename    else: outfilename = '1styear_MathsPhysics.' + 'AY' + str(AY) + '.xlsx'   # M+P filenameelif (classyear == 2):    #filename = 'data2022/2nd Year Exam Grid_01.07.22_v3.xlsx'    #filename = 'resits 2021-22/Input grids/Second Year_Resit Exam Grid_12.09_edited.xlsx'    #filename = 'data2023/Y2 - Input Grid.xlsx'    #filename = 'resits2023/PHYS_1221_Y2_RESIT_07.09.2020_StyleA_Plus.xlsx'    if (studtype == 1): filename = 'data2024/PHYS_1231_S2_Y2_Exam_Grids.xlsx'    else: filename = 'data2024/PHYS_1231_S2_Y2_MP_Exam_Grids.xlsx'    #filename = 'resits2023/PHYS_1221_Y2_RESIT_07.09.2020_StyleA_Plus.xlsx'    filename = 'resits2023/PHYS_1221 _Y2_Exam_Grids_Resit_08.09.2023.xlsx.xlsx'    #filename = 'resits2024/MSE_1221_YR2_EXAM_GRIDS_RESIT.xlsm'        # If CFfilename to be used (otherwise leave as blank '' to ignore or set doCF=False below)    CFfilename = ''    #CFfilename = './data2022/2nd year carry forward.xlsx'    #CFfilename = 'resits 2021-22/Input grids/2nd year carry forward.xlsx'        # output filename    if (studtype==1): outfilename = '2ndyear_Physics.' + 'AY' + str(AY) + '.xlsx'   # Physics filename    else: outfilename = '2ndyear_MathsPhysics.' + 'AY' + str(AY) + '.xlsx'   # M+P filenameelif(classyear==32):    #filename  = './data2022/3rd year exam grid_25.06.22_v2.xlsx'    #filename  = './data2023/Y3 - BSc - Input Grid.xlsx'     #filename  = './data2023/BSc-MAB.xlsx'    if (studtype==1): filename = 'data2024/PHYS_Y3_GRAD_EXAM_GRIDS_2024_V3.xlsx'    else: filename = 'data2024/PHYS_Y3_MP_GRAD_EXAM_GRIDS_2024_V3.xlsx'            #CFfilename = './data2022/3rd year carry forward.xlsx'    CFfilename = ''        # output filename    if (studtype==1): outfilename = 'FinalYear_BSc_Physics.' + 'AY' + str(AY) + '.xlsx'   # Physics filename    else: outfilename = 'FinalYear_BSc_MathsPhysics.' + 'AY' + str(AY) + '.xlsx'   # M+P filename    elif (classyear == 31):    #filename  = './data2022/3rd year exam grid_25.06.22_v2.xlsx'    #filename  = './data2023/NEW - STYLE A PLUS - Physics_Y3.xlsx'    #filename   = './data2023/Y3  - MPhys - Input Grid.xlsx'    if (studtype==1): filename  = 'data2024/PHYS_Y3_PROG_EXAM_GRIDS_2024_V3.xlsx'    else: filename = 'data2024/PHYS_Y3_MP_PROG_EXAM_GRIDS_2024_V3.xlsx'            #CFfilename = './data2022/3rd year carry forward.xlsx'    CFfilename = ''        # output filename    if (studtype==1): outfilename = '3rdyear_MPhys.' + 'AY' + str(AY) + '.xlsx'   # Physics filename    else: outfilename = '3rdyear_MMath.' + 'AY' + str(AY) + '.xlsx'   # M+P filename    elif(classyear==4):    #filename = './data2022/4th year exam grid_25.06.22_v2.xlsx'    #filename = './data2023/NEW - STYLE A PLUS - Physics_Y4.xlsx'    #filename = './data2023/Y4 - MPhys - Input Grid.xlsx'    if (studtype==1): filename = 'data2024/PHYS_Y4_GRAD_EXAM_GRIDS_2024_V3.xlsx'    else: filename = 'data2024/PHYS_Y4_MP_GRAD_EXAM_GRIDS_2024_V3.xlsx'            #CFfilename = './data2022/4th year carry forward.xlsx'    CFfilename = ''        # output filename    if (studtype==1): outfilename = 'FinalYear_MPhys.' + 'AY' + str(AY) + '.xlsx'   # Physics filename    else: outfilename = 'FinalYear_MMath.' + 'AY' + str(AY) + '.xlsx'   # M+P filenameelse:    print('*ERROR: Classyear not defined correctly (should be 1, 2, 31, 32, or 4)')    sys.exit(0)################################################################# CLASS DEFINITIONS################################################################# class to include all student info, but start with most important info# and include defaults for important parametersclass StudentInfo:    def __init__(self,emplid,classyear):        # Most important inputs        self.emplid = emplid        self.classyear = classyear        # Default parameters (in case not set and is needed by a function later)        self.status          = 'ACTV'  # default status        self.mitcirc         = ''        self.anonymous       = False        self.someunitunder30 = False        self.resitstriggered = False        self.faillabprog     = False        self.fail            = False        self.passfail        = 'Pass' # default unless not true        self.failreason      = ''        self.referredcoursenames = ''        self.deferredcoursenames = ''        self.referred_idx    = []        self.keep_referred_idx = []        self.deferred_idx    = []        self.excluded_idx    = []        self.compensated_idx = []        self.XN_idx          = []        self.marks           = []        self.marksout        = []        self.codes           = []        self.codes2          = []        self.orig_codes      = []        self.p_codes         = []        self.orig_en_codes   = []        self.en_codes        = []        self.mitcircs        = []        self.year3mark = -1        self.Y3creds_below40 = 0  # number of Y3 credits with marks < 40 (for Y4 only)        self.demote          = False        self.borderline      = False        self.promote         = False        self.promotetype     = ''        self.repeating       = False        self.resitgrid       = False        self.secondpass      = False        self.secondattempt_idx = []        self.mphysstudent    = False        self.mathstudent     = False        self.PPstudent       = False        self.PHYS30810       = False        self.PPaway          = False        self.abroad          = False        self.interrupt       = False        self.Euro            = False        self.phys1           = -1        self.phys2           = -1        self.phys3           = -1        self.math1           = -1        self.math2           = -1        self.math3           = -1        self.L1CM            = -1        self.L2CM            = -1        self.L3CM            = -1        self.L4CM            = -1        self.dooverall       = False        self.degclass_alg    = ''        self.degclass_review = ''        self.degclass_actual = ''        self.boundary_notes  = ''        self.flagCF_notes    = ''        self.award           = ''        self.mc              = '' # ('Y' if MCC codes exist otherwise blank)        self.manual          = False        self.withdrawn       = False        self.input_yearmark  = -1        self.input_overallmark = -1        self.input_award     = ''        self.input_classification     = ''        self.overallmark     = -1        self.overallmarkout  = '-1'        self.yearmark_not_consistent = False        self.overallmark_not_consistent = False        self.award_not_consistent = False        self.classification_not_consistent = False        self.lab_resit = False        ################################################################# FUNCTIONS################################################################################################################################# find the number of rows to skip before main data table# sheet_name is optional (provide the sheet name otherwise it will assume the 1st sheet)def find_skipnrows(filename,sheet_name=0):    # read all data in first    try:        if (filename.split('.')[-1] == 'csv'): df = pd.read_csv(filename, dtype='str',encoding = "ISO-8859-1")        else: df=pd.read_excel(filename,sheet_name=sheet_name, dtype='str')    except:        print('\nERROR reading the main input file (find_skipnrows()): {0:s}\nPlease check filename and/or directory and make sure it is xls/xlsx/csv format...\n'.format(filename))        print('If filename is ok, then there must be an issue with reading the file in via pandas...')        sys.exit(0)    # clean up dataframe of NaNs but leave Unnamed columns for now       df = df.replace(np.nan, '', regex=True)  # Remove NaNs    df = df.replace('\xa0', '', regex=True)  # Remove any unicode non-breakable space ('\ax0')        # find row where data starts    trycols = [1]  # try a few columns to make sure this is where the data starts    skipnrows = 0    for i in trycols:        col = df.iloc[:,i].to_list()        for j in np.arange(len(col)):            if (col[j] != ''):                nrows = j                break        if (nrows > skipnrows): skipnrows = nrows    skipnrows += 1 # to skip the required number of rows                return skipnrows################################################################# read in student data (usually from an excel (.xlsx) file but can be csv)# The correct data usually first input sheetdef read_data(filename, studtype):    try:        # must be "PyAssess" sheet name or the first input sheet if not         sheet_names = pd.ExcelFile(filename).sheet_names   # get sheet names                if (len(sheet_names) == 1): # if only one sheet use that            sheet_name = 0            print('\nOnly 1 sheet in the Excel file, so using that...\n')        elif (len(sheet_names) > 1): # if more than one look for "PyAssess"            if (studtype == 1): # for physics students                sheet_name = [s for s in sheet_names if (s.lower().find('phys') >= 0 and s.lower().find('mp') < 0)] # get matching sheet_name            elif (studtype == 2): # M+P students                sheet_name = [s for s in sheet_names if (s.lower().find('mp') >= 0)] # get matching sheet_names            if (classyear == 31): # for progressing 3rd year                sheet_name = [s for s in sheet_name if (s.lower().find('prog') >= 0)] # get matching sheet_names            if (classyear == 32): # for graduating 3rd year                sheet_name = [s for s in sheet_name if (s.lower().find('grad') >= 0)] # get matching sheet_names            if (len(sheet_name) > 1): # if more than one that match (!), take the first one but give a warning                sheet_name = str(sheet_name[0])  # take the 1st matching one anyway                print('\nWARNING: There is more than 1 sheet matching "PHYS"/"MP" - using the first one: {0:s} (Please check it is the correct one...)'.format(str(sheet_name)))            else:                sheet_name = sheet_names[0]      #  just take the 1st                print('\nWARNING: Using the first sheet: {0:s} (Please check it is the correct one...)'.format(str(sheet_name)))                        skipnrows = find_skipnrows(filename, sheet_name=sheet_name)  # get number of rows to skip                if (filename.split('.')[-1] == 'csv'): df = pd.read_csv(filename, skiprows=skipnrows, dtype='str',encoding = "ISO-8859-1")        else: df=pd.read_excel(filename,skiprows=skipnrows,dtype='str', sheet_name=sheet_name)        print('\nRead in main input file OK: {0:s}\n'.format(filename))    except:        print('ERROR reading the main input file: {0:s}\nPlease check filename and/or directory and make sure it is xls/xlsx/csv format...\n'.format(filename))        print('If filename is ok, then there must be an issue with reading the file in via pandas (also make sure no active filters set)...')        sys.exit(0)    # clean up dataframe of NaNs but leave Unnamed columns for now       df = df.replace(np.nan, '', regex=True)  # Remove NaNs    df = df.replace('\xa0', '', regex=True)  # Remove any unicode non-breakable space ('\ax0')    # just to be 100% certain, remove 'Award'/'Classification' since these are populated later in CS with real awards    # but sometimes they are incorrect and we don't want them getting in here at all!    # (We override 'Award' later but still, just in case something changes....)    #columns = df.columns.to_list()    #idx = [i for i, s in enumerate(columns) if s == 'Award']    #if (len(idx) == 1):    #    df.drop(columns=columns[idx[0]], inplace=True)    #idx = [i for i, s in enumerate(columns) if s == 'Classification']    #if (len(idx) == 1):    #    df.drop(columns=columns[idx[0]], inplace=True)                # reindex from 0 to N to ensure no gaps    #df = df.reindex(df)        return df################################################################# Remove Unnamed ('^Unnamed') columns from the dataframedef remove_unnamed_columns(df):    return df.loc[:, ~df.columns.str.contains('^Unnamed')]   # remove Unnamed columns################################################################# Check column names are standard and change as necessary# This function also converts 1-line Module/Mark/EN to old-style 2-line Unit (for AY>=2024)def check_column_names(df):    columnnames = df.columns.to_list()    # Make sure they are all strings!    for i in range(len(columnnames)):        columnnames[i] = str(columnnames[i])    df.columns = columnnames            # check that Emplid is there    if ('Emplid' not in columnnames):        if ('id' in columnnames): df.rename(columns={'id':'Emplid'}, inplace=True)        elif ('ID' in columnnames): df.rename(columns={'ID':'Emplid'}, inplace=True)        elif ('sid' in columnnames): df.rename(columns={'sid':'Emplid'}, inplace=True)        elif ('SID' in columnnames): df.rename(columns={'SID':'Emplid'}, inplace=True)        elif ('uid' in columnnames): df.rename(columns={'uid':'Emplid'}, inplace=True)        elif ('UID' in columnnames): df.rename(columns={'UID':'Emplid'}, inplace=True)        else: print('*WARNING: ''Emplid'' not in the header')    # Get ID number if it exists    if ('ID\nNo.' in columnnames):        df.rename(columns={'ID\nNo.':'ID No.'}, inplace=True)                # check that Plan is there    if ('Plan' not in columnnames):        if ('Prog' in columnnames): df.rename(columns={'Prog':'Plan'}, inplace=True)        elif ('Prog.' in columnnames): df.rename(columns={'Prog.':'Plan'}, inplace=True)        elif ('Programme' in columnnames): df.rename(columns={'Programme':'Plan'}, inplace=True)        else: print('*WARNING: ''Plan'' not in the header')    # If additional unnecessary rows/indices remove and re-index    df.dropna(axis=0,how='all',inplace=True,ignore_index=True)                # If duplicated Names/Emplid (e.g. faculty CS resit 3-line grids) then remove the extra names/emplids/plans etc.    emplids = df.loc[:,'Emplid'].to_list()    duplicate_idx = [idx for idx, val in enumerate(emplids) if val in emplids[:idx]]    for idx in duplicate_idx:        df.loc[idx,'Emplid'] = ''        df.loc[idx,'Name']   = ''        df.loc[idx,'Plan']   = ''    # determine if 1-line (faculty CS), 2-line (old-style but used by the rest of this code), 3-line (resits)    names = df.loc[:,"Name"].to_list()    names_idx = [i for i, s in enumerate(names) if s != '']    diff_idx  = list(np.diff(names_idx))    nrows_per_student = max(set(diff_idx), key=diff_idx.count)  # most common value    if (nrows_per_student == 0 or nrows_per_student > 3):        print('*ERROR: cannot determine number of rows per student (1/2/3)...usually lack of data...\n')        sys.exit(0)        # if 3-lines, must be a resit grid    if (nrows_per_student == 3):         resitgrid = True    else:        resitgrid = False    # first drop unwanted columns in between module and mark (usually "Link" columns for excel linking)    remove_cols = [s for s in columnnames if (s.lower().find('link') >=0)]    df.drop(remove_cols, axis=1, inplace=True)    columnnames = df.columns.to_list()  # update column names list    # remove Module2 columns if they exist    remove_cols = [s for s in columnnames if (s.lower().find('module2') >=0)]    df.drop(remove_cols, axis=1, inplace=True)    columnnames = df.columns.to_list()  # update column names list    # remove GBN columns if they exist    remove_cols = [s for s in columnnames if (s.lower().find('gbn') >=0)]    df.drop(remove_cols, axis=1, inplace=True)    columnnames = df.columns.to_list()  # update column names list    # remove AM1/AM2/AM3 columns if they exist    remove_cols = [s for s in columnnames if (s.lower().find('am1') >=0 or s.lower().find('am2') >=0 or s.lower().find('am3') >=0)]    df.drop(remove_cols, axis=1, inplace=True)    columnnames = df.columns.to_list()  # update column names list            # get columns with module names    module_cols_idx = [i for i, s in enumerate(columnnames) if (s.lower().find('module') >= 0)]    module_cols = [columnnames[i] for i in module_cols_idx]    nmodules = len(module_cols)    # for the other columns, there should only be one for each module so rename using dictionaries    unit_dict = {'Module':'Unit 1', 'Module.1':'Unit 2', 'Module.2':'Unit 3', 'Module.3':'Unit 4', 'Module.4':'Unit 5', 'Module.5':'Unit 6', 'Module.6':'Unit 7', 'Module.7':'Unit 8', 'Module.8':'Unit 9', 'Module.9':'Unit 10', 'Module.10':'Unit 11', 'Module.11':'Unit 12', 'Module.12':'Unit 13', 'Module.13':'Unit 14', 'Module.14':'Unit 15', 'Module.15':'Unit 16', 'Module.16':'Unit 17', 'Module.17':'Unit 18', 'Module.18':'Unit 19', 'Module.19':'Unit 20'}    en_dict = {'EN':'EN 1', 'EN.1':'EN 2', 'EN.2':'EN 3', 'EN.3':'EN 4', 'EN.4':'EN 5', 'EN.5':'EN 6', 'EN.6':'EN 7', 'EN.7':'EN 8', 'EN.8':'EN 9', 'EN.9':'EN 10', 'EN.10':'EN 11', 'EN.11':'EN 12', 'EN.12':'EN 13', 'EN.13':'EN 14', 'EN.14':'EN 15', 'EN.15':'EN 16', 'EN.16':'EN 17', 'EN.17':'EN 18', 'EN.18':'EN 19', 'EN.19':'EN 20'}    mitcirc_dict = {'Mit\nCircs':'Mit\nCircs 1', 'Mit\nCircs.1':'Mit\nCircs 2', 'Mit\nCircs.2':'Mit\nCircs 3', 'Mit\nCircs.3':'Mit\nCircs 4', 'Mit\nCircs.4':'Mit\nCircs 5', 'Mit\nCircs.5':'Mit\nCircs 6', 'Mit\nCircs.6':'Mit\nCircs 7', 'Mit\nCircs.7':'Mit\nCircs 8', 'Mit\nCircs.8':'Mit\nCircs 9', 'Mit\nCircs.9':'Mit\nCircs 10', 'Mit\nCircs.10':'Mit\nCircs 11', 'Mit\nCircs.11':'Mit\nCircs 12', 'Mit\nCircs.12':'Mit\nCircs 13', 'Mit\nCircs.13':'Mit\nCircs 14', 'Mit\nCircs.14':'Mit\nCircs 15', 'Mit\nCircs.15':'Mit\nCircs 16', 'Mit\nCircs.16':'Mit\nCircs 17', 'Mit\nCircs.17':'Mit\nCircs 18', 'Mit\nCircs.18':'Mit\nCircs 19', 'Mit\nCircs.19':'Mit\nCircs 20'}    # just got the dict entries required    unit_dict = {k: unit_dict[k] for k in list(unit_dict)[:nmodules]}    en_dict = {k: en_dict[k] for k in list(en_dict)[:nmodules]}    mitcirc_dict = {k: mitcirc_dict[k] for k in list(mitcirc_dict)[:nmodules]}    # rename all columns in the dictionaries    df.rename(columns=unit_dict, inplace=True)    df.rename(columns=en_dict, inplace=True)    df.rename(columns=mitcirc_dict, inplace=True)        # for 1-line per student (not resits)    if (nrows_per_student == 1):                mark_dict = {}        # get the columns with marks but only those immediately after module (only take this one)        for i in range(nmodules):            idx = module_cols_idx[i]            oldname = df.columns.values[idx+1]            newname = 'Mark ' + str(i+1)            mark_dict[oldname] = newname        # rename mark columns using dictionary        df.rename(columns=mark_dict, inplace=True)        # Now convert to 2 lines as per old format to allow rest of code to work seamlessly ;-)                # 1. Add blank row after each student        df.index = range(0, 2*len(df), 2)        df2 = df.reindex(index=range(2*len(df)), copy=True)                # 2. Add mark/EN codes below coursename in each Unit column - also includes Mit Circs to be added together (if exists)        mitcirc_colname = [s for s in columnnames if (s.lower().find('circ') >= 0)]        if (len(mitcirc_colname) == 0):            print('No Mit Circ column found in main input file - ensure you are using an external MCC file...\n')        else:            mitcirc_colname = mitcirc_colname[0]  # take the 1st one            for i in np.arange(0,len(df2),2):                for j in np.arange(nmodules)+1:                    df2.loc[i+1, 'Unit ' + str(j)] = df2.loc[i, 'Mark ' + str(j)]                    en_col_str = 'EN ' + str(j)                    df2.loc[i+1, en_col_str] = df2.loc[i, en_col_str]  # put in EN                     df2.loc[i,en_col_str] = ''  # blank EN on top row                    mit_col_str = mitcirc_colname + ' ' + str(j)                         df2.loc[i+1, mit_col_str] = df2.loc[i, mit_col_str]  # put in Mit Circ                    df2.loc[i,mit_col_str] = ''  # blank Mit. Circ on top row                        # 3. Remove Mark columns (so that EN is the next column after each mark)        mark_cols = list(mark_dict.values())         df2.drop(mark_cols, axis=1, inplace=True)                # clean up dataframe of NaNs but leave Unnamed columns for now           df2 = df2.replace(np.nan, '', regex=True)  # Remove NaNs        df2 = df2.replace('\xa0', '', regex=True)  # Remove any unicode non-breakable space ('\ax0')        # change back to df to return        df = df2.copy()    # make old-style 3-line format from new CS faculty 3-line format so to allow rest of code to work seamlessly ;-)    if (nrows_per_student == 3):        df2 = df.copy()        # make sure df has rows that are multiple of 3        #rem = len(df2)%3        #row = df2.loc[len(df2)-1,:]        #for i in range(rem):        #    df2 = pd.concat([df2, row],axis=1,ignore_index=True)        #df2 = df2.replace(np.nan, '', regex=True)  # Remove NaNs from new rows                    # add mark/EN codes below coursename in each Unit column - also inlcude Mit Circs to be added together (if exists)        mitcirc_colname = [s for s in columnnames if (s.lower().find('circ') >= 0)]        if (len(mitcirc_colname) == 0):            print('No Mit Circ column found in main input file - ensure you are using an external MCC file...\n')        else:            mitcirc_colname = mitcirc_colname[0]  # take the 1st one            for i in np.arange(0,len(df2),3):                for j in np.arange(nmodules)+1:                    if (df2.loc[i,'Emplid'] == ''): # if past students list on spreadsheet, don't continue                        continue                    en_col_str = 'EN ' + str(j)                    mit_col_str = mitcirc_colname + ' ' + str(j)                    df2.loc[i,en_col_str] = ''  # blank EN top row                    df2.loc[i,mit_col_str] = '' # blank Mit circ top row                    # Fill data for 2nd row                    #if (df2.loc[i+1,en_col_str] != '' and df2.loc[i+1,mit_col_str] != ''):                    #    df2.loc[i+1,en_col_str] += '_' + df2.loc[i+1,mit_col_str]                    #elif (df2.loc[i+1,mit_col_str] != ''):                    #    df2.loc[i+1,en_col_str] = df2.loc[i+1,mit_col_str]                    # Fill data for 2nd row                    #if (df2.loc[i+2,en_col_str] != '' and df2.loc[i+2,mit_col_str] != ''):                    #    df2.loc[i+2,en_col_str] += '_' + df2.loc[i+2,mit_col_str]                    #elif (df2.loc[i+2,mit_col_str] != ''):                    #    df2.loc[i+2,en_col_str] = df2.loc[i+2,mit_col_str]                            # clean up dataframe of NaNs but leave Unnamed columns for now           df2 = df2.replace(np.nan, '', regex=True)  # Remove NaNs        df2 = df2.replace('\xa0', '', regex=True)  # Remove any unicode non-breakable space ('\ax0')        # change back to df to return        df = df2.copy()            # for resits that have specific names convert to unit numbers    #keys = list(unitcolumns_dict.keys())    #for i in np.arange(len(keys)):    #    key = keys[i]    #    if (key in columnnames): df.rename(columns={key:'Unit {0:d}'.format(i)}, inplace=True)    return df, resitgrid  ################################################################# read in student data (usually from a csv file but can be excel)def read_CFflags(CF_flagfile,doCF):    # If no CF or flags then skip    if (doCF == False or CF_flagfile == ''):        return None        try:        if (filename.split('.')[-1] == 'csv'): df = pd.read_csv(CF_flagfile, dtype='str',encoding = "ISO-8859-1")        else: df=pd.read_excel(CF_flagfile,dtype='str')        print('Read in CF flags file OK: {0:s}\n'.format(filename))    except:        print('\nERROR reading the CF flasg file: {0:s}\nPlease check filename and/or directory and make sure it is xls/xlsx/csv format...\n'.format(CF_flagfile))        sys.exit(0)    # clean up dataframe of NaNs but leave Unnamed columns for now       df = df.replace(np.nan, '', regex=True)  # Remove NaNs    df = df.replace('\xa0', '', regex=True)  # Remove any unicode non-breakable space ('\ax0')        return df################################################################# function to read in unit codes from separate MCC file(s)# (which overrides unit codes in the main input file)# N.B. if multiple sheets in one file, they must have identical headers otherwise only the first sheet will work properlydef read_MCC_file(MCC_filename):    if (MCC_filename == '' or MCC_filename == None): # do nothing if MCC_filename does not exist        return None    #if multiple files (separated by commas, loop over each one    filenames = MCC_filename.split(',')    nfiles    = len(filenames)    dfs = []  # list of dataframes        for filename in filenames:            try:            if (filename.split('.')[-1] == 'csv'): df = pd.read_csv(filename, dtype='str',encoding = "ISO-8859-1")            else: df=pd.concat(pd.read_excel(filename,dtype='str', sheet_name=None), ignore_index=True)   # (read all sheets as one)            print('Read in MCC file OK: {0:s}\n'.format(filename))        except:            print('\nERROR reading the MCC file: {0:s}\nPlease check filename and/or directory and make sure it is xls/xlsx/csv format...\n'.format(filename))            print('Continuing on without MCC codes...\n')            continue        # get columns and drop unnamed columns        columns = df.columns.to_list()        columns = [col for col in columns if not col.startswith('Unnamed:')]        df = df[columns] # extract columns that are not Unnamed        # get just the key columns and give them a standard label        col1 = [s for s in columns if (s.lower().find('id') >=0)]        col2 = [s for s in columns if (s.lower().find('module') >=0 or s.lower().find('unit') >=0)]        col3 = [s for s in columns if (s.find('EN') >=0 or s.lower().find('mc') >=0 or s.lower().find('mit') >=0 or s.lower().find('deci') >=0)]                # check if columns exist at all otherwise return None and give warning        if (len(col1) == 0):            print('\nERROR reading correct ID column in the MCC file (please check column headers!)...\n'.format(filename))            print('Continuing on without MCC codes...\n')            return None        if (len(col2) == 0):            print('\nERROR reading correct Unit column in the MCC file (please check column headers!)...\n'.format(filename))            print('Continuing on without MCC codes...\n')            return None        if (len(col3) == 0):            print('\nERROR reading MCC/EN/MitCirc column in the MCC file (please check column headers!)...\n'.format(filename))            print('Continuing on without MCC codes...\n')            return None        # also check if more than 1 matching column - if so, assume first one is correct but give warning!        if (len(col1) > 1):            print('\nWARNING: more than 1 column in the MCC file {0:s} file with \"id\" in the header!\n'.format(filename))            print('Assuming the first column ({0:s}) is the correct one (please check!!!)...\n'.format(col1[0]))        if (len(col2) > 1):            print('\nWARNING: more than 1 column in the MCC file {0:s} file with \"unit\" in the header!\n'.format(filename))            print('Assuming the first column ({0:s}) is the file correct one (please check!!!)...\n'.format(col2[0]))        if (len(col3) > 1):            print('\nWARNING: more than 1 column in the MCC {0:s} file with \"en\"/\"mcc\" in the header!\n'.format(filename))            print('Assuming the first column ({0:s}) is the correct one (please check!!!)...\n'.format(col3[0]))                              # now make df with just the 3 required columns with the exact same names ready for concatenation        columns = ['ID', 'Unit', 'MCC']  # new column names                    df.rename(columns={col1[0]:columns[0], col2[0]:columns[1], col3[0]:columns[2]},inplace=True) # rename with standard names        df = df[columns].copy()   # new dataframe with just 3 columns                # clean up dataframe of NaNs         df = df.replace(np.nan, '', regex=True)  # Remove NaNs        df = df.replace('\xa0', '', regex=True)  # Remove any unicode non-breakable space ('\ax0')        # add df to list, ready to concatanate        dfs.append(df)    # concatenate    df = pd.concat(dfs, axis=0, ignore_index=True, sort=False)        return df################################################################# function to read in boundary notes from boundary_notes_file(s)# N.B. will assume 2 columns - Emplid and notesdef read_boundary_notes_file(boundary_notes_file):    if (boundary_notes_filename == ''): # do nothing if notes_filename does not exist        return None    #if multiple files (separated by commas, loop over each one    filenames = boundary_notes_filename.split(',')    nfiles    = len(filenames)    dfs = []  # list of dataframes        for filename in filenames:            try:            if (filename.split('.')[-1] == 'csv'): df = pd.read_csv(filename, dtype='str',encoding = "ISO-8859-1")            else: df=pd.concat(pd.read_excel(filename,dtype='str', sheet_name=None), ignore_index=True)   # (read all sheets as one)            print('Read in notes file OK: {0:s}\n'.format(filename))        except:            print('\nERROR reading the boundary notes file: {0:s}\nPlease check filename and/or directory and make sure it is xls/xlsx/csv format...\n'.format(filename))            print('Continuing on without boundary notes file...\n')            continue                # get just the key columns and give them a standard label        columns = df.columns.to_list()        ncolumns = len(columns)        # check number of columns        if (ncolumns < 2):            print('\nERROR with boundary notes file: {0:s}\n Only {1:d} columns when there should be 2 at least!\n'.format(filename, ncolumns))        elif (ncolumns > 2):            print('WARNING: more than 2 columns in boundary_notes file: {0:s} (using the first 2 columns)\n'.format(filename))                    # now make df with just the 3 required columns with the exact same names ready for concatenation        column_names = ['ID', 'Notes']  # new column names                    df.rename(columns={columns[0]:column_names[0], columns[1]:column_names[1]},inplace=True) # rename with standard names        df = df[column_names].copy()   # new dataframe with just 3 columns                # clean up dataframe of NaNs         df = df.replace(np.nan, '', regex=True)  # Remove NaNs        df = df.replace('\xa0', '', regex=True)  # Remove any unicode non-breakable space ('\ax0')        # add df to list, ready to concatanate        dfs.append(df)    # concatenate    df = pd.concat(dfs, axis=0, ignore_index=True, sort=False)        return df################################################################# function to read in Flag Carry Forward notes# N.B. will assume 2 columns - Emplid and Flag Carry Forwarddef read_flagCF_file(flagCF_file):    if (flagCF_file == ''): # do nothing if notes_filename does not exist        return None    #if multiple files (separated by commas, loop over each one    filenames = flagCF_file.split(',')    nfiles    = len(filenames)    dfs = []  # list of dataframes        for filename in filenames:            try:            if (filename.split('.')[-1] == 'csv'): df = pd.read_csv(filename, dtype='str',encoding = "ISO-8859-1")            else: df=pd.concat(pd.read_excel(filename,dtype='str', sheet_name=None), ignore_index=True)   # (read all sheets as one)            print('Read in flagCF file OK: {0:s}\n'.format(filename))        except:            print('\nERROR reading the flagCF notes file: {0:s}\nPlease check filename and/or directory and make sure it is xls/xlsx/csv format...\n'.format(filename))            print('Continuing on without flagCF notes file...\n')            return None                # get just the key columns and give them a standard label        columns = df.columns.to_list()        ncolumns = len(columns)        # check number of columns        if (ncolumns < 2):            print('\nERROR with flagCF notes file: {0:s}\n Only {1:d} columns when there should be 2 at least!\n'.format(filename, ncolumns))        elif (ncolumns > 2):            print('WARNING: more than 2 columns in flagCF file: {0:s} (using the first 2 columns)\n'.format(filename))                    # now make df with just the 3 required columns with the exact same names ready for concatenation        column_names = ['ID', 'Flag Carry Forward']  # new column names                    df.rename(columns={columns[0]:column_names[0], columns[1]:column_names[1]},inplace=True) # rename with standard names        df = df[column_names].copy()   # new dataframe with just 3 columns                # clean up dataframe of NaNs         df = df.replace(np.nan, '', regex=True)  # Remove NaNs        df = df.replace('\xa0', '', regex=True)  # Remove any unicode non-breakable space ('\ax0')        # add df to list, ready to concatanate        dfs.append(df)    # concatenate    df = pd.concat(dfs, axis=0, ignore_index=True, sort=False)        return df################################################################# function to read in list of interrupting students # (which overrides students in the hard-coded array) def read_interrupt_file(filename):    if (filename == ''): # do nothing if interrupting_filename does not exist        return None        try:        if (filename.split('.')[-1] == 'csv'): df = pd.read_csv(filename, dtype='str',encoding = "ISO-8859-1")        else: df=pd.concat(pd.read_excel(filename,dtype='str', sheet_name=None), ignore_index=True)   # (read all sheets as one)        print('Read in interrupts file OK: {0:s}\n'.format(filename))    except:        print('\nERROR reading the interrupting students file: {0:s}\nPlease check filename and/or directory and make sure it is xls/xlsx/csv format...\n'.format(filename))        print('Continuing on without (only students in interrupting_students array will be considered...\n')    # get just the key columns and give them a standard label    columns = df.columns.to_list()    col1 = [s for s in columns if (s.lower().find('id') >=0)]            # check if columns exist at all otherwise return None and give warning    if (len(col1) == 0):        print('\nERROR reading the correct ID column in the interrupting students file (please check column headers!)...\n'.format(filename))        print('Continuing on without MCC codes...\n')        return None            # also check if more than 1 matching column - if so, assume first one is correct but give warning!    if (len(col1) > 1):        print('\nWARNING: more than 1 column in the interrupting students file {0:s} file with \"id\" in the header!\n'.format(filename))        print('Assuming the first column ({0:s}) is the correct one (please check!!!)...\n'.format(col1[0]))            # clean up dataframe of NaNs     df = df.replace(np.nan, '', regex=True)  # Remove NaNs    df = df.replace('\xa0', '', regex=True)  # Remove any unicode non-breakable space ('\ax0')    return df################################################################# function to read in list of Y3 credits with marks < 40 (only for Y4 where Y3+Y4 creds matters)def read_Y3creds_below40_file(filename):    if (filename == '' or classyear != 4): # do nothing if interrupting_filename does not exist or if not Y4        return None        try:        if (filename.split('.')[-1] == 'csv'): df = pd.read_csv(filename, dtype='str',encoding = "ISO-8859-1")        else: df=pd.concat(pd.read_excel(filename,dtype='str', sheet_name=None), ignore_index=True)   # (read all sheets as one)        print('Read in Y3creds_below40 file OK: {0:s}\n'.format(filename))    except:        print('\nERROR reading the Y3creds_below40 file: {0:s}\nPlease check filename and/or directory and make sure it is xls/xlsx/csv format...\n'.format(filename))        return None        # get just the key columns and give them a standard label    columns = df.columns.to_list()    col1 = [s for s in columns if (s.lower().find('id') >=0 and s.lower().find('course') <0) ]    col2 = [s for s in columns if (s.lower().find('y3') >=0 and s.lower().find('credits') >=0 and s.lower().find('below 40') >=0)]        # check if columns exist at all otherwise return None and give warning    if (len(col1) == 0):        print('\nERROR reading the correct ID column in the Y3creds_below40 file (please check column headers!)...\n'.format(filename))        return None    if (len(col2) == 0):        print('\nERROR reading the correct Y3 credits below 40 column in the Y3creds_below40 file (please check column headers!)...\n'.format(filename))        return None        # also check if more than 1 matching column - if so, assume first one is correct but give warning!    if (len(col1) > 1):        print('\nWARNING: more than 1 column in the Y3creds_below40 file {0:s} file with \"id\" in the header!\n'.format(filename))        print('Assuming the first column ({0:s}) is the correct one (please check!!!)...\n'.format(col1[0]))    if (len(col2) > 1):        print('\nWARNING: more than 1 column in the Y3creds_below40 file {0:s} file with \"id\" in the header!\n'.format(filename))        print('Assuming the first column ({0:s}) is the correct one (please check!!!)...\n'.format(col2[0]))    # remove all other columns for speed/simplicity    df = df.filter([col1[0], col2[0]], axis=1)            # clean up dataframe of NaNs     df = df.replace(np.nan, '', regex=True)  # Remove NaNs    df = df.replace('\xa0', '', regex=True)  # Remove any unicode non-breakable space ('\ax0')    return df################################################################# see if is an interrupting studentdef get_interrupt(Info, df,interrupting_students):    # Interrupting students can be identified from separate file or (hard-coded) list - check this first!    if (Info.emplid in interrupting_students):        Info.interrupt = True            # if no df_interrupt, see if student is in interrupting_students array, otherwise just return    if (df is None):        return Info    # Otherwise, see if student is in df_interrupt    columns = df.columns.to_list()    col = [s for s in columns if (s.lower().find('id') >=0)]            if (Info.emplid in df[col[0]].to_list()):        Info.interrupt = True        print('Interrupting student!')            return Info################################################################# see if is student is in then "for manual completion" listdef get_manual(Info, manual_students):    # Interrupting students can be identified from separate file or (hard-coded) list - check this first!    if (Info.emplid in manual_students):        if (Info.resitgrid == True and Info.secondpass == False):            Info.manual = False        else: # for when main grid (1st pass) or resit grid (2nd pass)            Info.manual = True            print('For manual completion (insufficient/incorrect data)')            return Info################################################################# extract relevant students from df to another df by typedef extract_students_by_type(df,classyear,studtype,resitgrid):                  # get indices of relevant students    if (classyear == 1 or classyear == 2 or classyear == 4):        if (studtype == 1):            idx = df.index[(df['Plan'].str.contains('MPhys')) | (df['Plan'].str.contains('BSc')) & (~df['Plan'].str.contains('Math'))]        else:            idx = df.index[(df['Plan'].str.contains('Math'))]                if(classyear==31):        if (studtype == 1):            idx = df.index[(df['Plan'].str.contains('MPhys')) & (~df['Plan'].str.contains('Math'))]        else:            idx = df.index[(df['Plan'].str.contains('MMath'))]    #  Select BScs without math    if(classyear==32):        if(studtype==1):            idx = df.index[(df['Plan'].str.contains('BSc')) & (df['Plan'].str.contains('Phys')) & (~df['Plan'].str.contains('Math'))]        else:            idx = df.index[(df['Plan'].str.contains('BSc')) & (df['Plan'].str.contains('Math'))]                # If no students, return and give warning    if (len(idx) == 0):        print('\n*ERROR: No students found - check inputs and that studtype is correct (1=Physics, 2=M+P)\n')        sys.exit(0)                # add indices for the 2nd row of each student record    idx2 = []   # array of full indices    idx = idx.to_list()  # array of the first row index    for i in range(len(idx)):        idx2.append(idx[i])        idx2.append(idx[i]+1)        if (resitgrid):  # add 3rd row index if not on next student            idx2.append(idx[i]+2)            dfstudents = df.iloc[idx2]    # extract all the relevant rows    dfstudents.reindex()          # reindex to ensure it is contiguous for later        return dfstudents################################################################# get all student ids from a dataframedef get_sids(df):        sids = df.loc[:,'Emplid']        if (sids.size < 1):        print('No student IDs found...check file and column for SIDs (should be the 1st column called Emplid or UID or SID or similar)')        sys.exit(0)    sids = sids.to_list()  # make a list    sids = list(filter(None,sids))    # remove empty strings    # also remove any unicode non-breaking spaces (e.g. '\xa0') which can sometimes appear out of nowhere!    # not needed now - removed at the beginning in the allstudents dataframe    #sids = [x.strip() for x in sids]  # remove any spaces ('\xa0' -> '')    #sids_cleaned = [x for x in sids if x != '']  # remove any blank elements ('')                return sids################################################################def get_dfstudent(df,sid,resitgrid):        dfstudent=df.loc[df['Emplid'] == sid]  # select row with studentID= target    index=dfstudent.index.to_list()          # get index number of this row    dfstudent1 = df.loc[df.index == index[0]]    dfstudent2 = df.loc[df.index == index[0]+1]        dfstudent = pd.concat([dfstudent1, dfstudent2])    # if resit student get 3rd row    if (resitgrid == True):        dfstudent3 = df.loc[df.index == index[0]+2]        dfstudent = pd.concat([dfstudent, dfstudent3])  # add extra row to df            dfstudent.reindex()        return dfstudent################################################################# Make Info student record class filling with basic marks etc.# Ignores courses that are in ignore_coursesdef make_Info(df,anid,classyear,ignore_courses,AY, fill_marks=False):    columns = df.columns.to_list() # get columns        Info = StudentInfo(anid,classyear)            # Make Info record and add SID/classyear    Info.Plan = df["Plan"].values[0]    # Add Plan    Info.AY   = AY                      # Add academic year    if ('ID No.' in columns):        Info.IDnumber = df['ID No.'].values[0]  # ID number from input sheet (if exists)    else:        Info.IDnumber = ''   # otherwise just blank        # Determine if progressing or finalyear    if (classyear == 32 or classyear == 4):        Info.finalyear = True    else:        Info.finalyear = False        # Determine if M+P student    if ('math' in Info.Plan.lower()):        Info.mathstudent = True    else:        Info.mathstudent = False            # Determine if MPhys student    if ('mphys' in Info.Plan.lower() or 'Mp' in Info.Plan or 'MM' in Info.Plan):        Info.mphysstudent = True    else:        Info.mphysstudent = False    # determine if a PP (professional placement) student although this doesn't catch all - look for PHYS30810 later!!!    if ('PP' in Info.Plan):        Info.PPstudent = True        Info.PPpass    = -1  # no info at moment    else:        Info.PPstudent = False            # determine if resitting - which means there is a 3rd row    if (len(df) == 3):        Info.resitgrid = True    else:        Info.resitgrid = False    # Determine if an "abroad" student (usually in Y3) via programme name    # but also have to hard-code some below because we can't always tell (e.g. plan MPhys Physics can go abroad)    if (Info.mphysstudent == True and Info.mathstudent == False and 'study' in Info.Plan.lower()):        Info.abroad = True    if ('3A' in Info.Plan or '[A]' in Info.Plan or 'Eu' in Info.Plan): # Physics with Study in Europe        Info.abroad = True        Info.Euro   = True    # Make sure all abroad students are identidied from separate (hard-coded) list    # (because we can't always tell (e.g. plan MPhys Physics can go abroad)     if (Info.emplid in abroad_students):        Info.abroad = True            # add in simple information from input data    if ("Name" in columns):        Info.Name = df["Name"].values[0] # add Name if available    else: Info.anonymous = True  # anonymous file    # Admitted Term    if ("Admit Term" in columns):        Info.admitterm = df["Admit Term"].values[0]    elif ("Admit\nTerm" in columns):        Info.admitterm = df["Admit\nTerm"].values[0]            # Credits taken/passed    if ("Units\nTaken" in columns): Info.UnitsTaken = df["Units\nTaken"].values[0]    if ("Units\nPassed" in columns): Info.UnitsTaken = df["Units\nPassed"].values[0]    # AS (status) code    if ("AS Code" in columns): Info.AScode = df["AS Code"].values[0]    # Overall mark (Deg GPA)    if ("Deg.\nGPA" in columns):        Info.input_overallmark = df["Deg.\nGPA"].values[0]        if (Info.input_overallmark == ''):            Info.input_overallmark = -1        else:            Info.input_overallmark = float(Info.input_overallmark)            # Degree award and classification    if ('Award' in columns):        Info.input_award = df["Award"].values[0]    if ('Classification' in columns):        Info.input_classification = df["Classification"].values[0]    # If previous year marks exist in the file (from 2023) store them separately    # and into phys1, phys2 etc.    # also copy to math1, math2 to ensure maths overall average is correct    if ("Pr. Yr Mk\n/ GPA" in columns and Info.classyear == 2): # If Y2 resit grid it may only have this one        Info.dooverall = True        try:            Info.L1CM = float(df["Pr. Yr Mk\n/ GPA"].values[0])            Info.L1CM  = round(Info.L1CM+0.000001,1)  # round to 1 d.p. in case not already in the input!            Info.phys1 = Info.L1CM            Info.math1 = Info.phys1        except:            Info.L1CM = -1            Info.phys1 = -1            if ("L1CM" in columns):  # more generally         Info.dooverall = True  # for later on to ensure it is outputted at the end        try:            Info.L1CM = float(df["L1CM"].values[0])            Info.L1CM  = round(Info.L1CM+0.000001,1)  # round to 1 d.p. in case not already in the input!            Info.phys1 = Info.L1CM            Info.math1 = Info.phys1        except:            Info.L1CM = -1            Info.phys1 = -1    if ("L2CM" in columns):        try:            Info.L2CM = float(df["L2CM"].values[0])            Info.L2CM  = round(Info.L2CM+0.000001,1)  # round to 1 d.p. in case not already in the input!            Info.phys2 = Info.L2CM            Info.math2 = Info.phys2        except:            Info.L2CM = -1            Info.phys2 = -1    if ("L3CM" in columns):        try:            Info.L3CM = float(df["L3CM"].values[0])            Info.L3CM = round(Info.L3CM+0.000001,1)  # round to 1 d.p. in case not already in the input!            Info.phys3 = Info.L3CM            Info.year3mark = Info.phys3  # to ensure overall mark is calculated correctly        except:            Info.L3CM = -1            Info.phys3 = -1    if ("L4CM" in columns):        try:            Info.L4CM = float(df["L4CM"].values[0])            Info.L4CM = round(Info.L4CM+0.000001,1)  # round to 1 d.p. in case not already in the input!        except:            Info.L4CM = -1            # Reset the last phys1/2/3/4 if a repeating student    # Unfortunately, not reliable, because L1CM for the *current* year gets populated later (and is sometimes there anyway!)    #if (Info.classyear == 1 and Info.L1CM > -1):    #    Info.phys1 = -1    #    Info.repeating = True    #if (Info.classyear == 2 and Info.L2CM > -1):    #    Info.phys2 = -1    #    Info.repeating = True    #if ((Info.classyear == 31 or Info.classyear == 32) and Info.L3CM > -1):    #    Info.phys3 = -1    #    Info.year3mark = -1    #    Info.repeating = True    #if (Info.classyear == 4 and Info.L4CM > -1):    #    Info.phys4 = -1    #    Info.repeating = True                # Mit Circ/Sp if exists    mitcirc_name = [s for s in columns if ('Mit' in s or 'Sp' in s)] # get name of column if it exists    if (mitcirc_name): Info.mitcirc = df[mitcirc_name[0]].values[0]        # add all the Unit information including codes    columns = df.filter(regex='^Unit\ ',axis=1).columns.to_list()  # just unit columns    coursenames = []    coursenamesout = []    marks = []    marksout = []   # string for output marks (including potentially codes etc)    credits = []    codes = []        # loop over each Unit column    for col in columns:        data = df.loc[:,col].values  # get main data        coursename = data[0][0:9] # coursename is first 10 characters        if (len(coursename) < 5 or coursename in ignore_courses):  # move on if blank            continue        # credits        lbindex = data[0].find('(')        rbindex = data[0].find(')')        thiscredit = int(data[0][lbindex + 1:rbindex])                # Get codes for any courses        idx = df.columns.get_loc(col)  # get indices of column with potential codes        code = str(df.iloc[1,idx+1])                # add mark and get code string        mark_str = str(data[1])        #print(mark_str, code)        # for testing non-complete grids with missing marks, optionally add in marks for checking codes/decisions etc.        if (fill_marks == True and mark_str == ''):            mark_str = '50'                try:  # if just a number (usually is)            mark = round(float(mark_str)+0.000001) # mark as a (rounded) integer            markout = str(mark) # *keep as integer in the end (remove str()) when this is not used later                except: # if not just a number and code            if (mark_str == ''): # if empty                mark = -1                markout = ''                print('*WARNING: No mark for {0:s} ({1:s})'.format(coursename,mark_str))            elif (mark_str[0].isnumeric() == True):  # if XXC or XXR or XX_X get numerical mark                mark = round(float(''.join([c for c in mark_str if c.isdigit()])))  # get only numerical values                markcode = ''.join([c for c in mark_str if not c.isdigit()]) # get any code with the mark                markout = str(mark)  + markcode  # with markcode for reproduction                 #code = code # add mark code back to main code (but can change later)                if (markcode == 'R' and Info.resitgrid == False): Info.repeating = True  # if capped resit, repeating student            else: # no numerical mark but not empty!                markout = mark_str  # output the code (e.g. PRO) even though no mark                mark = -1                # warning only if is going to be non-0 credit weighted (and not PHYS30810 with 120 credits)                if ((thiscredit > 0 and thiscredit < 100) or coursename in generalpapers):                     print('*WARNING: No mark for {0:s} ({1:s})'.format(coursename,mark_str))                elif (thiscredit == 0):                    markout = 'AUD'   # likely a student has signed up but not taking the exam        # If no mark, mark as a blank (if want "PRO" etc. to be re-produced, comment out lines below)        #if (mark == -1):        #    markout = ''        # For 1-line input format (from 2024) add in Mit Circs codes for each module directly from input sheet        if (AY >= 2024):            mcc_codes = df.iloc[1,idx+2].split('/')            if (isinstance(mcc_codes,list) and mcc_codes[0] != ''): # if multiple codes add them back and separate with '_'                for i in range(len(mcc_codes)):                    if (code == ''):                        code += mcc_codes[i] + '_'                    else:                        if (i == 0): # add '_' if code already exists                            code += '_' + mcc_codes[i] + '_'                        else:                            code += mcc_codes[i] + '_'                code.replace('__', '_')  # remove extra '_' if exists                code  = code[:-1] # remove trailing '_'                code  = code.replace(' ', '') # remove any white space                                # Check again for PP students by looking for PHYS30810 and see whether on placement or not        if (coursename == 'PHYS30810'):            Info.PHYS30810 = True            Info.PPstudent = True            # get PHYS30810 pass/fail if available            if (mark_str.find('P') >=0):                Info.PPpass = True                markout = 'P'                Info.PPaway = False            elif (mark_str.find('F') >=0):                Info.PPpass = False                markout = 'F'                Info.PPaway = False                Info.PPstudent = False # PP fail means they will not now be on PP course anymore - treat like a normal student            else:                Info.PPpass = -1                Info.PPaway = True                    # Append the values to the individual lists if it is a real course        coursenamesout.append(data[0])  # Keep original coursename + credits for output        coursenames.append(coursename)          marks.append(mark)  # mark        marksout.append(markout) # marksout        credits.append(thiscredit)        codes.append(code)        # PP/away students: Check that there are no other marks, which should not be there if PP student is away    if (Info.PPstudent == True and Info.PPaway == True and len(marks) > 1):        print('WARNING: Looks like a PP student but there appears to be other marks for this year....please check!')            # Enforce position/ordering of some courses for clearer output later    if (classyear == 4):        try:            idx = coursenames.index('PHYS40181')  # If exists put in 1st columnn            if (idx and idx != 0):                coursenamesout.insert(0,coursenamesout[idx])                coursenames.insert(0,coursenames[idx])                marks.insert(0,marks[idx])                marksout.insert(0,marksout[idx])                credits.insert(0,credits[idx])                codes.insert(0,codes[idx])                del coursenamesout[idx+1]                del coursenames[idx+1]                del marks[idx+1]                del marksout[idx+1]                del credits[idx+1]                del codes[idx+1]        except:            pass        try:            idx = coursenames.index('PHYS40182')  # If exists put in 2nd columnn            if (idx and idx != 1):                coursenamesout.insert(1,coursenamesout[idx])                coursenames.insert(1,coursenames[idx])                marks.insert(1,marks[idx])                marksout.insert(1,marksout[idx])                credits.insert(1,credits[idx])                codes.insert(1,codes[idx])                del coursenamesout[idx+1]                del coursenames[idx+1]                del marks[idx+1]                del marksout[idx+1]                del credits[idx+1]                del codes[idx+1]        except:            pass            if (classyear == 32 or classyear == 31):        try:            idx = coursenames.index('PHYS30010')  # If exists put in 1st columnn            if (not idx): idx = coursenames.index('PHYS30210')  # If exists put in 1st columnn            if (idx and idx != 0):                coursenamesout.insert(0,coursenamesout[idx])                coursenames.insert(0,coursenames[idx])                marks.insert(0,marks[idx])                marksout.insert(0,marksout[idx])                credits.insert(0,credits[idx])                codes.insert(0,codes[idx])                del coursenamesout[idx+1]                del coursenames[idx+1]                del marks[idx+1]                del marksout[idx+1]                del credits[idx+1]                del codes[idx+1]        except:            pass        try:            idx = coursenames.index('PHYS30180')  # If exists put in 2nd columnn            if (not idx): idx = coursenames.index('PHYS30280')  # If exists put in 2nd columnn            if (idx and idx != 1):                coursenamesout.insert(1,coursenamesout[idx])                coursenames.insert(1,coursenames[idx])                marks.insert(1,marks[idx])                marksout.insert(1,marksout[idx])                credits.insert(1,credits[idx])                codes.insert(1,codes[idx])                del coursenamesout[idx+1]                del coursenames[idx+1]                del marks[idx+1]                del marksout[idx+1]                del credits[idx+1]                del codes[idx+1]        except:            pass        try:            idx = coursenames.index('PHYS30880')  # If exists put in 3rd columnn            if (idx and idx != 2):                coursenamesout.insert(2,coursenamesout[idx])                coursenames.insert(2,coursenames[idx])                marks.insert(2,marks[idx])                marksout.insert(2,marksout[idx])                credits.insert(2,credits[idx])                codes.insert(2,codes[idx])                del coursenamesout[idx+1]                del coursenames[idx+1]                del marks[idx+1]                del marksout[idx+1]                del credits[idx+1]                del codes[idx+1]        except:            pass    # add the lists back to the Info object    Info.coursenamesout = coursenamesout    Info.coursenames = coursenames    Info.marks       = marks    Info.marksout    = marksout    Info.credits     = credits    Info.codes       = codes        # Store indices of courses with no mark    Info.nomarks_idx = [i for i, j in enumerate(marks) if j < 0]    # Store indices of XN    XN_idx = [i for i, s in enumerate(Info.codes) if 'XN' in s]  # get idx of any XN codes    Info.XN_idx += XN_idx        # Set mcc=True if there are any MCC codes (i.e. not blank '')    if (any(Info.codes)): Info.mc = 'Y'        # If already compensated (for resit grid) then note it    if (Info.resitgrid == True):        idx = [x for x, s in enumerate(Info.codes) if (s.find('C') >=0 and s.find('MC') <0 and s.find('L1C') <0)]         for i in idx:            if i not in Info.compensated_idx:                Info.compensated_idx.append(i)                    return Info################################################################# add MCC data to Info from df_MCC aleady read-in, after removing existing codes# (though keep in XN for info on the 2-Line format output)def add_MCC_data(Info,df_MCC,keep_input_codes=False):        # First save these "EN codes" for CS output later (even if MCC not available just for completeness)    Info.orig_en_codes = Info.codes.copy()   # original only (for looking for dodgy records)    Info.en_codes      = Info.codes.copy()   # another copy that can be modified for the output        # keep record of XN for info though to put back later (after referalls etc.) into the output code, except if A8    Info.XN_idx = [i for i, s in enumerate(Info.codes) if 'XN' in s]  # get idx of any XN codes    # always first remove all the input codes already there, *unless* keep_input_codes=True    if (keep_input_codes == False):        Info.codes = ['']*len(Info.coursenames)     # New blank codes list            # Keep original codes in for CS output in case of changes (e.g. if fail)    Info.orig_codes = Info.codes.copy()   # New list for original codes since they must come from the MCC file    if (df_MCC is None):  # do nothing more if no MCC file        return Info        # get complete df for this particular student    columns = df_MCC.columns.to_list()    id_colname = [s for s in columns if 'id' in s.lower()][0]    df = df_MCC.loc[df_MCC[id_colname] == Info.emplid]   # get student if their is a match        # Check if empty - if so, stop and continue on (assume no additional codes exist)    if (df.empty):        Info.mc = ''        return Info    # get other column names/ids    idx_coursename = [i for i, s in enumerate(columns) if ('unit' in s.lower() or 'course' in s.lower())]    idx_code       = [i for i, s in enumerate(columns) if ('mcc' in s.lower() or 'mit' in s.lower() or 'deci' in s.lower() or 'en' in s.lower())]    if (len(idx_coursename) == 0):        print('*WARNING: Cannot find Unit/Coursename column in MCC file....please check...')    else:        idx_coursename = idx_coursename[0]  # in case there are two, take the first one    if (len(idx_code) == 0):        print('*WARNING: No \"Decision\"/\"EN\"/\"MCC\" column in MCC file: assuming it is the 5th column...please check...')        idx_code = 4 # Zero-indexed    else:        idx_code = idx_code[-1]   # if more than one, more likely to be the last column    # Otherwise carry and add the codes in for each unit in the MCC file    for i in range(len(df)):        data = df.iloc[i].to_list()                # put in code for this course - give warning if the course does not exist from the main input grid!        try: # in case of no match            idx = Info.coursenames.index(data[idx_coursename])  # get index of matching coursename            if ('/' in data[idx_code]):                codes = data[idx_code].split('/') # if multiple codes split with '/'            elif (',' in data[idx_code]):                codes = data[idx_code].split(',') # if multiple codes split with ','            else:                codes = data[idx_code]                Info.codes[idx] = codes  # just a single code                            if (isinstance(codes,list)): # if multiple codes add them back and separate with '_'                for i in range(len(codes)):                    Info.codes[idx] += codes[i] + '_'                Info.codes[idx] = Info.codes[idx][:-1] # remove trailing '_'                Info.codes[idx] = Info.codes[idx].replace(' ', '') # remove any white space                            # Ensure that this is in the resit list in case there is no mark            if (idx not in Info.resit_idx):                Info.resit_idx.append(idx)                Info.nomarks_idx.append(idx)                        except: # if no match, give a warning to the screen            print('WARNING: MCC code exists but cannot find match to the list of courses for this student!')                # Save original codes    Info.orig_codes  = Info.codes  # just in case we need them later when blanking everything (cleanup_nomarks)    # Add any additional XN codes to Info.XN_idx since they may come from the MCC file    XN_idx = [i for i, s in enumerate(Info.codes) if 'XN' in s]  # get idx of any XN codes    Info.XN_idx += XN_idx        # Set mcc=True if there are any MCC codes (i.e. not blank '')    if (any(Info.codes)): Info.mc = 'Y'                return Info################################################################# cap resit marks if R2 in input grid - also remove R2->"cap" to save confusion later with referrals# Note that this is strictly only correct if original mark <30 (ok for AY=2024, we think)def cap_resit_marks(Info):    # don't do anything if a resit grid (dealt with elsewhere in apply_capped_resit_marks())    if (Info.resitgrid == True):         return Info    # cap any second attempt marks at 30 if above 30    for idx in Info.secondattempt_idx:        if (Info.marks[idx] > 29.95):            Info.marksout[idx] = Info.marks[idx]  # output actual mark            Info.marks[idx] = 30   # cap mark at 30 if above                                # remove R2 from codes to save confusion later            Info.codes[idx] = 'cap'            Info.codes2[idx] = 'cap'            # add back 'C' if compensated            if (idx in Info.compensated_idx):                Info.codes[idx] += '_C'                Info.codes2[idx] += '_C'                    return Info################################################################# add Y3 creds below 40 data (for Y4 only) if file existsdef add_Y3creds_below40_data(Info,df):        if (df is None):  # do nothing more if no MCC file        Info.Y3creds_below40 = 0        return Info        # get ID column    columns = df.columns.to_list()    id_colname = [s for s in columns if 'id' in s.lower()][0]    id_Y3creds = [s for s in columns if ('y3' in s.lower() and 'credits' in s.lower() and 'below 40' in s.lower())][0]        # get rows of matching student (there may be several)    rows = df[id_colname] == Info.emplid    data = df[rows].values    # if no match, continue    if (len(data) == 0):        Info.Y3creds_below40 = 0 # default (should be 0 anyway)        return Info        # get the number of credits below 40 for this student    for i in range(len(data)):        Y3creds_below40 = data[i,1] # get value in 2nd column        if (Y3creds_below40 == ''): # check other rows if no value            Y3creds_below40 = 0            continue        else:       # otherwise take value and get out of the for loop            Y3creds_below40 = int(data[i,1])  # convert to integer            break      # Assign value to Info    Info.Y3creds_below40 = Y3creds_below40                     return Info################################################################# add boundary notes from df_boundary_notes aleady read-indef add_boundary_notes_data(Info,df_boundary_notes):    if (df_boundary_notes is None):  # do nothing if no boundary_notes file        return Info    # get column names and first columns    columns = df_boundary_notes.columns.to_list()    id_colname = columns[0]    notes_colname = columns[1]    df = df_boundary_notes.loc[df_boundary_notes[id_colname] == Info.emplid]   # get student if their is a match        # Check if empty - if so, stop and continue on     if (df.empty):        return Info    # Otherwise add notes to Info    Info.boundary_notes += str(df["Boundary Notes"].to_list()[0])    return Info################################################################# add boundary notes from df_boundary_notes aleady read-indef add_flagCF_notes_data(Info,df_flagCF):    if (df_flagCF is None):  # do nothing if no boundary_notes file        return Info    # get column names and first columns    columns = df_flagCF.columns.to_list()    id_colname = columns[0]    notes_colname = columns[1]    df = df_flagCF.loc[df_flagCF[id_colname] == Info.emplid]   # get student if their is a match        # Check if empty - if so, stop and continue on     if (df.empty):        return Info    # Otherwise add notes to Info (also used for boundary notes, which is similar)    Info.flagCF_notes += str(df["Flag Carry Forward"].to_list()[0])    return Info################################################################# Determine which units are 2nd attempts i.e. proper resits that can't be taken again# for now, this is only for resit grids with a secondpass as we rarely have codes (usually repeating students)def get_secondattempts(Info):    # put previous attempts in an array when doing second pass (For resit grids)    if (Info.secondpass == True):        Info.p_secondattempt_idx = Info.secondattempt_idx.copy()        Info.secondattempt_idx = []                # loop over each unit and find where it is a 2nd attempt based on previous codes unless current code excuses it (e.g. X, X1, XL)        for idx in range(len(Info.codes)):            if (Info.codes[idx].find('X') >=0 and Info.codes[idx].find('XN') < 0):                pass            elif ((Info.p_codes[idx].find('R') >=0 and Info.p_codes[idx].find('R1') < 0 and Info.p_codes[idx].find('SR') < 0) or Info.p_codes[idx].find('A2') >=0):                Info.secondattempt_idx.append(idx)                    # if not a resit grid, then see if there is a code with the main mark    elif (Info.resitgrid == False):        for idx in range(len(Info.codes)):            if ( (Info.codes[idx].find('R') >=0 and Info.codes[idx].find('R1') < 0 and Info.codes[idx].find('SR') < 0) or Info.codes[idx].find('A2') >=0):                    Info.secondattempt_idx.append(idx)                    return Info################################################################# Get CarryForward data from xls file (if doCF == True)def get_CF_data(doCF, CFfilename):    # do nothing if doCF == False or no CFfilename or if resit grid    if (doCF == False or CFfilename == ''):        return None    # Read in data    try:        skipnrows = find_skipnrows(CFfilename)  # get number of rows to skip        if (CFfilename.split('.')[-1] == 'csv'):            df_CF = pd.read_csv(CFfilename, skiprows=skipnrows, dtype='str', engine='python')        else:            df_CF = pd.read_excel(CFfilename, skiprows=skipnrows, dtype='str')    except:        print('\nERROR reading Carry Forward file: {0:s}\nPlease check filename and/or directory...\n'.format(CFfilename))        sys.exit(0)    df_CF = df_CF.replace(np.nan, '', regex=True)  # Remove NaNs    df_CF = df_CF.replace('\xa0', '', regex=True)  # Remove any unicode non-breakable space ('\ax0')        return df_CF################################################################# add CF data to Info from df_CF already read-indef add_CF_data(Info,df_CF, doCF):    if (doCF == False):  # do nothing if no CF file        return Info        selected = df_CF.loc[df_CF['Emplid'] == Info.emplid]   # get student data from 1st column        # Check if empty - if so, stop and give warning - usually, CF file not correct or not used (doCF should be 0)    # Put in -1 marks so that code will continue    if (selected.empty):        print('*WARNING: Cannot find student {0:s} in CF file (but file read in ok)... '.format(anid))        #print('***If no relevant CF file, set doCF = False or set CFfilename = '' to ignore carry forwards')        Info.dooverall = False        Info.phys1 = -1        Info.phys2 = -1        Info.phys3 = -1        Info.math1 = -1        Info.math2 = -1        Info.math3 = -1        Info.year3mark = -1        return Info    else:        Info.dooverall = True        # get index number of this row and extract the numbers    selectedindex = selected.index    data=df_CF.iloc[selectedindex].values    data=data.flatten()    ndata = np.size(data)        if (ndata < 9):        print('*WARNING: < 9 columns in CF file')        print('***If no relevant CF file, set doCF = False or set CFfilename = '' to ignore carry forwards')            outnames = ['phys1','phys2','phys3','math1','math2','math3']            # loop over each column to get Phys/Math marks from columns 4-9    cols = [3,4,5,6,7,8]  # 6 columns expected after the first 3    for i in cols:        outname = outnames[i-cols[0]]        try:    setattr(Info,outname, float(data[i]))  # set the number if can be converted to float        except: setattr(Info,outname,-1)               # if string or empty set to -1        # get Year 3 mark for 4th year M+P students from column 10 (if it exists)    if (Info.classyear == 4 and Info.mathstudent == True):        if (ndata < 10):            print('Year3mark does not seem to appear in the CF file (no column 10?)! Doing straight average of M+P in 3rd year for now which is incorrect!')            Info.year3mark = (Info.phys3+Info.math3)/2 # incorrect - not a straight average (in case no year3 mark available)        else:            try: Info.year3mark = float(data[9])            except:                Info.year3mark = (Info.phys3+Info.math3)/2 # incorrect - not a straight average (in case no year3 mark available)                print('Using straight Phys/Math average because year3mark is not available in CF file which is not correct!')                                return Info################################################################# get credit weights from coursename or credweights dictionary if 0# will run through all courses# unless idx set to list of indices to re-do (e.g. if compensated later need to put credweights back for these only)def get_credweights(Info,credweightunits,useidx=False):    credits = Info.credits.copy()  # get credits    marks   = Info.marks.copy()    # marks in case missing (which is -1)        # loop over those that are zero using supplied useidx or all zeroes if not    if (useidx):        idx = list([useidx])        credweights = Info.credweights.copy()   # take existing credweights    else:        credweights = credits.copy()  # does not exist yet so take credits as default        idx = [i for i, j in enumerate(credits) if j == 0]    # loop over relevant idx    for i in idx:        coursename = Info.coursenames[i]        if (useidx):            credweights[i] = credits[i]   # if possible compensation put it back to original credits                        if (credits[i] == 0):              try:                credweights[i] = credweightunits[coursename]  # set to correct weight otherwise remains as 0            except:                pass  # no need to give a warning now                Info.credweights = credweights  # Add back to Info                    return Info################################################################# get core/non-core courses for physics and mathdef get_core_courses(Info,isphyscore, ismathcoure):    coursenames     = Info.coursenames.copy()        # Physics core courses    physcore_idx = [i for i in range(len(coursenames)) if coursenames[i] in isphyscore]  # get indices where core courses         # Math core courses (N.B. Y1 all math courses are core only for AY<=2022)    if (Info.mathstudent == True):        mathcore_idx = [i for i in range(len(coursenames)) if coursenames[i] in ismathcore]  # get indices where specific core courses     # Add back to Info    Info.physcore_idx = physcore_idx    if (Info.mathstudent == True):        Info.mathcore_idx    = mathcore_idx   # extra variable only relevant for Math/Phys students        Info.core_idx        = physcore_idx + mathcore_idx  # all core course indices (M+P students)    else:         Info.core_idx    = physcore_idx   # Physics students (no MATHs core)            return Info################################################################# apply manual exclusions to courses (for rare cases) - using manual_exclusions dictionarydef apply_manual_exclusions(Info, manual_exclusions):    # look for ID in manual_exclusions and exclude courses    if (Info.emplid in manual_exclusions.keys()):        coursenames = manual_exclusions[Info.emplid].split(',') # split coursenames if more than 1        # loop over each course        for coursename in coursenames:            try:                idx = Info.coursenames.index(coursename)                Info.codes[idx] = 'X'       # add 'X' to exclude this course            except: # if cannot be found, must be a typo in the manual_exclusions list                '*ERROR: course ({0:s}) not found to manually exlcude - check manual_exclusions list...\n'                return Info################################################################# determine exluded courses from year mark including which ones to be deferred or with no markdef exclude_courses(Info):        # find where codes exist    codes = Info.codes    idx = [i for i in range(len(codes)) if codes[i] != '']  # get indices where codes exist    # Blank variables unless already set and set credweights to 0 if no mark and previously excluded    excluded_idx = []    excludedcoursenames = []    deferred_idx = []    deferredcoursenames = ''    deferredcredits = 0    creditsexcluded = 0    # If resit grid (2nd pass), and no new mark, but was excluded last time, then exclude this time again    if (Info.secondpass == True and len(Info.excluded_idx) > 0):        for i in Info.excluded_idx:            if (i not in Info.resit_idx):  # only if no new mark                excluded_idx.append(i)                excludedcoursenames.append(Info.coursenames[i])                creditsexcluded += Info.credits[i]                Info.credweights[i] = 0                # For PP students (Professional Placement) last year that have PHYS30810 (120) and current Y3 marks - ignore PHYS30810 (120)    # If on its own with no marks, should be at the bottom of the grid (which will happen anyway if this is ignored so try that)    # (Judith Teams chat 22-Jun-2023)    if (Info.PPstudent == True and Info.PHYS30810 == True):        excluded_idx.append(Info.coursenames.index('PHYS30810'))    # loop over each code and excluded if required    # But first exclude courses with no marks from year average where there should be e.g. if A5 it should be treated as per normal    if (len(Info.nomarks_idx) > 0):        for i in Info.nomarks_idx:            if ('XN' not in Info.codes[i] and 'A5' not in Info.codes[i]):                 excluded_idx.append(i)                excludedcoursenames.append(Info.coursenames[i])                creditsexcluded += Info.credits[i]                Info.credweights[i] = 0   # do not include in year average    # if not Y1/Y2, there should be no SR1/MA3/MA4/MA8 codes - print warning to screen if so    if (Info.classyear > 2 and ('SR' in codes or 'MA' in codes)):        print('*WARNING: SR/MA codes exist here when they should not! (Y3/Y4)')    # loop over each code    for i in idx:        # if resit grid (only) and A3/A4/A5 take current status of resits (if deferral - referrals done in get_referred_units())        if (Info.resitgrid == True and (codes[i].find('A3') >=0 or codes[i].find('A4') >=0 or codes[i].find('A5') >=0)):                                # If deferral last time, then stay with deferral (R1) unless an X            if (Info.codes[i].find('R1') >= 0 or (Info.codes[i].find('X') >=0 and Info.codes[i].find('XN') < 0)):                excluded_idx.append(i)                excludedcoursenames.append(Info.coursenames[i])                creditsexcluded += Info.credits[i]                Info.credweights[i] = 0                                # if first pass, codes are not valid anyway so only include the R1                if (Info.secondpass == False and Info.codes[i].find('X') < 0):                    Info.codes[i] = 'R1'                # Defer if Y1/Y2 and if resittable (credits>0)                if (Info.codes[i].find('R1') >=0 and (Info.classyear == 1 or Info.classyear == 2) and Info.credits[i] > 0):                    deferred_idx.append(i)                    deferredcredits += Info.credits[i]                    if (codes[i].find('A4') >=0 and Info.marks[i] > 39.95): # optional deferral if passed                        deferredcoursenames += Info.coursenames[i] + '[1opt] / '                    else:                        deferredcoursenames += Info.coursenames[i] + '[1] / '  # deferral if failed            # if second pass (resit grid) with A3/A4/A5 and previously deferred then assume still deferred            if (Info.secondpass == True and i in Info.p_deferred_idx and i not in deferred_idx):                excluded_idx.append(i)                excludedcoursenames.append(Info.coursenames[i])                creditsexcluded += Info.credits[i]                Info.credweights[i] = 0                deferred_idx.append(i)                deferredcredits += Info.credits[i]                if (codes[i].find('A4') >=0 and Info.marks[i] > 39.95): # optional deferral if passed                    deferredcoursenames += Info.coursenames[i] + '[1opt] / '                else:                    deferredcoursenames += Info.coursenames[i] + '[1] / '  # deferral if failed                                # MA4/A4/A5: Y1/Y2 only, resit as first attempt (deferral) -> R1 (A4) or R2 (A5) (done in get_referred)        elif (codes[i].find('A4') >=0):            excluded_idx.append(i)            excludedcoursenames.append(Info.coursenames[i])            creditsexcluded += Info.credits[i]            Info.credweights[i] = 0            #Info.codes[i] = 'A4'            # Defer if Y1/Y2 and if resittable (credits>0)            if ((Info.classyear == 1 or Info.classyear == 2) and Info.credits[i] > 0):                deferred_idx.append(i)                if (codes[i].find('A4') >=0 and Info.marks[i] > 39.95): # optional deferral if passed                    deferredcoursenames += Info.coursenames[i] + '[1opt] / '                else:                    deferredcoursenames += Info.coursenames[i] + '[1] / '  # deferral if failed                deferredcredits += Info.credits[i]        # A5: Y1/Y2 only, resit as first attempt (deferral) -> R2 (A5) but only if failed        elif (codes[i].find('A5') >=0 and Info.marks[i] < 39.95):            excluded_idx.append(i)            excludedcoursenames.append(Info.coursenames[i])            creditsexcluded += Info.credits[i]            Info.credweights[i] = 0            Info.codes[i] = 'A5'            # Change to referral if resittable (credits>0)            if ((Info.classyear == 1 or Info.classyear == 2) and Info.credits[i] > 0):                Info.referred_idx.append(i)                Info.referredcoursenames += Info.coursenames[i] + ' / '        # R1/A1 means exclude and treat as a resit at first attempt next time         elif (((codes[i].find('R1') >= 0 and codes[i].find('SR1') < 0) or (codes[i].find('A1') >=0 and codes[i].find('A10') <0) or (codes[i].find('C1') >=0)) and i not in Info.secondattempt_idx and i not in Info.compensated_idx): # and not already excluded            excluded_idx.append(i)            excludedcoursenames.append(Info.coursenames[i])            creditsexcluded += Info.credits[i]            Info.credweights[i] = 0                        # Defer if Y1/Y2 and if resittable (credits>0)            if ((Info.classyear == 1 or Info.classyear == 2) and Info.credits[i] > 0):                deferred_idx.append(i)                if (Info.marks[i] > 39.95): # optional deferral if passed                    deferredcoursenames += Info.coursenames[i] + '[1opt] / '                else:                    deferredcoursenames += Info.coursenames[i] + '[1] / '  # deferral if failed                deferredcredits += Info.credits[i]                        # MA3/A3: Y1/Y2 only, exclude from average -> X (if no A4/A5 code, since it may be passed)        elif (codes[i].find('A3') >=0 and codes[i].find('A5') < 0):               excluded_idx.append(i)            excludedcoursenames.append(Info.coursenames[i])            creditsexcluded += Info.credits[i]            Info.credweights[i] = 0            #codes[i] = 'A3'            #codes[i] = 'X'  # do this later                    # MA8/A8: Y3/Y4 only, exclude from average -> X        elif (codes[i].find('A8') >=0):            excluded_idx.append(i)            excludedcoursenames.append(Info.coursenames[i])            creditsexcluded += Info.credits[i]            Info.credweights[i] = 0            #codes[i] = 'A8'            #codes[i] = 'X' # do this later                    # X = exclude from year mark        elif (codes[i] == 'X' or codes[i] == '_X' or codes[i].find('X_C') >=0): # includes 'X_C' for 2nd pass (resits)            excluded_idx.append(i)            excludedcoursenames.append(Info.coursenames[i])            creditsexcluded += Info.credits[i]            Info.credweights[i] = 0        # XL = Absent from exam with reason: excludes from the calculation of the year mark and flags as a resit at 1st attempt (deferred)        elif (codes[i].find('XL') >= 0):            excluded_idx.append(i)            excludedcoursenames.append(Info.coursenames[i])            creditsexcluded += Info.credits[i]            Info.credweights[i] = 0            # Defer if Y1/Y2 and if resittable (credits>0)            if ((Info.classyear == 1 or Info.classyear == 2) and Info.credits[i] > 0):                if (i not in Info.secondattempt_idx):   # if not already a 2nd attempt                    Info.codes[i] = Info.codes[i] + '_R1'                    deferred_idx.append(i)                    deferredcoursenames += Info.coursenames[i] + '[1] / '                    deferredcredits += Info.credits[i]                else:                    Info.referred_idx.append(i)                    Info.referredcoursenames += Info.coursenames[i] + ' / '                            # X1 = Deferall in Y1/Y2 (same as XL)         elif (codes[i].find('X1') >= 0):            excluded_idx.append(i)            excludedcoursenames.append(Info.coursenames[i])            creditsexcluded += Info.credits[i]            Info.credweights[i] = 0            # Defer if Y1/Y2 and if resittable (credits>0)            if ((Info.classyear == 1 or Info.classyear == 2) and Info.credits[i] > 0):                if (i not in Info.secondattempt_idx):  # if not already a 2nd attempt                    Info.codes[i] = Info.codes[i] + '_R1'                    deferred_idx.append(i)                    deferredcoursenames += Info.coursenames[i] + '[1] / '                    deferredcredits += Info.credits[i]                else:                    Info.referred_idx.append(i)                    Info.referredcoursenames += Info.coursenames[i] + ' / '                            # XN = Missed with no reason - do NOT exclude!        elif (codes[i].find('XN') >= 0):            pass        # L1C/L2C for previous year - means extra credit courses/mark from previous year and these should not form part of the average - exclude        # (Judith email 09-Sep-2023 and 14-Jun-2024)        elif (codes[i].find('L1C') >= 0 and Info.classyear == 2):            excluded_idx.append(i)            excludedcoursenames.append(Info.coursenames[i])            creditsexcluded += Info.credits[i]            Info.credweights[i] = 0        elif (codes[i].find('L2C') >= 0 and (Info.classyear == 31 or Info.classyear == 32)):            excluded_idx.append(i)            excludedcoursenames.append(Info.coursenames[i])            creditsexcluded += Info.credits[i]            Info.credweights[i] = 0        elif (codes[i].find('L3C') >= 0 and (Info.classyear == 4)):            excluded_idx.append(i)            excludedcoursenames.append(Info.coursenames[i])            creditsexcluded += Info.credits[i]            Info.credweights[i] = 0                # If no mark previously and no mark on resits then exlcude them (marking boycott!) and make a note!    if (Info.secondpass == True):        for i in Info.p_nomarks_idx:            if (i in Info.nomarks_idx):                excluded_idx.append(i)                excludedcoursenames.append(Info.coursenames[i])                creditsexcluded += Info.credits[i]                Info.credweights[i] = 0                print('Excluding {0:s} because no marks both times!'.format(Info.coursenames[i]))                    # Add extras back to Info    Info.excluded_idx        = excluded_idx    Info.excludedcoursenames = excludedcoursenames    Info.creditsexcluded     = creditsexcluded    Info.deferred_idx        = deferred_idx    Info.deferredcoursenames = deferredcoursenames    Info.deferredcredits     = deferredcredits        return Info################################################################# Function to make codes2 which is alternative output codes for 2-line outputdef make_codes2(Info):    # Make codes2 which is alternative format for 2-Line output    # e.g. has old familiar 'X' codes.    Info.codes2 = Info.codes.copy()    idx = [i for i, j in enumerate(Info.codes) if Info.codes[i] != '']    for i in idx:        if (Info.codes[i].find('A1')>=0 and i in Info.excluded_idx and i in Info.deferred_idx):            Info.codes2[i] = ''  # just add _R1 below        elif (Info.codes[i].find('A4')>=0 and i in Info.excluded_idx and i in Info.deferred_idx):            Info.codes2[i] = ''  # just add _R1 below        elif (Info.codes[i].find('A3')>=0 and i in Info.excluded_idx and i not in Info.deferred_idx):            Info.codes2[i] = 'X'  # 'A3' -> X for 2-Line output only        elif (Info.codes[i].find('A8')>=0 and i in Info.excluded_idx and i not in Info.deferred_idx):            Info.codes2[i] = 'X'  # 'A8' -> X for 2-Line output only (unless with XN -> XL_R1 below)        # Override the above few lines if deferred/referred (e.g. A4/A5 -> R1/R2)        if (i in Info.deferred_idx): # overrides A3 above            if (Info.codes2[i].find('R1') < 0): Info.codes2[i] = 'R1_' + Info.codes2[i]  # for 2-Line output only            #if (Info.en_codes[i].find('R1') < 0): Info.en_codes[i] += '_R1'  # Add R1 to EN codes for CS 1-line sheet        elif (i in Info.referred_idx):             Info.codes2[i] = 'R2'  # for 2-Line output only            #Info.en_codes[i] += '_R2'  # Add R2 to EN codes for CS 1-line sheet        elif (Info.marks[i] >=39.95 and i not in Info.excluded_idx): # if not excluded (e.g. A3)            pass            #Info.codes2[i] = ''  # accept the mark as is but copy over any codes            #Also keep 'XN' for info on 2-Line output (unless A3/4/8 which should have XN removed)    for i in Info.XN_idx:        if (Info.codes[i].find('A4') >=0 or Info.codes[i].find('A8') >=0 or Info.codes[i].find('A3') >=0):            #Info.en_codes[i] = Info.en_codes[i].replace('XN_', '')           #Info.en_codes[i] = Info.en_codes[i].replace('XN', '')           #Info.codes2[i]   = Info.codes2[i].replace('XN_', 'XL_')  #            #Info.codes2[i]   = Info.codes2[i].replace('XN', 'XL_')           if (i not in Info.deferred_idx and i not in Info.referred_idx):               Info.codes2[i] = 'XL_'           else:               Info.codes2[i] = 'XL_' + Info.codes2[i]        elif (Info.codes[i].find('XN') >= 0):            Info.codes2[i] = Info.codes[i]        else:  # but if another code, append it to XN            Info.codes2[i] = 'XN_' + Info.codes[i]    # remove any '__' that happen to be there or trailing '_'    idx = [i for i, j in enumerate(Info.codes2) if Info.codes2[i] != '']    for i in idx:        Info.codes2[i] = Info.codes2[i].replace('__', '_')        if (Info.codes2[i][-1] == '_'):            Info.codes2[i] = Info.codes2[i][0:-1]        # take XN out of XN list if A3/A4/A8 to save issues later    Info.XN_idx = [i for i in Info.XN_idx if (Info.codes[i].find('A3') <0 and Info.codes[i].find('A4') <0 and Info.codes[i].find('A8') <0)]    return Info################################################################# Function to determine MATH units and marks/credits and also math credits takendef get_math_units(Info):    math_units = []    coursenames = Info.coursenames    idx = [i for i in range(len(coursenames)) if 'MATH' in coursenames[i]]  # get indices if MATH unit    idx2 = [i for i in range(len(coursenames)) if 'MATH' not in coursenames[i]]  # get indices if not MATH unit    # Physics/math credits taken    mathcreditstaken = np.sum(np.array(Info.credits)[idx])    physcreditstaken = np.sum(np.array(Info.credits)[idx2])    # Remove credits for PHYS30810 for PP students! (in all cases - either away or mark from previous year)    if (Info.PHYS30810 == True): # don't look for PPstudent because if they fail PHYS30810 no longer a PP student!        idx = Info.coursenames.index('PHYS30810')        physcreditstaken -= Info.credits[idx]            # Add back to Info    Info.math_units_idx = idx    Info.phys_units_idx = idx2    Info.mathcreditstaken = mathcreditstaken    Info.physcreditstaken = physcreditstaken    Info.creditstaken = mathcreditstaken + physcreditstaken        return Info################################################################# Determine the overall project mark for S1/S2 or both# taking into account special cases for non-standard projects (Phys/Phil and M+P)def get_projectmark(Info):    # If not Y3/Y4 then skip this function    if (Info.classyear == 1 or Info.classyear == 2):        return Info        # taking into account special cases for non-standard projects (Phys/Phil and M+P)    # or with only 1 project    coursenames = Info.coursenames    project1mark = -1    # -1 means no mark       project2mark = -1    # -1 means no mark        # BSc dissertation for 3rd years    if ('PHYS30880' in coursenames):        idx = coursenames.index('PHYS30880')        project1mark = Info.marks[idx]        project1cred = Info.credits[idx]            if ('PHYS40181' in coursenames and 'PHYS40182' in coursenames):        idx = coursenames.index('PHYS40181')        project1mark = Info.marks[idx]      # S1        project1cred = Info.credits[idx]        idx = coursenames.index('PHYS40182')        project2mark = Info.marks[idx]      # S2        project2cred = Info.credits[idx]            elif ('PHYS40181' in coursenames and 'PHYS40182' not in coursenames):        idx = coursenames.index('PHYS40181')        project1mark = Info.marks[idx]      # S1        project1cred = Info.credits[idx]    elif ('PHYS40181' not in coursenames and 'PHYS40182' in coursenames):        idx = coursenames.index('PHYS40182')        project2mark = Info.marks[idx]      # S2        project2cred = Info.credits[idx]                    # for Phys/Phil who do an essay for one project - only worth 10 credits c.f. 20 credits for physics    if ('PHIL40000' in coursenames and project1mark==-1):        idx = coursenames.index('PHIL40000')        project1mark = Info.marks[idx]        project1cred = Info.credits[idx]    elif ('PHIL40000' in coursenames and project2mark==-1):        idx = coursenames.index('PHIL40000')        project2mark = Info.marks[idx]        project2cred = Info.credits[idx]            # for Math/Phys Math projects only 15 credits c.f. 20 credits for physics    if ('MATH40011' in coursenames and project1mark==-1):        idx = coursenames.index('MATH40011')        project1mark = Info.marks[idx]        project1cred = Info.credits[idx]    if ('MATH40022' in coursenames and project2mark==-1):        idx = coursenames.index('MATH40022')        project2mark = Info.marks[idx]        project2cred = Info.credits[idx]            # combine S1/S2 project marks    if (project1mark >=0 and project2mark >=0):        projectmark = ((project1mark*project1cred)+(project2mark*project2cred))/float(project1cred+project2cred)        projectcred = project1cred+project2cred    elif (project1mark >=0 and project2mark == -1):        projectmark = project1mark        projectcred = project1cred    elif (project2mark >=0 and project1mark == -1):        projectmark = project2mark        projectcred = project2cred    elif (project1mark == -1 and project2mark == -1):        projectmark = 0        projectcred = 0            # Add to Info    Info.projectmark = round(projectmark+0.000001)    Info.projectcred = projectcred    return Info################################################################# Find which units are passed/faileddef get_passed_failed(Info,mustpass,noresitlist):    Info.faillabprog = False # default is False in case allowed to resit 2nd time (e.g. 'A2')    marks = Info.marks.copy()  # get numerical marks    Info.someunitunder30 = False # default (and to reset on 2nd pass for resits)        # get passed marks/credits    passed_idx = [i for i in range(len(marks)) if marks[i] >= 39.95]  # passed marks                if (len(passed_idx) > 0):        creditspassed = np.sum(np.array(Info.credits)[passed_idx])  # Sum of passed credits    else:        creditspassed = 0    # also get Y3 unit credits passed (needed for BSc criteria) for Y3 students (also do for Y4)    if (Info.classyear == 31 or Info.classyear == 32 or Info.classyear == 4):        passed3_idx = [i for i in range(len(marks)) if (marks[i] >= 39.95 and Info.coursenames[i][4] == '3')]        # Level 4 also include level 6 courses (for Philosophy)        passed4_idx = [i for i in range(len(marks)) if (marks[i] >= 39.95 and (Info.coursenames[i][4] == '4' or Info.coursenames[i][4] == '6'))]         if (len(passed3_idx) > 0):            credits3passed = np.sum(np.array(Info.credits)[passed3_idx]) # Sum of passed Y3 courses        else:            credits3passed = 0        if (len(passed4_idx) > 0):            credits4passed = np.sum(np.array(Info.credits)[passed4_idx]) # Sum of passed Y4 courses        else:            credits4passed = 0                    Info.passed3_idx = passed3_idx        Info.credits3passed = int(credits3passed)        Info.passed4_idx = passed4_idx        Info.credits4passed = int(credits4passed)        Info.credits34passed = Info.credits3passed + Info.credits4passed            # get nominally failed marks/credits    failed_idx = [i for i in range(len(marks)) if (marks[i] < 39.95 and marks[i] >= 0 and i not in Info.excluded_idx)]  # failed marks        # Get sum of "failed" credits    if (len(failed_idx) > 0):        creditsfailed = np.sum(np.array(Info.credits)[failed_idx])  # Sum of "failed" credits    else:        creditsfailed = 0    # Store locations of units in 30-39 range for possible compensation     units30_39_idx = [i for i in range(len(marks)) if (marks[i] >= 29.95 and marks[i] < 39.95)]        # loop through nominally failed courses and determine outcome at end    for i in failed_idx:        # has this course been failed when it must be passed i.e. lab,  project?         if (Info.coursenames[i] in mustpass):            if ('R2' not in Info.codes[i] and 'A2' not in Info.codes[i]): # (but not if A2/R2 code for resits)                Info.faillabprog = True  # add failreason later on in get_status            # If lab mark is 39, then allow resit and REVW rather than fail (Judith email 28-Jun-2024)            if (Info.faillabprog == True and Info.marks[i] > 38.45):                Info.faillabprog = False                Info.lab_resit = True                        #if any course is < 30%, resits triggered for 1st/2nd year (also trigger resits later)        if(marks[i]<29.95 and Info.coursenames[i] not in noresitlist and Info.credits[i] > 0 and i not in Info.excluded_idx):            if (Info.secondpass == True and Info.p_marks[i] >=29.95): # If 2nd pass, consider original mark first to prevent unncessary referrals                pass            else:  # otherwise really have a unit under 30%                Info.someunitunder30 = True                #if (Info.secondpass == True): print(i, Info.coursenames[i], Info.p_marks[i], Info.marks[i])    # ***Also assume unit is failed if no mark and not exlcuded    for idx in Info.nomarks_idx:        if (idx not in failed_idx and idx not in Info.excluded_idx):            failed_idx.append(idx)        # Add back to Info    Info.passed_idx = passed_idx    Info.creditspassed = int(creditspassed)    Info.failed_idx = failed_idx       Info.creditsfailed = int(creditsfailed)    Info.units30_39_idx = units30_39_idx    return Info################################################################# Determine which units are to be referred (resit) or can be compensated# ***RE-WRITTEN (old below) - possible that some resit/second attempt criteria may still not be in here! (most of it done now)def get_referred_units(Info):        # If not Y1/Y2 then skip this function (no resits in Y3/Y4)    if (Info.classyear != 1 and Info.classyear != 2):        return Info    # if level 3 or higher course, not resits, so add to mustpass    for coursename in Info.coursenames:        courselevel = int(coursename[4])        if (courselevel >=3 and coursename not in mustpass):            mustpass.append(coursename)                # blank variables in case this is being ran twice (for resit grids) but keep record of resits at 2nd attempt to keep for later    if (Info.secondpass == True):        Info.keep_referred_idx = [idx for idx in Info.referred_idx if idx in Info.secondattempt_idx]        Info.referred_idx = []  # blank them        Info.referredcoursenames = '' # blank them        #Info.compensated_idx = []  # do not blank here!         # If A5 code on input then they should not be considered 2nd attempt this time since they can resit        idx = [i for i, s in enumerate(Info.codes) if ('A4' in s or 'A5' in s)]        for idx in idx:            if (idx in Info.secondattempt_idx):                Info.secondattempt_idx.remove(idx)                Info.codes2[idx] = Info.codes2[idx].replace('A5', '')  # remove A5 code since it will be changed to R2 later                    # If definetly not a fail overall    if (Info.faillabprog==0 and (Info.creditsfailed-Info.deferredcredits <= 40)):        # if not more than 40 credits < 40% and none below 30%, they can all be compensated (except Y1 MATHs for M+P students and mustpass)        if (Info.someunitunder30==0):            for idx in Info.units30_39_idx:                if (idx not in Info.excluded_idx and idx not in Info.compensated_idx and Info.coursenames[idx] not in mustpass):                    Info.compensated_idx.append(idx) # compensated automatically for Physics students        # if any mark <30% must be resat and triggers resits of any core course 30-39% (if <40 credits 30-39%)        elif (Info.someunitunder30==1):            Info.resitstriggered = True            for idx in Info.failed_idx: # loop through all failed courses                if (idx not in Info.excluded_idx and Info.credits[idx] != 0): # if not excluded                    if (Info.marks[idx] < 29.95):  # if <30% must be resat                        if (idx in Info.secondattempt_idx): # If 2nd attempt and is failed, then is a fail!                            Info.fail = True                            Info.status = 'FAIL'                            Info.progress= False                            Info.failreason = 'Failed (<30%) 2nd attempts'                            print('Failed 2nd attempts')                        else:                            Info.referred_idx.append(idx)                    elif (idx in Info.units30_39_idx and idx in Info.core_idx): # if 30-39 resit if core course                        if (idx in Info.secondattempt_idx): # If 2nd attempt and is failed, then is a fail!                            Info.fail = True                            Info.status = 'FAIL'                            Info.progress= False                            Info.resitstriggered=True                            Info.failreason = 'Failed 2nd attempts (core not compensatable)'                            print('Failed 2nd attempt: {0:s} not compensatable'.format(Info.coursenames[idx]))                        else:                            Info.referred_idx.append(idx)                    elif (idx not in Info.referred_idx and idx not in Info.core_idx and idx not in Info.compensated_idx and Info.coursenames[idx] not in mustpass):                            Info.compensated_idx.append(idx) # else will be compensated (not for 0-credit units)                    elif (idx not in Info.compensated_idx): # else referred if not already compensated                        Info.referred_idx.append(idx)                            # Else if > 40 credits at 30-39%, all core units must be resat    elif ((Info.creditsfailed-Info.deferredcredits) > 40 and len(Info.failed_idx) >0):        Info.resitstriggered = True        for idx in Info.failed_idx:  # loop through all failed courses            if (Info.marks[idx] < 29.95 and idx not in Info.excluded_idx and Info.credits[idx] !=0): # courses < 30% must be resat                if (Info.secondattempt_idx and idx not in Info.excluded_idx): # if 2nd attempt, and is failed, then is a fail!                    Info.status='FAIL'                    print('Fail due to failed 2nd attempts')                    Info.failreason = 'Failed 2nd attempts'                    Info.fail = True                    Info.progress = False                    Info.resitstriggered=False                else:                    Info.referred_idx.append(idx)              elif (idx in Info.core_idx and idx not in Info.excluded_idx and Info.credits[idx] !=0):  # only for core courses                if (Info.secondattempt_idx and idx not in Info.excluded_idx): # if 2nd attempt, and is failed, then is a fail!                    Info.status='FAIL'                    print('Fail due to failed 2nd attempts')                    Info.failreason = 'Failed 2nd attempts'                    Info.fail = True                    Info.progress = False                    Info.resitstriggered=False                else:                    Info.referred_idx.append(idx)              elif (idx not in Info.deferred_idx and idx not in Info.excluded_idx and Info.credits[idx] !=0): # else must be compensated as an option                if (idx not in Info.compensated_idx and Info.coursenames[idx] not in mustpass):                    Info.compensated_idx.append(idx)        # If Maths+Physics student, some MATHs courses in Y1 not compensatable and must be resat    # (pre-2023: all MATHs in 1st year, post-2023 two modules - see Judith McGovern email 14-May-2022     if (Info.mathstudent == True and Info.classyear == 1):        if (Info.AY <= 2022):  # all MATHs units in 1st year non-compensatable            for idx in Info.compensated_idx:                if (idx in Info.math_units_idx):                    Info.compensated_idx.remove(idx)                    if (Info.secondattempt_idx and idx not in Info.excluded_idx): # if 2nd attempt, and is failed, then is a fail!                        Info.status='FAIL'                        print('Fail due to failed 2nd attempts')                        Info.failreason = 'Failed 2nd attempts'                        Info.fail = True                        Info.progress = False                        Info.resitstriggered=False                    else:                        Info.referred_idx.append(idx)        elif (Info.AY > 2022): # post 2023 onwards: only 2 MATHs modules (listed in not_compensatable dictionary)            for idx in Info.compensated_idx:                if (Info.coursenames[idx] in not_compensatable):                    Info.compensated_idx.remove(idx)                    if (Info.secondattempt_idx and idx not in Info.excluded_idx): # if 2nd attempt, and is failed, then is a fail!                        Info.status='FAIL'                        print('Fail due to failed 2nd attempts')                        Info.failreason = 'Failed 2nd attempts'                        Info.fail = True                        Info.progress = False                        Info.resitstriggered=False                    else:                        Info.referred_idx.append(idx)                        # Now put back any previous referred coursenames at 2nd attempt into the referred idx list     if (Info.secondpass == True):        for idx in Info.keep_referred_idx:  # put back only referred that are 2nd attempt            if (idx not in Info.referred_idx):                Info.referred_idx.append(idx)    # For resits ensure that all R1/R2 codes still next to mark there even if no mark/previous code (therefore not in resit_idx)    if (Info.secondpass == True):        for idx in Info.referred_idx:            if ('R2' not in Info.codes2[idx]):                Info.codes2[idx] = 'R2_' + Info.codes2[idx]                if (idx not in Info.resit_idx):                    Info.resit_idx.append(idx)                     for idx in Info.deferred_idx:            if ('R1' not in Info.codes2[idx]):                Info.codes2[idx] = 'R1_' + Info.codes2[idx]                if (idx not in Info.resit_idx):                    Info.resit_idx.append(idx)                                        # Remove compensation if a referral (e.g. a capped resit like 30R is not compensated)    #idx = [i for i in Info.compensated_idx if (i not in Info.referred_idx and i not in Info.deferred_idx)]    #for i in idx:    #    Info.compensated_idx.remove(i)            # Deal with any resit marks < 30 (failed) but OM 30-39 - do not need to be resats    #if (Info.secondpass == True)                    # Remove compensation code if above 40    for idx in Info.compensated_idx:        if (Info.marks[idx] >= 39.95):            Info.compensated_idx.remove(idx)                    # apply referred coursenames and any missing R codes     for idx in Info.referred_idx:        Info.referredcoursenames += Info.coursenames[idx] + ' / '  # add referred coursenames        if (Info.codes2[idx].find('R') < 0 and Info.codes[idx].find('SR') < 0):            #Info.codes[idx] += '_R2'  # not for CS 1-line sheet            Info.codes2[idx] = 'R2_' + Info.codes2[idx] # to incidcate resit at 2nd attempt            Info.en_codes[idx] = 'R2_' + Info.en_codes[idx] # for CS 1-line sheet                # Apply any missing compensated unit codes to the mark if not there (don't add to mark unless on input)    for idx in Info.compensated_idx:        #if (Info.marksout[idx].find('C') < 0):            #Info.marksout[idx] += 'C' # to indicate compensated (only if on input grid to be consistent)        #if (Info.codes2[idx].find('C') < 0 and Info.codes2[idx].find('MC') < 0):        #Info.codes[idx] += '_C'   # not for CS 1-line sheet        Info.codes2[idx] += '_C'        Info.en_codes[idx] += '_C'  # for CS 1-line sheet            # Remove any leading/trailing '_' to the code if it exists    for i in range(len(Info.codes)):        if (len(Info.codes[i]) > 0 and Info.codes[i][0] == '_'): Info.codes[i] = Info.codes[i][1:]        if (len(Info.codes2[i]) > 0 and Info.codes2[i][0] == '_'): Info.codes2[i] = Info.codes2[i][1:]        if (len(Info.en_codes[i]) > 0 and Info.en_codes[i][0] == '_'): Info.en_codes[i] = Info.en_codes[i][1:]        #if (len(Info.p_codes[i]) > 0 and Info.p_codes[i][0] == '_'): Info.p_codes[i] = Info.p_codes[i][1:]        if (len(Info.codes[i]) > 0 and Info.codes[i][-1] == '_'): Info.codes[i] = Info.codes[i][0:-1]        if (len(Info.codes2[i]) > 0 and Info.codes2[i][-1] == '_'): Info.codes2[i] = Info.codes2[i][0:-1]        if (len(Info.en_codes[i]) > 0 and Info.en_codes[i][-1] == '_'): Info.en_codes[i] = Info.en_codes[i][0:-1]                # Remove any trailing ' / ' in referred/deferred coursenames    #if (Info.referredcoursenames[-2:].find('/') >=0):    #    Info.referredcoursenames = Info.referredcoursenames[:-2]    #if (Info.deferredcoursenames[-2:].find('/') >=0):    #    Info.deferredcoursenames = Info.deferredcoursenames[:-2]                # Remove any spaces    Info.codes = [s.replace(' ', '') for s in Info.codes]    Info.codes2 = [s.replace(' ', '') for s in Info.codes2]    Info.en_codes = [s.replace(' ', '') for s in Info.en_codes]        return Info################################################################# Determine which units are to be referred (resit) or can be compensateddef get_referred_units_old(Info):        # If not Y1/Y2 then skip this function (no resits in Y3/Y4)    if (Info.classyear != 1 and Info.classyear != 2):        return Info        # blank variables in case this is being ran twice (for resit grids) but keep record of resits at 2nd attempt to keep for later    if (Info.secondpass == True):        Info.keep_referred_idx = [idx for idx in Info.referred_idx if idx in Info.secondattempt_idx]        Info.referred_idx = []  # blank them        Info.referredcoursenames = '' # blank them        #Info.compensated_idx = []  # do not blank here            # if not more than 40 credits < 40% and none below 30%, they can all be compensated (except Y1 math)    if (Info.someunitunder30==0 and Info.faillabprog==0 and (Info.creditsfailed-Info.deferredcredits <= 40)):        for idx in Info.units30_39_idx:            #if (idx in Info.compensated_idx and Info.secondpass == True): # if already compensated (resitgrid) then just carry on after putting codes in                #Info.marksout[idx] = Info.marksout[idx] + Info.codes[idx]            if (Info.classyear == 1 and Info.mathstudent == True and idx in Info.math_units_idx and idx not in Info.deferred_idx and idx not in Info.excluded_idx):                if (Info.secondpass == True and idx in Info.secondattempt_idx): # If fail at 2nd attempt, a fail overall                    Info.failed_idx.append(idx)                    Info.fail = True                    Info.status = 'FAIL'                    print('Fail due to failed 2nd attempts')                else:                    Info.referred_idx.append(idx)   # Any Y1 math units are referred for M+P students (but only if not resat already!)            elif (idx not in Info.deferred_idx and idx not in Info.excluded_idx and Info.credits[idx] !=0):                #if (Info.marksout[idx].find('C') < 0): Info.marksout[idx] = Info.marksout[idx] + '_C'  # add code to show it is compensated                #if (Info.codes[idx].find('C') < 0): Info.codes[idx] = Info.codes[idx] + '_C'                if (idx not in Info.compensated_idx): Info.compensated_idx.append(idx)                if (Info.codes[idx].find('XN') > 0): # only if not excluded                    Info = get_credweights(Info,credweightunits,useidx=idx)     # put credit weight back in case it has been zeroed    # if any mark <30% must be resat and triggers resits of any core course 30-39% (if <40 credits 30-39%)    if (Info.someunitunder30==1 and Info.faillabprog==0 and (Info.creditsfailed-Info.deferredcredits <= 40)):        Info.resitstriggered = True        for idx in Info.failed_idx: # loop through all failed courses            if (Info.marks[idx] < 29.95 and idx not in Info.excluded_idx and Info.credits[idx] != 0):  # if <30% must be resat                if (Info.secondpass == True and idx in Info.secondattempt_idx): # If 2nd attempt and is failed, then is a fail!                    Info.status = 'FAIL'                    print('Fail due to failed 2nd attempts')                    Info.fail = True                    Info.progress= False                else:                    Info.referred_idx.append(idx)            elif (idx in Info.units30_39_idx and idx in Info.core_idx and idx not in Info.excluded_idx and Info.credits[idx] !=0): # if 30-39 resit if core course                if (Info.secondpass == True):                    if (Info.p_codes[idx].find('C') <0 and idx not in Info.secondattempt_idx): # check if not allowed to compensate for 2nd pass or if already resat                        Info.referred_idx.append(idx)                    elif (idx not in Info.deferred_idx and Info.credits[idx] !=0 and idx not in Info.referred_idx):        # else will be compensated (not for 0-credit units)                        #if (Info.marksout[idx].find('C') < 0): Info.marksout[idx] = Info.marksout[idx] + '_C'                        #if (Info.codes[idx].find('C') < 0): Info.codes[idx] = Info.codes[idx] + '_C'                        if (idx not in Info.compensated_idx): Info.compensated_idx.append(idx)                            # if > 40 credits at 30-39%, all core units must be resat    if ((Info.creditsfailed-Info.deferredcredits) > 40 and len(Info.failed_idx) >0):        Info.resitstriggered = True        for idx in Info.failed_idx:  # loop through all failed courses            if (Info.secondpass == True and idx in Info.secondattempt_idx and idx not in Info.excluded_idx): # if 2nd attempt, and is failed, then is a fail!                Info.status='FAIL'                print('Fail due to failed 2nd attempts')                Info.fail = True                Info.progress = False                Info.resitstriggered=False            elif (Info.marks[idx] < 29.95 and idx not in Info.excluded_idx and Info.credits[idx] !=0): # courses < 30% must be resat                Info.referred_idx.append(idx)              elif (idx in Info.core_idx and idx not in Info.excluded_idx and Info.credits[idx] !=0):  # only for core courses                Info.referred_idx.append(idx)              elif (idx not in Info.deferred_idx and idx not in Info.excluded_idx and Info.credits[idx] !=0): # else must be compensated as an option                if (idx not in Info.compensated_idx): Info.compensated_idx.append(idx)                #if (Info.marksout[idx].find('C') < 0): Info.marksout[idx] = Info.marksout[idx] + '_C'                #if (Info.codes[idx].find('C') < 0): Info.codes[idx] = Info.codes[idx] + '_C'                        # add any other codes already in the input    #for idx in range(len(Info.marks)):        #if ((Info.codes[idx].find('R') >= 0 and Info.marksout[idx].find('R') <0) or (Info.codes[idx].find('A') >=0 and Info.marksout[idx].find('A') <0)):   # put main code if exists including 1st pass        #    Info.marksout[idx] += Info.codes[idx]                # Now put back any previous referred coursenames at 2nd attempt into the referred idx list     if (Info.secondpass == True):        for idx in Info.keep_referred_idx:  # put back only referred that are 2nd attempt            if (idx not in Info.referred_idx):                Info.referred_idx.append(idx)    # Deal with any resit marks < 30 (failed) but OM 30-39 - do not need to be resat    #if (Info.secondpass == True)                    # apply referred coursenames and codes to output marks     for idx in Info.referred_idx:        Info.referredcoursenames += Info.coursenames[idx] + ' / '  # add referred coursenames        #if (Info.codes[idx].find('R') >= 0):   # put main code if exists        #    Info.marksout[idx] += Info.codes[idx]        #if (Info.secondpass == True):  # for resits only        #    if (Info.p_codes[idx].find('R') >= 0 and Info.marksout[idx].find('R') < 0): # put p_code if not e.g. R1, R2        #        Info.marksout[idx] += Info.p_codes[idx]        #if (Info.marksout[idx].find('R') < 0 and Info.marksout[idx].find('A2') < 0): # if not already in marksout, add _R to indicate resit        #    Info.marksout[idx] = Info.marksout[idx] + '_R'    return Info################################################################# make precapped/poscapped marks arrays, and also apply any other rules for resitsdef apply_capped_resit_marks(Info):    # only apply if 2nd pass (resit)     if (Info.secondpass == True):        # if a course is excluded due to missing but is referred (for 2nd attempt) then still include in average        for idx in Info.referred_idx:            if (idx in Info.excluded_idx): # do not exclude if XL but is a referall (e.g. R2) and use original mark/credits                Info.excluded_idx.remove(idx)                Info.excludedcoursenames.remove(Info.coursenames[idx])                Info.credweights[idx] = Info.credits[idx]                Info.marks_postcapped[idx] = Info.p_marks[idx]   # apply marks to postcapped array        # If a course is compensated and OM<29.95, but new mark is >30, use new mark (this is for when compensated was determined later)        #for idx in Info.compensated_idx:        #    if (Info.p_marks[idx] < 29.95 and Info.marks[idx] > 29.95):        #        Info.marks_postcapped[idx] = Info.marks[idx]        # If a course is compensated and OM<29.95, but new mark is >30, cap at 30 (still compensatable)        for idx in Info.compensated_idx:            if (Info.p_marks[idx] < 29.95 and Info.marks[idx] > 29.95):                Info.marks_postcapped[idx] = 30                        # use capped resit marks         Info.marks_precapped = Info.marks.copy() # to store just in case needed        Info.marks = Info.marks_postcapped.copy() # replace marks with correct (capped) resit marks    return Info################################################################# get overall average year markdef get_yearmark(Info):    # get arrays            marks = np.array(Info.marks.copy())    credweights = np.array(Info.credweights.copy())    # get credits    sumcredweights = np.sum(credweights)    Info.sumcredweights = sumcredweights        # do calculation    if (sumcredweights > 0):        Info.yearmark = np.sum(marks*credweights)/sumcredweights        Info.yearmark = round(Info.yearmark + 0.000001, 1) # round to 1 d.p.    else:        Info.yearmark = -1  # if no marks    Info.yearmarkout = str(Info.yearmark)            return Info################################################################# get overall average year mark for Physics and Math separately including overall year mark (for M+P students only)def get_mp_yearmark(Info):        marks       = np.array(Info.marks.copy())    credweights = np.array(Info.credweights.copy())  # Needed for separate Physics/Math averages    credits     = np.array(Info.credits.copy())      # Needed for year average for weighting of Physics/Math        # Physics    idx = Info.phys_units_idx    physcredweights = np.sum(credweights[idx])    if (physcredweights > 0):        phys_yearmark = np.sum(marks[idx]*credweights[idx])/physcredweights  # do not round yet    else:        phys_yearmark = 0.0            # Math    idx = Info.math_units_idx    mathcredweights = np.sum(credweights[idx])    if (mathcredweights > 0):        math_yearmark = np.sum(marks[idx]*credweights[idx])/mathcredweights  # do not round yet    else:        math_yearmark = 0.0        # Overall year mark replaced by weighted average of M+P separately using original credit weightings (for M+P students only)    # Exclude deferred credits from the credit M+P credit split (Judith email 06-Jul-2022 but won't be an issue for future years)    # From 2023 just do straight average like for other students    if (Info.mathstudent):        phys_units_idx = Info.phys_units_idx.copy()        math_units_idx = Info.math_units_idx.copy()        excluded_idx   = Info.excluded_idx.copy()            # get physics/maths units omitting excluded ones        phys_assessed_credits_idx = [idx for idx in phys_units_idx if idx not in excluded_idx]        math_assessed_credits_idx = [idx for idx in math_units_idx if idx not in excluded_idx]        sumcredits_phys = np.sum(credits[phys_assessed_credits_idx])        sumcredits_math    = np.sum(credits[math_assessed_credits_idx])        if ( (sumcredits_phys+sumcredits_math) == 0):  # just to catch when 0 credits            yearmark = 0        else:            yearmark   = (phys_yearmark*sumcredits_phys + math_yearmark*sumcredits_math)/(sumcredits_phys+sumcredits_math)                    Info.yearmark  = round(yearmark+0.000001,1)  # only add back to Info if math student (round to 1 d.p.)                # From AY 2023, just do straight average like for other students (not sure why above is not identical to this!)        if (Info.AY >= 2023):            Info = get_yearmark(Info)            # Add back to Info    Info.physcredweights = physcredweights    Info.mathcredweights    = mathcredweights    Info.phys_yearmark   = round(phys_yearmark+0.000001,1)  # round to 1 d.p.    Info.math_yearmark      = round(math_yearmark+0.00001,1)      # round to 1 d.p.    # If missing marks (-1) put back as intger (-1) rather than -1.0    if (Info.yearmark < 0): Info.yearmark = -1    if (Info.phys_yearmark < 0): Info.phys_yearmark = -1    if (Info.math_yearmark < 0): Info.math_yearmark = -1             # Add O/P/M string and physics/math credist taken string for output    Info.year_opm           = str(Info.yearmark) + ' / ' + str(Info.phys_yearmark) + ' / ' + str(Info.math_yearmark)     Info.creditstaken_pm    = str(Info.physcreditstaken) + ' / ' + str(Info.mathcreditstaken)        return Info################################################################# get credits at and above each level (for promotion and CS output)def get_credits_above(Info):    # Get credits credits in each class, not including excluded credits    marks = Info.marks.copy()    idx = [i for i, v in enumerate(marks) if (v >= boundaryfirst and i not in Info.excluded_idx)] # 1st    Info.credsatfirst = sum([Info.credits[i] for i in idx])    idx = [i for i, v in enumerate(marks) if (v >= boundaryupper2 and v < boundaryfirst and i not in Info.excluded_idx)]  #2.1    Info.credsatupper2 = sum([Info.credits[i] for i in idx])    idx = [i for i, v in enumerate(marks) if (v >= boundarylower2 and v < boundaryupper2 and i not in Info.excluded_idx)] #2.2    Info.credsatlower2 = sum([Info.credits[i] for i in idx])    idx = [i for i, v in enumerate(marks) if (v >= boundarythird and v < boundarylower2 and i not in Info.excluded_idx)]  #3rd    Info.credsatthird = sum([Info.credits[i] for i in idx])    idx = [i for i, v in enumerate(marks) if (v < boundarythird and v >=0 and i not in Info.excluded_idx)]  # Failed (<40 but >=0 to ignore -1 marks!)    Info.credsfailed = sum([Info.credits[i] for i in idx])    idx = [i for i, v in enumerate(marks) if (v >= 29.95 and v < boundarythird and i not in Info.excluded_idx)]  # CF (30-39) - for CS output     Info.credsatCF = sum([Info.credits[i] for i in idx])        # credits above each class    Info.credsaboveupper2 = Info.credsatfirst + Info.credsatupper2    Info.credsabovelower2 = Info.credsaboveupper2 + Info.credsatlower2    Info.credsabovethird  = Info.credsabovelower2 + Info.credsatthird        return Info################################################################# Get overall mark based on years availabledef get_overallmark(Info,doCF):    overallmark=-1    overallmathmark=-1    overallphysmark=-1        # If no Carry Forward and no previous marks from the file (2023+), then can only do this years mark and get out    if (doCF == False and Info.dooverall == False):        if (Info.classyear != 1): print('No Carry Forward marks so cannot calculate overall mark (only year mark)')        Info.overallmark = overallmark        Info.overallphysmark = overallphysmark        Info.overallmathmark   = overallmathmark        Info.overallmark_opm   = ''                return Info    # BSc and MPhys have same weights except in Y4     if (Info.classyear != 4):        if (Info.phys1<0 and Info.phys2<0): # no first or second year mark, so 1st year (also direct entry to 3rd year)            overallmark = Info.yearmark          elif (Info.phys1<0 and Info.phys2>0): # no first year mark, so direct entry            overallmark = (1/3)*Info.phys2 + (2/3)*Info.yearmark         elif (Info.phys1>0 and Info.phys2<0):  # for 2nd years when CF file available            overallmark = 0.25*Info.phys1 + 0.75*Info.yearmark         else: # Default for 3-year course (both BSc and MPhys progressing - see Judith emails 24/25-Jun-2023)            overallmark = 0.1*Info.phys1+0.3*Info.phys2+0.6*Info.yearmark          overallphysmark = overallmark                         #  Y4 (MPhys only)     if (Info.classyear == 4):        if (Info.phys1 < 0 and Info.phys2 > 0): # no first year mark, direct entry to 2nd year            overallmark = (0.19/0.94)*Info.phys2 + (0.375/0.94)*Info.phys3 + (0.375/0.94)*Info.yearmark          elif (Info.phys1 < 0 and Info.phys2 < 0 and Info.phys3>0): # no first or second year mark, so direct entry to 3rd year             overallmark = 0.5*Info.phys3 + 0.5*Info.yearmark          elif (Info.phys1 < 0 and Info.phys2 < 0 and Info.phys3<0): # only 4th year mark available            overallmark = Info.yearmark          else: # 4th year default            overallmark = 0.06 * Info.phys1 + 0.19 * Info.phys2 + 0.375 * Info.phys3 + 0.375*Info.yearmark               # MPHYS study in/abroad [ Phys Europe 4th year - previously had [3A] or [A] to be added to the program code to differentiate them. ]    # only apply in Y4 (otherwise 3-year weights)    if (Info.classyear == 4 and (Info.abroad == True or Info.Euro == True)):         overallmark = 0.08 * Info.phys1 + 0.23 * Info.phys2 + 0.23 * Info.phys3 + 0.46*Info.yearmark                     overallphysmark = overallmark  # log physics mark    # BSc M/P (only for pre AY=2023 for backward compatibility)    if (Info.AY <= 2022 and 'BSc' in Info.Plan and 'Math' in Info.Plan):        if (Info.phys1<0 and Info.phys2>0): # no first year mark, so direct entry (Y3)            overallmark=0.3333*(Info.phys2+Info.math2)/2.+0.6666*Info.yearmark             overallphysmark = 0.3333 * Info.phys2 + 0.6666 * Info.phys_yearmark             overallmathmark = 0.3333 * Info.math2 + 0.6666 * Info.math_yearmark        elif (Info.phys1>0 and Info.phys2<0): # 2nd year students when CF file available             overallmark = 0.25*(Info.phys1+Info.math1)/2. + 0.75*Info.yearmark            overallphysmark = 0.25*Info.phys1 + 0.75*Info.phys_yearmark            overallmathmark = 0.25*Info.math1 + 0.75*Info.math_yearmark        else:            overallmark= 0.1*(Info.phys1+Info.math1)/2. + 0.3*(Info.phys2+Info.math2)/2. +0.6*Info.yearmark            overallphysmark = 0.1*Info.phys1 + 0.3*Info.phys2 + 0.6*Info.phys_yearmark            overallmathmark = 0.1*Info.math1 + 0.3*Info.math2 + 0.6*Info.math_yearmark    # MPHYS M/P (only for pre AY=2023 backward compatibility)    if (Info.AY <= 2022 and 'Phys' in Info.Plan and 'Math' in Info.Plan and 'BSc' not in Info.Plan):        if (Info.phys1 < 0 and Info.phys2 > 0 and Info.year3mark < 0): # no first  year mark, so direct entry (Y3)            overallmark = (0.19/0.565)*(Info.phys2+Info.math2)/2.  + (0.375/0.565)*Info.yearmark              overallmathmark = (0.19/0.565)*Info.math2 + (0.375/0.565)*Info.math_yearmark            overallphysmark = (0.19/0.565)*Info.phys2 + (0.375/0.565)*Info.phys_yearmark        elif (Info.phys1 < 0 and Info.phys2 > 0 and Info.year3mark > -1): # no first  year mark, so direct entry (Y4)            overallmark = (0.19/0.94)*(Info.phys2+Info.math2)/2. + (0.375/0.94)*Info.year3mark + (0.375/0.94)*Info.yearmark              overallmathmark = (0.19/0.94)*Info.math2 + (0.375/0.94)*Info.math3 + (0.375/0.94)*Info.math_yearmark            overallphysmark = (0.19/0.94)*Info.phys2+ (0.375/0.94)*Info.phys3 + (0.375/0.94)*Info.phys_yearmark        elif (Info.phys1 < 0 and Info.phys2 < 0 and Info.year3mark > -1): # no first or second year mark, so direct entry            overallmark = 0.5*Info.year3mark + 0.5*Info.yearmark              overallphysmark = 0.5*Info.phys3 + 0.5*Info.phys_yearmark            overallmathmark = 0.5*Info.math3 + 0.5*Info.math_yearmark        elif (Info.phys1>0 and Info.phys2<0):  # 2nd years when CF file available             overallmark = 0.06/0.25 * (Info.phys1+Info.math1)/2. + 0.19/0.25*Info.yearmark            overallmathmark =  0.06/0.25 * Info.math1 + 0.19/0.25 * Info.math_yearmark            overallphysmark = 0.06/0.25 * Info.phys1 + 0.19/0.25 * Info.phys_yearmark        elif (Info.phys1>0 and Info.phys2>0 and Info.phys3<0): # 3rd years            overallmark = (0.06/0.625)*(Info.phys1+Info.math1)/2. + (0.19/0.625)*(Info.phys2+Info.math2)/2. + (0.375/0.625)*Info.yearmark            overallmathmark =  (0.06/0.625)*Info.math1 + (0.19/0.625)*Info.math2 + (0.375/0.625)*Info.math_yearmark            overallphysmark = (0.06/0.625)*Info.phys1 + (0.19/0.625)*Info.phys2 + (0.375/0.625)*Info.phys_yearmark        else: # 4th years            overallmark = 0.06 * (Info.phys1+Info.math1)/2. + 0.19 * (Info.phys2+Info.math2)/2. + 0.375 * Info.year3mark + 0.375*Info.yearmark            overallmathmark =  0.06 * Info.math1 + 0.19*Info.math2 + 0.375*Info.math3 + 0.375*Info.math_yearmark            overallphysmark = 0.06 * Info.phys1 + 0.19 * Info.phys2 + 0.375 * Info.phys3 + 0.375*Info.phys_yearmark    # Add back to Info    Info.overallmark     = round(overallmark+0.000001,1)    Info.overallphysmark = round(overallphysmark+0.000001,1)    Info.overallmathmark = round(overallmathmark+0.000001,1)    # add output mark as a string (so can easily add '**' or other things later)    Info.overallmarkout = str(Info.overallmark)    # also output O/P/M    Info.overallmark_opm = Info.overallmarkout + ' / ' + str(Info.overallphysmark) + ' / ' + str(Info.overallmathmark)        return Info################################################################# get status for progression# remove referred/deferred info if already faileddef get_status(Info):    if (Info.fail == False): # unless a fail for another reason 'ACTV' default status to begin with        Info.status = 'ACTV'          # borderlines for MPhys students    if (Info.AY == 2020 or Info.AY == 2021):        rbsc_upper = 51.95  # changed due to COVID after 2019 (used in 2020/2021) but not in 2022 - see Ivan/Judith email 15-Sep-2022         rx_upper   = 54.95    else: # pre-2019 and post 2022 back to normal        rbsc_upper = 52.95         rx_upper   = 54.95            if (len(Info.deferred_idx) > 0):        Info.status = 'A/D'         # student with deferrals        if (Info.fail == True):             Info.fail = False            Info.failreason = ''            if (len(Info.referred_idx) > 0):         Info.status = 'REVW'        # student with resits (REVW trumps A/D)        if (Info.fail == True): # in case a "fail" (resit/second pass) but shouldn't be, reset:            Info.fail = False            Info.failreason = ''                                        # MPhys borderline/move to BSc students (for Y2/3)     if (Info.mphysstudent == True and Info.classyear == 2):         # For students without resits (1st pass)         if (Info.secondpass == False and len(Info.referred_idx) == 0 and len(Info.deferred_idx) == 0):            if (Info.yearmark < rbsc_upper):                Info.status = 'R/BSc'            elif (Info.yearmark < rx_upper):                Info.status = 'R/X'        # On 2nd pass, if referalls use new (August) mark otherwise use previous (June) mark (Judith email 15-Sep-2022)        if (Info.secondpass == True and len(Info.deferred_idx) == 0):            # if no referrals, use new (August) mark             if (len(Info.referred_idx) == 0):                if (Info.yearmark < rbsc_upper):                    Info.status = 'R/BSc'                elif (Info.yearmark < rx_upper):                    Info.status = 'R/X'            # if referrals, use previous (June) mark            elif (len(Info.referred_idx) > 0):                yearmark = Info.p_yearmark # (previous mark in June)                if (yearmark < rbsc_upper):                    Info.status = 'R/BSc'                elif (yearmark < rx_upper):                    Info.status = 'R/X'    # Y3->Y4 progression    if (Info.classyear == 31):        # Min level of credits to progress for Y3->Y4 is 100 credits        min_credits = 100                # must be level 3/4/6 courses from 2023 but  only for BSc, not MPhys! (Judith email 24-Jun-2023)                        if (Info.faillabprog==False and Info.creditspassed>=min_credits and Info.yearmark>=49.95 and Info.overallmark>=49.95):            Info.status   = 'ACTV'            Info.fail     = False            Info.progress = True        elif (Info.faillabprog==False and Info.creditspassed>=min_credits and (Info.yearmark>=47.95 and Info.overallmark>=47.95) ):  # borderline goes to review            Info.status   = 'REVW BSc 2.2'             #Info.fail     = True            Info.progress = False            #Info.finalyear = True  # Put these back if wanting to go through apply_promotion etc.        elif (Info.faillabprog==False and Info.creditspassed<min_credits):  # borderline with fewer credits goes to review for BSc            if (Info.overallmark>59.95 and Info.credits34passed>=creditstogetBScgood):                Info.status = 'REVW BSc 2.1'                Info.progress = False                #Info.finalyear = True            elif (Info.overallmark>49.95 and Info.credits34passed>=creditstogetBScgood):                Info.status = 'REVW BSc 2.2'                Info.progress = False                #Info.finalyear = True            elif (Info.overallmark>39.95 and Info.credits34passed>=creditstogetBSclower):                Info.status = 'REVW BSc 3'                Info.progress = False                #Info.finalyear = True            else:                Info.status   = 'FAIL'                Info.failreason = '<MPhys fail (<50%) and not enough marks/credits ({0:d}/{1:d}) for BSc 3 '.format(Info.credits34passed,creditstogetBSclower)                Info.fail     = True                Info.progress = False        else:  # MPhys Fail -> BSc            Info.status   = 'FAIL->BSc'            Info.fail     = True            Info.progress = False            #Info.finalyear = True            if (Info.faillabprog == True):   Info.failreason = 'MPhys fail (lab/project) -> BSc'            elif (Info.creditspassed < creditstogetMPHYSlower):       Info.failreason = 'MPhys fail (credits) -> BSc'            elif (Info.overallmark < 49.95): Info.failreason = 'MPhys fail (<50%) -> BSc'                            # Additional requirement for M+P students to get >45% M+P separately to progress in 3rd year to progress    if (Info.mathstudent == True and Info.classyear == 31 and Info.fail == False):         if (Info.faillabprog == False and (Info.phys_yearmark<45 or Info.math_yearmark<45)): # >45% M+P separately            if (Info.overallmark>boundaryupper2 and Info.credits34passed>=creditstogetBScgood):                Info.status = 'REVW BSc 2.1'                Info.progress = False                #Info.finalyear = True            elif (Info.overallmark>boundarylower2 and Info.credits34passed>=creditstogetBScgood):                Info.status = 'REVW BSc 2.2'                Info.progress = False                #Info.finalyear = True            elif (Info.overallmark>boundarythird and Info.credits34passed>=creditstogetBSclower):                Info.status = 'REVW BSc 3'                Info.progress = False                #Info.finalyear = True            else: # if not borderline, then is a fail                    Info.status = 'FAIL'                    Info.failreason = '<45% separately in Math/Phys and not borderline'                    Info.fail = True                    Info.progress = False                    # Y1/Y2 if < 80 credits (if > 60, may be able to resit as per below), but don't do this if missing marks    if ( (Info.classyear == 1 or Info.classyear == 2) and ((Info.creditspassed+Info.deferredcredits) < 80) and len(Info.referred_idx) == 0 and len(Info.deferred_idx) == 0 and len(Info.nomarks_idx) == 0):        Info.fail = True        Info.progress = False        Info.status = 'FAIL'        Info.failreason = '<80 credits'            # If fewer than 60 credits, then fail    if ((Info.creditspassed + Info.deferredcredits) < 60):        Info.fail   = True        Info.status = 'FAIL'        Info.failreason = '< 60 credits'    # For 2nd attempts that are failed or no mark for a resit then is a fail (unless codes say is first attempt or can be excluded)    if (Info.secondpass == True):        for idx in Info.secondattempt_idx:            if (Info.marks[idx] < 29.95 and idx not in Info.excluded_idx and idx not in Info.referred_idx):                Info.fail = True                Info.progress = False                Info.status = 'FAIL'                Info.failreason = 'Failed (<30%) 2nd attempt resits'    if (Info.faillabprog == True):  # student has failed lab        Info.status = 'FAIL'        Info.failreason = Info.failreason + ' Failed lab/project/non-resittable unit'        Info.fail = True    # If 'PRO' in the marks likely the full marks are not in so just change fail to ACTV unless definitely deferred units    #if ('PRO' in Info.codes):    #    Info.status = 'ACTV'    #    Info.fail   = False    #    Info.progress = True    #    Info.failreason = ''    #elif (hasattr(Info,'p_codes') and 'PRO' in Info.p_codes):    #    Info.status = 'ACTV'    #    Info.fail   = False    #    Info.progress = True    #    Info.failreason = ''    # if it looks like a repeating student remove _R, _C etc. and  reset status and output to screen for info    # (these would normally be put in the donotprocesslist)    if (Info.finalyear == False and Info.resitgrid == False and Info.repeating == True):    #    Info.status = ''    #    Info.codes = ['']*len(Info.codes)    #    Info.compensated_idx = []    #    Info.referred_idx = []    #    Info.referredcoursenames = ''    #    Info.deferred_idx = []        #print('Looks like repeating student -details (resits/status) may be incorrect for Y1/Y2 (marks should still be ok)')        pass # better not print anything since L?CM marks give the current years marks so all students appear to be repeating!!    # if lab mark is 39 can resit over summer (essay)    if (Info.lab_resit == True and (Info.creditspassed+Info.deferredcredits >= 40)): # only if < 60 credits failed plus lab (worth 20)         for idx in Info.failed_idx:            if (Info.marks[idx] > 38.45 and Info.coursenames[idx] in mustpass): # check again to be sure                Info.fail = False                Info.failreason = 'Resit failed lab'                Info.status = 'REVW'                if (idx not in Info.referred_idx):                    Info.referred_idx += [idx]                    if (len(Info.codes2[idx]) == 0):  # add 'R2' to show it's a resit                        Info.codes2[idx] = 'R2'                    elif (Info.codes2[idx].find('R2') < 0): # (if not there already from the input)                        Info.codes2[idx] += '_R2'                    if (len(Info.referred_idx) > 1): # add mustpass course to referral list                        Info.referredcoursenames += ' / ' + Info.coursenames[idx]                    else:                        Info.referredcoursenames = Info.coursenames[idx]                    if (len(Info.deferred_idx) > 1): # add leading ' / ' if necessary                        Info.referredcoursenames = ' / ' + Info.referredcoursenames                                                # In general, if a fail, referrals/deferalls and print out the fail reason (and remove any C/R *output* codes - go back to inputs only)    if (Info.fail == True):         #if (Info.resitgrid == False): # do not do for resit grids for now            #codes = Info.codes.copy()            #for i in range(len(codes)): # Remove R/C codes, R1/R2, SR1 etc.            #        codes[i] = codes[i].replace('R', '')            #        codes[i] = codes[i].replace('C','')            #        codes[i] = codes[i].replace('1', '')            #        codes[i] = codes[i].replace('2','')            #        codes[i] = codes[i].replace('S', '')            #        codes[i] = codes[i].replace('XN', '')            #        codes[i] = codes[i].replace('_','')                                    print('Fail due to ' + Info.failreason)        Info.passfail = 'Fail'  # extra varibale for 1-line CS grids ]        Info.codes = Info.orig_codes.copy() # for CS go back to original codes        Info.codes2 = Info.orig_codes.copy() # 2-line also go back to original input codes        Info.en_codes = Info.orig_en_codes.copy() # for CS sheet go back to original codes        Info.referredcoursenames = ''        Info.deferredcoursenames = ''    return Info################################################################# get degree classification based on overall mark for finalyear students# also, include promotion if relevantdef get_degclass(Info):    # If not final year    if (Info.finalyear == False):        return Info    fail = 0  # Not a fail by default    demote = 0  # Not demoted by default (this is for deciding whether promotion cann be applied later)    creditspassed = Info.creditspassed  # credits passed for BSc    # get appropriate number of credits passed (must be level 3/4/6 courses from 2022 onwards)    if (Info.classyear != 4 and AY >= 2022): creditspassed = Info.credits34passed    else: creditspassed = Info.creditspassed            # if failed lab/project then is a fail - don't go through the logic further down    if (Info.faillabprog == True):        Info.honours  = 1        Info.degclass = -1        Info.fail     = True        Info.demote   = 0        Info.failreason = 'Failed lab/project/non-resittable unit'        return Info            # BSc or MPHys -> BSc    if (classyear == 32):                    if  creditspassed>=creditstogetBScgood and Info.overallmark>=boundaryfirst:            honours=1            degclass=4        elif creditspassed >= creditstogetBSclower and creditspassed <=creditstogetBScgood and Info.overallmark >= boundaryfirst:            honours = 1            degclass = 3            demote = 1        elif creditspassed>=creditstogetBScgood and Info.overallmark>=boundaryupper2 and Info.overallmark<boundaryfirst:            honours = 1            degclass = 3        elif creditspassed>=creditstogetBSclower and creditspassed <=creditstogetBScgood and Info.overallmark>=boundaryupper2 and Info.overallmark<boundaryfirst:            honours = 1            degclass = 2            demote = 1        elif creditspassed>=creditstogetBScgood and Info.overallmark>=boundarylower2 and Info.overallmark<boundaryupper2:            honours = 1            degclass = 2        elif creditspassed>=creditstogetBSclower and creditspassed<creditstogetBScgood and Info.overallmark>=boundarylower2 and Info.overallmark<boundaryupper2:            honours = 1            degclass = 1            demote = 1        elif creditspassed >= creditstogetBSclower and Info.overallmark >= boundarythird:            honours = 1            degclass = 1        elif creditspassed >= creditstogetBSclower:            honours =0            degclass=0            demote = 1        else: # Fail            honours=0            degclass=-1            fail = 1            demote = 1                # MPhys - from 2024 when only Y3+Y4 credits over the 2 years    if (Info.AY >= 2024 and classyear == 4):        # get number of passed credits over Y3+Y4        creditspassed34 = creditspassed + (120-Info.Y3creds_below40)        Info.creditspassed34 = creditspassed34                if  creditspassed34>=creditstogetMPHYS34 and Info.overallmark>=boundaryfirst:            honours=1            degclass=4        elif creditspassed34 >= creditstogetMPHYSlower34 and creditspassed34 <=creditstogetMPHYS34 and Info.overallmark >= boundaryfirst:            honours = 1            degclass = 3            demote = 1            Info.failreason = 'Not enough credits ({0:d}) over Y3/Y4'.format(creditspassed34)        elif creditspassed34>=creditstogetMPHYS34 and Info.overallmark>=boundaryupper2 and Info.overallmark<boundaryfirst:            honours = 1            degclass = 3        elif creditspassed34>=creditstogetMPHYSlower34 and creditspassed34 <=creditstogetMPHYS34 and Info.overallmark>=boundaryupper2 and Info.overallmark<boundaryfirst:            honours = 1            degclass = 2            demote = 1            Info.failreason = 'Not enough credits ({0:d}) over Y3/Y4'.format(creditspassed34)        elif creditspassed34>=creditstogetMPHYS34 and Info.overallmark>=boundarylower2 and Info.overallmark<boundaryupper2:            honours = 1            degclass = 2        else: # Fail            honours=0            degclass=-1            fail = 1            demote = 1            if (creditspassed34<=creditstogetMPHYSlower34): Info.failreason = 'Not enough credits ({0:d}) for MPhys over Y3/Y4'.format(creditspassed34)            # MPhys - for before 2024 when only considering Y4 credits    elif (Info.AY < 2024 and classyear == 4):        if  creditspassed>=creditstogetMPHYS and Info.overallmark>=boundaryfirst:            honours=1            degclass=4        elif creditspassed >= creditstogetMPHYSlower and creditspassed <=creditstogetMPHYS and Info.overallmark >= boundaryfirst:            honours = 1            degclass = 3            demote = 1        elif creditspassed>=creditstogetMPHYS and Info.overallmark>=boundaryupper2 and Info.overallmark<boundaryfirst:            honours = 1            degclass = 3        elif creditspassed>=creditstogetMPHYSlower and creditspassed <=creditstogetMPHYS and Info.overallmark>=boundaryupper2 and Info.overallmark<boundaryfirst:            honours = 1            degclass = 2            demote = 1        elif creditspassed>=creditstogetMPHYS and Info.overallmark>=boundarylower2 and Info.overallmark<boundaryupper2:            honours = 1            degclass = 2        else: # Fail            honours=0            degclass=-1            fail = 1            demote = 1    # Put back into Info    Info.honours  = honours    Info.degclass = degclass    Info.fail     = fail    Info.demote   = demote        return Info################################################################# Apply promotion to borderline students in final yeardef apply_promotion(Info):    if (Info.finalyear == False): # if not final year do not continue        return Info    # determine if borderline or not    if( (Info.overallmark >= borderfirst and Info.overallmark < boundaryfirst) or (Info.overallmark >= borderupper2 and Info.overallmark < boundaryupper2) or (Info.overallmark >= borderlower2 and Info.overallmark < boundarylower2) or (Info.overallmark>=borderthird and Info.overallmark<boundarythird)):        Info.borderline = True        Info.promote    = False    else:   # Just carry on if not borderline        Info.borderline = False        Info.promote = False        return Info    # do not continue if student has been demoted for not enough credits, continue    if (Info.demote == True): # (put here so borderline information is recorded above)        return Info            # If borderline see if can be promoted    if (Info.borderline == True):        # Apply algorithm A        if (Info.classyear == 32 or Info.classyear == 31):  # BSc or MPhys Y3 -> BSc            if(Info.degclass==3 and Info.credsatfirst>=creditstogetBScgood):                Info.promote=True            elif(Info.degclass==2 and Info.credsaboveupper2>=creditstogetBScgood):                Info.promote=True            elif(Info.degclass==1 and Info.credsabovelower2>=creditstogetBScgood):                Info.promote=True        else: # MPhys            if (Info.degclass == 3 and Info.credsatfirst >= creditstogetMPHYSalgA):                Info.promote = True            elif (Info.degclass == 2 and Info.credsaboveupper2 >= creditstogetMPHYSalgA):                Info.promote = True            elif (Info.degclass == 1 and Info.credsabovelower2 >= creditstogetMPHYSalgA):                Info.promote = True        # If A is successful, promote and return        if (Info.promote == True):            Info.promotetype = 'A'            Info.degclass += 1            return Info        # if A doesn't work, try algorithm B        if(Info.classyear == 32 or Info.classyear == 31):  # BSc or MPhys Y3 -> BSc            if(Info.degclass==3 and Info.credsatfirst >= creditstogetalgB and Info.projectmark>=boundaryfirst and Info.yearmark>Info.overallmark):                Info.promote=True            elif(Info.degclass==2 and Info.credsaboveupper2 >= creditstogetalgB and Info.projectmark>=boundaryupper2 and Info.yearmark>Info.overallmark):                Info.promote=True            elif(Info.degclass==1 and Info.credsabovelower2 >= creditstogetalgB and Info.projectmark>=boundarylower2 and Info.yearmark>Info.overallmark):                Info.promote=True        else: # MPhys            if (Info.degclass==3 and Info.credsatfirst >= creditstogetalgB and Info.projectmark>=boundaryfirst and Info.yearmark > Info.overallmark):                Info.promote = True            elif (Info.degclass==2 and Info.credsaboveupper2 >= creditstogetalgB and Info.projectmark>=boundaryupper2 and Info.yearmark > Info.overallmark):                Info.promote = True            elif (Info.degclass==1 and Info.credsabovelower2 >= creditstogetalgB and Info.projectmark>=boundarylower2 and Info.yearmark > Info.overallmark):                Info.promote = True        # If B is successful, promote and return        if (Info.promote == True):            Info.promotetype = 'B'            Info.degclass += 1            return Info            return Info################################################################# If not already promoted, try applying promotion to borderline students in final year using 2/3 of assessed credits (output P(A_X)/P(B_X) to indicate this# (see Judith email 30-Jun-2022)# For AY=2024 - do not make changes to degree but just output PA_X/PB_X in review for information only def apply_promotion_x(Info):    if (Info.finalyear == False or Info.demote == True):  # if not final year or has been demoted for not enough credits, continue        return Info    if (Info.promote == True):     # if already promoted, don't need to do anything        return Info        # determine if borderline or not    if( (Info.overallmark >= borderfirst and Info.overallmark < boundaryfirst) or (Info.overallmark >= borderupper2 and Info.overallmark < boundaryupper2) or (Info.overallmark >= borderlower2 and Info.overallmark < boundarylower2) or (Info.overallmark>=borderthird and Info.overallmark<boundarythird)):        Info.borderline = True        Info.promote    = False    else:   # Just carry on if not borderline        Info.borderline = False        Info.promote = False        return Info    # If borderline see if can be promoted    if (Info.borderline == True):        # get assessed credits only        assessedcredits = Info.creditstaken - Info.creditsexcluded # (this includes missing marks!)        creditstogetalgA_x = 0.6667 * assessedcredits        if (creditstogetalgA_x > 80): creditstogetalgA_x = 80  # don't have more than 80 (e.g. if taken 125+credits)                # Apply algorithm A        if (Info.classyear == 32):  # BSc            if(Info.degclass==3 and Info.credsatfirst>=creditstogetalgA_x):                Info.promote=True            elif(Info.degclass==2 and Info.credsaboveupper2>=creditstogetalgA_x):                Info.promote=True            elif(Info.degclass==1 and Info.credsabovelower2>=creditstogetalgA_x):                Info.promote=True        else: # MPhys            if (Info.degclass == 3 and Info.credsatfirst >= creditstogetalgA_x):                Info.promote = True            elif (Info.degclass == 2 and Info.credsaboveupper2 >= creditstogetalgA_x):                Info.promote = True            elif (Info.degclass == 1 and Info.credsabovelower2 >= creditstogetalgA_x):                Info.promote = True        # If A is successful, promote and return        if (Info.promote == True):            Info.promotetype = 'A_X'            Info.degclass += 1            # reset since this was only done for COVID in 2022            if (Info.AY >=2023):                Info.degclass -= 1                Info.promote = False # so not to change degree class                            return Info        creditstogetalgB_x = creditstogetalgA_x - 10   # -10 credits for alg B (usually 70 if no non-assessed courses)                # if A doesn't work, try algorithm B        if(Info.classyear == 32):  # BSc            if (Info.degclass==3 and Info.credsatfirst >= creditstogetalgB_x and Info.projectmark>=boundaryfirst and Info.yearmark>Info.overallmark):                Info.promote=True            elif (Info.degclass==2 and Info.credsaboveupper2 >= creditstogetalgB_x and Info.projectmark>=boundaryupper2 and Info.yearmark>Info.overallmark):                Info.promote=True            elif (Info.degclass==1 and Info.credsabovelower2 >= creditstogetalgB_x and Info.projectmark>=boundarylower2 and Info.yearmark>Info.overallmark):                Info.promote=True        else: # MPhys            if (Info.degclass==3 and Info.credsatfirst >= creditstogetalgB_x and Info.projectmark>=boundaryfirst and Info.yearmark > Info.overallmark):                Info.promote = True            elif (Info.degclass==2 and Info.credsaboveupper2 >= creditstogetalgB_x and Info.projectmark>=boundaryupper2 and Info.yearmark > Info.overallmark):                Info.promote = True            elif (Info.degclass==1 and Info.credsabovelower2 >= creditstogetalgB_x and Info.projectmark>=boundarylower2 and Info.yearmark > Info.overallmark):                Info.promote = True        # If B is successful, promote and return        if (Info.promote == True):            Info.promotetype = 'B_X'            Info.degclass += 1            # reset since this was only done for COVID in 2022            if (Info.AY >=2023):                Info.degclass -= 1                Info.promote = False # so not to change degree class                        return Info            return Info################################################################# convert degree class to a string for output grid# Also add extra variables for extra columnsdef degclass_to_string(Info):    # deg classification    degclass_dict = {        4:"1",        3:"2.1",        2:"2.2",        1:"3",        0:"Ord.",        -1:"Fail",        -2:"NOT SET!!!"}    # degree type    degstr = Info.Plan.split('(')[0]    degstr = ''.join(degstr.split()) # remove white space in degree plan (e.g. MMath & Phys)    degstr = degstr + ' ' # have a gap at the end ready for classification below    # Add to Info, with new class and also add promotion string     if (Info.promote == True):        Info.degclass_str = degstr + degclass_dict[Info.degclass-1] + ' P(' + Info.promotetype + ')'    else:        Info.degclass_str = degstr + degclass_dict[Info.degclass] #             # Add 3 extra columns (one is used for borderline students)    Info.degclass_alg = degstr + degclass_dict[Info.degclass]    Info.degclass_actual = degstr + degclass_dict[Info.degclass]        if (Info.borderline == True):        if (Info.promote == True):            Info.degclass_review = 'P' + Info.promotetype            Info.degclass_actual = degstr + degclass_dict[Info.degclass]    # actual is correct one                        # alg class depends on promotetype (A Uni-wide = algorithm, but B is department so should be original class)            if (Info.promotetype == 'A'):                Info.degclass_alg    = degstr + degclass_dict[Info.degclass]    # algorithmic is the correct one            elif (Info.promotetype == 'B'):                Info.degclass_alg    = degstr + degclass_dict[Info.degclass-1]    # algorithmic is the original one (so CS Override shows this)                    else:            Info.degclass_review = 'CR/marks'   # not promoted or inadequeate credits    if ('MA9' in Info.codes): Info.degclass_review += ' MA9'  # also add this code if exists (Judith request June 2023)    # since PA_X/PB_X is not algorithmic, do not change the degree (promote) but ensure PA_X/PB_X is outputted for information    if (Info.promote == False and Info.promotetype == 'A_X' or Info.promotetype == 'B_X'):        Info.degclass_review = 'P' + Info.promotetype            return Info################################################################# If MPhys fail, see if can get BSc based on Y1-Y3 marks# Also correct MPhys award/classification variables for CS 1-line formatdef degclass_MPhys_to_BSc(Info):    if (Info.classyear != 4 and Info.finalyear == False):        return Info        # If 4th year MPhys fail, output BSc based on Y1-Y3 marks     # Only fail if less than 2 years worth of marks    if (Info.fail == True):        Info2 = copy.deepcopy(Info)  # make temporary Info to trick functions that it is BSc not MPhys        Info2.classyear = 32    # Convert to a BSc student         plan = Info.Plan        Info2.Plan = plan.replace('BSc','MPhys') # Convert to a BSc student        if (Info.mathstudent == False): Info2.yearmark = Info.phys3   # 3rd year mark is now finalyear mark        else: Info2.yearmark = Info.year3mark                         # Average Phys/Math for M+P students        Info2.phys3 = -1              # set this back to -1        Info.math3  = -1              # set this back to -1        Info2 = get_overallmark(Info2,doCF)  # Get overall mark if CF available        newoverallmark = Info2.overallmark    # new overall mark        Info.newoverallmark = round(newoverallmark+0.00001,1)  # add to Info        if (newoverallmark>boundaryfirst):            Info.degclass_str = 'BSc 1' + ' (' + str(newoverallmark) + '%)'            Info.degclass_alg = 'BSc 1'            Info.degclass = 4            Info.honours = 1            Info.degclass_review = Info.degclass_str            Info.degclass_actual = Info.degclass_alg        elif (newoverallmark>boundaryupper2):            Info.degclass_str = 'BSc 2.1' + ' (' + str(newoverallmark) + '%)'            Info.degclass_alg = 'BSc 2.1'            Info.degclass = 3            Info.honours = 1            Info.degclass_review = Info.degclass_str            Info.degclass_actual = Info.degclass_alg        elif (newoverallmark>boundarylower2):            Info.degclass_str = 'BSc 2.2' + ' (' + str(newoverallmark) + '%)'            Info.degclass_alg = 'BSc 2.2'            Info.degclass = 2            Info.honours = 1            Info.degclass_review = Info.degclass_str            Info.degclass_actual = Info.degclass_alg        elif (newoverallmark>boundarythird):            Info.degclass_str = 'BSc 3' + ' (' + str(newoverallmark) + '%)'            Info.degclass_alg = 'BSc 3'            Info.degclass = 2            Info.honours = 1            Info.degclass_review = Info.degclass_str            Info.degclass_actual = Info.degclass_alg        else:            Info.degclass_str = 'Fail'            Info.degclass_alg = 'Fail'            Info.degclass = -1            Info.degclass_review = Info.degclass_str            Info.degclass_actual = Info.degclass_alg            Info.honours = 0                # Reset fail/fail reason as necessary        if (Info.degclass_str.lower().find('fail') >=0):            Info.fail = True            Info.failreason = 'Fail BSc (< 40%)'            Info.finalyear = True  # to ensure sorting of students is done correctly at the end        elif (Info.faillabprog == True): # to catch MPhys -> BSc with failed lab/project            Info.fail = True            Info.failreason = 'Fail lab/project -> BSc'            Info.finalyear = True  # to ensure sorting of students is done correctly at the end        else:            Info.fail = False            Info.finalyear = True  # to ensure sorting of students is done correctly at the end        # Check that there are at least 2 years of marks otherwise it is still a fail (chat with Judith 30-Jun-2022)        markyears = [Info.phys1, Info.phys2, Info.phys3]        idx = [i for i, x in enumerate(markyears) if x < 0]        if (len(idx) > 1):            Info.fail = True            Info.failreason = '(<2 years BSc marks)'            Info.degclass_str = 'Fail ' + Info.failreason            Info.degclass_alg = 'Fail'            Info.degclass_review = Info.degclass_str            Info.degclass_actual = Info.degclass_alg                return Info################################################################# set correct award/class variables (for CS 1 line format only)# has to be after all promotion and MPhys -> BSc considerationsdef add_CS_award_class(Info):    # get the award from the degclass_alg since this is correct in most cases    # including P(B) promotions because this shows the lower class    # (P(B) have to have entries in override award/classification dealt with later)    s_alg = Info.degclass_alg.split()   #algorithmic    s_actual = Info.degclass_actual.split() # actual (used for PB promotion)    if (len(s_alg) >= 2):        award = s_alg[0].upper()        award2 = s_actual[0].upper()        classification = s_alg[-1]        classification2 = s_actual[-1]        passfail = 'Pass'    elif (len(s_alg) == 1):        award = s_alg[0].upper()        award2 = s_actual[0].upper()        classification = 'P' # (it will likely be a pass for DIPHE (BSc) or BSc (MPhys)        classification2 = 'P'        passfail = 'Fail'    else:        award = ''        award2 = ''        classification = ''        classification2 = ''        passfail = ''            # add 'HONS" back for award if honours degree    if (Info.fail == False and Info.honours == 1 and award != ''):        award += 'HONS'    # If fail/DIPHE    if (Info.fail == 1 and Info.degclass < 0):        award    = 'DIPHE'        award2   = 'DIPHE'        classification = 'P'        classification2 = 'P'        passfail = 'Fail'    if (award.lower().find('fail') >=0):        classification = 'F'        classification2 = 'F'            # Put back into Info    Info.award          = award    # alg award    Info.award2         = award2   # actual award for when actual award upgraded (e.g. PB promotion)    Info.classification = classification   # alg classification    Info.classification2 = classification2 # for when actual award upgraded (e.g. PB promotion)    Info.passfail       = passfail    # Add new variables for making award/classification column for only when they change (For CS override columns in case of PB)    #Info.award_change = ''  # deafult is empty    #Info.classification_change = ''  # default is empty    #if (Info.degclass_alg != Info.degclass_actual):    #    s_alg = Info.degclass_alg.split()    #    s_actual = Info.degclass_actual.split()    #    if (len(s_alg) >= 2): # assumes of the form e.g. "MPhys 1"     #        if (s_alg[0] != s_actual[0]): Info.award_change = s_actual[0]    #        if (s_alg[1] != s_actual[1]): Info.classification_change = s_actual[1]    #    else: # just output it to be sure even if not correct format    #        Info.award_change = s_actual    #        Info.classification_change = s_actual                return Info################################################################# get extremes (lo/hi marks) to account for missing marks# This is to see if major change in degree when lots of missing marks for marking buycott (2023)# should be run first before get_yearmark etc. which gets correct final values firstdef get_extremes(Info, doCF, do_extremes):    # if do_extremes not set, do nothing    if (do_extremes == False):        return Info    # if student away (e.g. PP) don't calculate extremes and just return blanks    if (Info.PPaway == True or Info.interrupt == True):        Info.overall_extremes_str = ''        return Info        # Record original arrays to back later    orig_marks       = Info.marks.copy()        # Keep original marks     orig_credweights = Info.credweights.copy()  # Keep original credweights (0 for excluded)        # first, do not exclude missing marks    for idx in Info.nomarks_idx:        if (idx in Info.excluded_idx):            Info.excluded_idx.remove(idx)            Info.credweights[idx] = Info.credits[idx]   # this is ok post 2022 because no 0 credit options    # For PP students, ensure that PP previous mark *is* excluded! PHYS30810 (120) from this calculation!!!    # in fact, just ignore any course worth > 100 credits which will catch these!    idx = [i for i, c in enumerate(Info.credits) if c > 100] # indices of any course with >100 credits!    for i in idx:        Info.excluded_idx.append(i)  # exclude again for these extreme cases        Info.credweights[i] = 0      # give 0 weight to be sure                missing_marks = [0,100]   # extreme values to consider (0% and 100% for missing marks)    # Calculate year lo/hi average, putting back original value at the end!    for i in range(2):  # loop over lo/hi ranges        missing_mark = missing_marks[i]   # mark to replace missing marks with        for idx in Info.nomarks_idx:            Info.marks[idx] = missing_mark  # temporarily replace missing marks        # get yearmarks etc.        Info = get_yearmark(Info)          Info = get_mp_yearmark(Info)        if (Info.dooverall == True): Info = get_overallmark(Info,doCF)        # store into separate variables        if (i == 0):            Info.yearmark_lower = Info.yearmark            if (Info.dooverall == True): Info.overallmark_lower = Info.overallmark        elif (i == 1):            Info.yearmark_upper = Info.yearmark            if (Info.dooverall == True): Info.overallmark_upper = Info.overallmark    # Put original marks, cred weights etc. back to info (yearmark, overallmark etc will be replaced anyway later)    Info.marks       = orig_marks    Info.credweights = orig_credweights        # Put in new combined string ready for output    Info.yearmark_extremes_str = str(Info.yearmark_lower) + ' -> ' + str(Info.yearmark_upper)    if (Info.dooverall == True):        if ( (Info.overallmark_upper - Info.overallmark_lower) < 0.05):            Info.overallmark_extremes_str = 'OK'        else:            Info.overallmark_extremes_str = str(Info.overallmark_lower) + ' -> ' + str(Info.overallmark_upper)            return Info################################################################# if (do_extremes == True) check that extremes don't make a major change# record if they do and highlight later on outputdef check_extremes(Info,do_extremes):    # if do_extremes not, set do nothing    if (do_extremes == False):        return Info        # If student away (e.g. PP or interrupting) set marks to blanks    if (Info.PPaway == True or Info.interrupt == True):        Info.overallmark_lohi = ''        return Info        # compare overall mark    if (Info.dooverall == True and (Info.finalyear == True or Info.classyear == 31)):        #boundary_low_overall = min(70.0,max(40.0, (Info.overallmark // 10)*10)) - 0.05 # overall mark rounded down to nearest 10 (40 max)        #boundary_high_overall = min(70.0,round(Info.overallmark/10)*10.) - 0.05 # overall mark rounded down to nearest 10 (70 max)        boundary_low_overall = min(70.,max(40.0, (Info.overallmark // 10)*10)) - 0.05 # overall mark rounded down to nearest 10 (40 max)        boundary_high_overall = max(40.,round(Info.overallmark/10)*10.) - 0.05 # overall mark rounded down to nearest 10 (70 max)        if (boundary_high_overall == boundary_low_overall and boundary_low_overall < 60.): # ensure higher is +10 higher excpet if 69.95            boundary_high_overall += 10  # need next one                # take into account borders (assume 3%/4% as for 2020-2023)        if (Info.AY >= 2020 and Info.AY <= 2023):            border_low_overall = boundary_low_overall - 3   # 3% borders            border_high_overall = boundary_high_overall- 3  # 3% borders        else:            border_low_overall = boundary_low_overall - 2   # 2% borders            border_high_overall = boundary_high_overall- 2  # 2% borders        if (border_low_overall < 40):  border_low_overall -= 1  # extra 1% on the lowest border        if (border_high_overall < 40): border_high_overall -= 1  # extra 1% on the lowest border                    if ((Info.overallmark_upper - Info.overallmark_lower) < 0.05):  # If the same no problem            Info.overallmark_lohi = ''        elif (Info.overallmark_lower < (boundary_low_overall) and Info.overallmark > 39.95): # only if mark is <40            Info.overallmark_lohi = 'low'        elif (Info.overallmark_upper > border_high_overall and Info.overallmark < 69.95): # only if less than 1st to begin with            Info.overallmark_lohi = 'high'                    else:            Info.overallmark_lohi = ''                return Info################################################################# Check status from input ("AS Code") and compare with PyAssess/overridedef check_status(Info):    # check against PyAssess status    if (Info.AScode == 'ACTV' and Info.status != 'ACTV'):        print('*WARNING: AScode ({0:s}) and Status ({1:s}) do not agree'.format(Info.AScode,Info.status))    #elif (Info.AScode == 'REVW' and Info.status != 'REVW'):    #    print('*WARNING: AScode ({0:s}) and Status ({1:s}) do not agree'.format(Info.AScode,Info.status))                # replace codes for some circumstances    if (Info.AScode == 'COMP'): # completed and already given degree award        Info.status = 'Completed'    elif (Info.AScode == 'LEFT' or Info.AScode == 'EXCL' or Info.AScode == 'EXIT'):  # withdrawn        Info.status = 'Withdrawn'        Info.withdrawn = True            elif (Info.AScode == 'RFYR' or Info.AScode == 'RYIA' or Info.AScode == 'RYOA'):  # repeat year (interrupting)        Info.interrupt = True    elif (Info.AScode == 'ACTR' or Info.AScode == 'MACT' or Info.AScode == 'PCFL' or Info.AScode == 'SPCL'): # ignore these        return Info            return Info################################################################# Check yearmark against input grid (if available)def check_overallmarks(Info):    # get input yearmark if available    if (Info.classyear == 1):       Info.input_yearmark = Info.L1CM    elif (Info.classyear == 2):        Info.input_yearmark = Info.L2CM    elif (Info.classyear == 31 or Info.classyear == 32):        Info.input_yearmark = Info.L3CM    elif (Info.classyear == 4):        Info.input_yearmark = Info.L4CM    # compare yearmark against PyAssess if available    if (Info.yearmark >=0 and Info.input_yearmark >=0):        diff = Info.input_yearmark - Info.yearmark        if (np.abs(diff) > 0.05):            Info.yearmark_not_consistent = True            print('*WARNING: Yearmark ({0:.1f}) does not agree with input ({1:.1f})'.format(Info.yearmark,Info.input_yearmark))            if (np.abs(diff) < 0.11):                Info.yearmarkout = Info.yearmarkout + '*' + '{0:+.2f}'.format(diff)            else:                Info.yearmarkout = Info.yearmarkout + '**' + '{0:+.1f}'.format(diff)                                    # compare overllmark against PyAssess if available    if (Info.overallmark >=0 and Info.input_overallmark >=0):        diff = Info.input_overallmark - Info.overallmark        if (np.abs(diff) > 0.05):            Info.overallmark_not_consistent = True            print('*WARNING: Overallmark ({0:.1f}) does not agree with input ({1:.1f})'.format(Info.overallmark,Info.input_overallmark))            if (np.abs(diff) < 0.11):                Info.overallmarkout = Info.overallmarkout + '*' + '{0:+.2f}'.format(diff)            else:                Info.overallmarkout = Info.overallmarkout + '**' + '{0:+.1f}'.format(diff)                return Info################################################################# Check degree award/classification againt input grid (if available)def check_deg_award(Info):    if (Info.finalyear == False):  # if not final year do nothing        return Info        # compare degree award    if ((Info.award.lower() not in Info.input_award.lower()) and (Info.input_award.lower() not in Info.award.lower()) ):        Info.award_not_consistent = True        Info.degclass_alg = Info.degclass_alg + '**'        print('*WARNING: Degree award ({0:s}) does not agree with input ({1:s})'.format(Info.award,Info.input_award))            # compare degree classification    if (Info.classification.lower() not in Info.input_classification.lower()):        if (Info.input_classification.lower().find('xxx') >=0 and Info.degclass_alg.lower().find('fail') >=0): # if 'XXX' its equivalent to a fail            pass        else:            Info.classification_not_consistent = True            Info.degclass_alg = Info.degclass_alg + '**'            print('*WARNING: Degree classification ({0:s}) does not agree with input ({1:s})'.format(Info.classification,Info.input_classification))                return Info################################################################# cleanup PP/study in Europe/abroad status/deg/overall mark if not avaialble# also use this to blank/cleanup students with unknown codes/circumstancesdef cleanup_nomark_students(Info):    # If no courses listed at all so no credits taken, don't show averages/fail    if (Info.creditstaken <= 0):        Info.degclass_str = ''        Info.degclass_alg = ''        Info.degclass_review = ''        Info.degclass_actual = ''        Info.status = 'No marks'        Info.failreason = ''        Info.yearmark = -1        Info.overallmark = -1    # If clearly a lot of missing marks, don't show fail    if (Info.creditstaken <= 80):        Info.degclass_str = ''        Info.degclass_alg = ''        Info.degclass_review = ''        Info.degclass_actual = ''        Info.status = ''        Info.failreason = 'Many marks (>=40 credits) missing!'            # If PP with no final year marks but still may have a coursename in the list with credit    # check for PHYS30810 rather than PP for PP students because if they fail, no longer a PP student!    if (Info.PHYS30810 == True and Info.PPaway == True):        Info.degclass_str = 'Intercal'        Info.degclass_alg = 'Intercal'        Info.degclass_review = ''        Info.degclass_actual = 'Intercal'        Info.award = ''        Info.award2 = ''        Info.classification = ''        Info.classification2 = ''        Info.status = 'Intercal'        Info.fail = False        Info.failreason = ''        Info.overallmark = -1        Info.codes = Info.orig_codes.copy() # keep codes on CS sheet        Info.codes2 = ['']*len(Info.codes)     # clear codes on 2-line input        Info.en_codes = Info.orig_en_codes.copy() # Original EN codes            # If study abroad/PP and have PHYS31000/PHYS41000 with no marks, indicate in output as "Intercal" (Judith email 01-Jul-2022)    #abroadunits_idx = np.array([i for i, names in enumerate(Info.coursenames) if ('PHYS31000' in names or 'PHYS41000' in names or 'PHYS30810' in names or 'PHYS40810' in names)])    abroadunits_idx = np.array([i for i, names in enumerate(Info.coursenames) if ('PHYS31000' in names or 'PHYS41000' in names or 'PHYS40810' in names)])    if (len(abroadunits_idx) > 0):        marks = np.array(Info.marks)        markstotal = np.sum(marks[abroadunits_idx])        if (markstotal < 0):            Info.degclass_str = '' #'Intercal'            Info.status = 'Intercal'            Info.degclass_alg = '' # 'Intercal'            Info.degclass_review = '' # 'Intercal'            Info.fail = False            Info.failreason = ''            Info.overallmark = -1            Info.overallmark_lohi = '' # to prevent a box appearing            Info.overallmark_extremes_str = ''  # to ensure blank            Info.codes = Info.orig_codes.copy()  # keep codes on CS sheet            Info.codes2 = ['']*len(Info.codes)     # clear codes on 2-line input            Info.en_codes = Info.orig_en_codes.copy() # Original EN codes                # If known to be interrupting do not calculate year/overall mark/degree classification etc. and mark as interrupting    if (Info.interrupt == True):        Info.degclass_str = 'Interrupt'        Info.status       = 'Interrupt'        Info.degclass_alg = 'Interrupt'        Info.degclass_review = ''        Info.degclass_actual = 'Interrupt'        Info.award = ''        Info.award2 = ''        Info.classification = ''        Info.classification2 = ''        Info.fail         = False        Info.failreason   = ''        Info.yearmark     = -1 # to ensure students are at the bottom of the grid        Info.overallmark  = -1 # to ensure all at bottom of grid        Info.referredcoursenames = ''        Info.deferredcoursenames = ''        Info.codes = Info.orig_codes.copy()    # keep codes on CS sheet        Info.codes2 = ['']*len(Info.codes)     # clear codes on 2-line input        Info.en_codes = Info.orig_en_codes.copy() # Original EN codes    # If in the "for manual completion" list due to insufficient/ioncorrect information, mark and blank     if (Info.manual == True):        Info.degclass_str = ''        Info.status       = ''        Info.degclass_alg = ''        Info.degclass_review = ''        Info.degclass_actual = ''        Info.award = ''        Info.award2 = ''        Info.classification = ''        Info.classification2 = ''        Info.fail         = False        Info.failreason   = 'For manual completion (insufficient/incorrect info)'        Info.yearmark     = -1 # to ensure students are at the bottom of the grid        Info.overallmark  = -1 # to ensure all at bottom of grid        Info.referredcoursenames = ''        Info.deferredcoursenames = ''        Info.codes = Info.orig_codes.copy()  # keep codes on CS sheet (blank anyway)        Info.codes2 = Info.orig_en_codes.copy()  # keep codes on 2-line sheet as well for info        Info.en_codes = Info.orig_en_codes.copy() # Original EN codes    if (Info.withdrawn == True):        Info.degclass_str = ''        Info.status       = 'Withdrawn'        Info.degclass_alg = ''        Info.degclass_review = ''        Info.degclass_actual = ''        Info.award = ''        Info.award2 = ''        Info.classification = ''        Info.classification2 = ''        Info.fail         = False        Info.failreason   = 'Withdrawn'        Info.yearmark     = -1 # to ensure students are at the bottom of the grid        Info.overallmark  = -1 # to ensure all at bottom of grid        Info.referredcoursenames = ''        Info.deferredcoursenames = ''        Info.codes = Info.orig_codes.copy()  # keep codes on CS sheet (blank anyway)        Info.codes2 = Info.orig_en_codes.copy()  # keep codes on 2-line sheet as well for info        Info.en_codes = Info.orig_en_codes.copy() # Original EN codes            # ***Temporarily blank out columns where we don't understand the codes (yet!) and make a note for the pre-board    # Only for Y1/Y2 2023 and not resits    unknown_codes = ['ror', 'rof', 'rwf', 'r2', 'l1c', 'r1']    #codes = Info.orig_codes.copy()    if (AY==2023 and Info.resitgrid == False):        codes = Info.orig_en_codes.copy()  # for now go back to original input codes to identify RoR etc.        codes = [x.lower() for x in codes]        j = 0 # counter        for ucode in unknown_codes:            if ucode in codes:                Info.manual = True   # so can output list at the end                Info.status = ''                Info.yearmark = -1                Info.overallmark = -1                Info.referredcoursenames = ''                Info.deferredcoursenames = ''                Info.codes = Info.orig_codes.copy()  # keep codes on CS sheet (blank anyway)                Info.codes2 = Info.orig_en_codes.copy()  # keep codes on 2-line sheet as well for info                Info.en_codes = Info.orig_en_codes.copy() # Original EN codes                # output string with code(s)                if (j == 0):                    Info.failreason = 'For manual completion: contains {0:s}'.format(ucode.upper())                else:                    Info.failreason += ', ' + ucode.upper()                j += 1  # add to counter                # or if repeating, blank out columns for manual completion    if (Info.repeating == True):        Info.status = ''        Info.yearmark = -1        Info.overallmark = -1        Info.failreason = 'For manual completion (repeating student)'        Info.referredcoursenames = ''        Info.deferredcoursenames = ''        Info.codes = Info.orig_codes.copy()  # keep codes on CS sheet (blank anyway)        Info.codes2 = Info.orig_codes.copy()  # keep codes on CS sheet         Info.en_codes = Info.orig_en_codes.copy() # Original EN codes            return Info################################################################# cleanup "manual" students def cleanup_manual_students(Info):    # If in the "for manual completion" list due to insufficient/ioncorrect information, mark and blank     if (Info.manual == True):        Info.degclass_str = ''        Info.status       = ''        Info.degclass_alg = ''        Info.degclass_review = ''        Info.degclass_actual = ''        Info.award = ''        Info.award2 = ''        Info.classification = ''        Info.classification2 = ''        Info.fail         = False        Info.failreason   = 'For manual completion (insufficient/incorrect info)'        Info.yearmark     = -1 # to ensure students are at the bottom of the grid        Info.overallmark  = -1 # to ensure all at bottom of grid        Info.referredcoursenames = ''        Info.deferredcoursenames = ''        Info.codes = Info.orig_codes.copy()  # keep codes on CS sheet (blank anyway)        Info.codes2 = Info.orig_en_codes.copy()  # keep codes on 2-line sheet as well for info        Info.en_codes = Info.orig_en_codes.copy() # Original EN codes            return Info################################################################# make basic output dataframe including extra columns CS format def make_output_df():    # make list of all possible definite columns (more will be added later)    columns = ['ID No.', 'Emplid', 'Emplid*','Name', 'Admit Term', 'Plan',                'Unit 1', 'Code 1',                'Unit 2', 'Code 2',                'Unit 3', 'Code 3',                'Unit 4', 'Code 4',                'Unit 5', 'Code 5',                'Unit 6', 'Code 6',                'Unit 7', 'Code 7',                'Unit 8', 'Code 8',                'Unit 9', 'Code 9',                'Unit 10', 'Code 10',                'Unit 11', 'Code 11',                'Unit 12', 'Code 12',                'Unit 13', 'Code 13',                'Unit 14', 'Code 14',                'Unit 15', 'Code 15',                'Unit 16', 'Code 16',                'Unit 17', 'Code 17',                'Unit 18', 'Code 18',                'Unit 19', 'Code 19',                'Unit 20', 'Code 20',                'Credits Taken', 'Credits Passed', 'Credits Failed', 'Year Mark', 'Overall', 'Status', 'Resits', 'Referred', 'Deferred', 'Mit Circ']    # make dataframe    df = pd.DataFrame(columns=columns)    return df################################################################# add column data from this student (Info) to the output student dataframe# also output other columns used for CS format laterdef add_data_df(df,Info,doCF,encode_sids):    # First few columns    if (encode_sids == True):        new_row1 = {'ID No.': [Info.IDnumber], 'Emplid': [Info.emplid], 'Emplid*': [Info.emplid_encoded]}        new_row2 = {'ID No.': [''], 'Emplid': [''], 'Emplid*': ['']}    elif (Info.anonymous == False):        new_row1 = {'ID No.': [Info.IDnumber], 'Emplid': [Info.emplid]}        new_row2 = {'ID No.': [''], 'Emplid': ['']}    else:        new_row1 = {'ID No.': [Info.IDnumber], 'Emplid*': [Info.emplid_encoded]}        new_row2 = {'ID No.': [''], 'Emplid*': ['']}    # remove ID No. if blank (i.e. no ID number in input)    if (Info.IDnumber == ''):        del new_row1['ID No.']        del new_row2['ID No.']            # Next set of columns before units    new_row1['Name'] = [Info.Name]    new_row1['Admit Term'] = [Info.admitterm]    new_row1['Plan'] = [Info.Plan]    new_row2['Name'] = ['']    new_row2['Admit Term'] = ['']    new_row2['Plan'] = ['']            # Add each unit that exists - 2 columns per unit (mark and code)    for i in range(len(Info.coursenamesout)):        unit_str = 'Unit ' + str(i+1)        unitcode_str = 'Code ' + str(i+1)        new_row1[unit_str] = [Info.coursenamesout[i]]        new_row2[unit_str] = [Info.marksout[i]]      # Just mark with 2 column output        new_row1[unitcode_str] = ['']        new_row2[unitcode_str] = [Info.codes2[i]]    # Use codes2 for 2-Line output which has some slightly different codes                # Also Add extra columns required for CS format (on the 1st line of each student, 2nd line keep blank and will be removed later)        mark_str = 'Mark ' + str(i+1)        encode_str = 'EN ' + str(i+1)        mitcircs_str = 'Mit Circs ' + str(i+1)        new_row1[mark_str] = [Info.marksout[i]]       # Mark        new_row2[mark_str] = ['']        new_row1[encode_str] = [Info.en_codes[i]]    # EN codes from the input grid (for output to CS sheet later)        new_row2[encode_str] = ['']        new_row1[mitcircs_str] = [Info.codes[i]]   # Mit Circs (read in from separate MCC file)        new_row2[mitcircs_str] = ['']    # Rest of default columns    new_row1['Creds Taken']      = [Info.creditstaken]    new_row1['Creds Passed']     = [Info.creditspassed]    new_row1['Creds Failed']     = [Info.creditsfailed]    new_row1['Creds Passed/Taken'] = [str(Info.creditspassed) + ' / ' + str(Info.creditstaken)]    new_row1['Credits Taken']      = [Info.creditstaken]    new_row1['Credits Passed']     = [Info.creditspassed]    new_row1['Credits Failed']     = [Info.creditsfailed]    new_row1['Phys/Math Creds Taken'] = [Info.creditstaken_pm]    new_row1['Creds 1']          = [Info.credsatfirst]    new_row1['Creds 2.1']          = [Info.credsatupper2]    new_row1['Creds 2.2']          = [Info.credsatlower2]    new_row1['Creds 3']          = [Info.credsatthird]    new_row1['Creds CF']          = [Info.credsatCF]    new_row1['Creds Total']        = [Info.creditstaken-Info.creditsexcluded]    new_row1['Phys Year Mark']     = [Info.phys_yearmark]    new_row1['Math Year Mark']     = [Info.math_yearmark]    new_row1['Year Mark']          = [Info.yearmarkout]    new_row1['Year Av O/P/M']      = [Info.year_opm]    new_row1['Status']             = [Info.status]    new_row1['Mit Circ']           = [Info.mitcirc]    new_row1['Referred']           = [Info.referredcoursenames.rstrip(' / ')]    new_row1['Deferred']           = [Info.deferredcoursenames.rstrip(' / ')]    new_row1['Fail']               = [Info.fail]    new_row1['Pass / Fail']        = [Info.passfail]    new_row1['Fail reason']        = [Info.failreason]    if (Info.referredcoursenames == ''): # this is to ensure no trailing forward slash        new_row1['Resits']         = [Info.deferredcoursenames.rstrip(' / ')]    else:        new_row1['Resits']         = [Info.deferredcoursenames + Info.referredcoursenames.rstrip(' / ')]    new_row1['Notes']              = [Info.boundary_notes + Info.flagCF_notes]  # add both together even though usually just one    new_row1['Exam Board Minutes'] = ['']         new_row2['Creds Taken']        = ['']    new_row2['Creds Passed']       = ['']    new_row2['Creds Passed/Taken'] = ['']    new_row2['Creds Failed']       = ['']    new_row2['Credits Taken']      = ['']    new_row2['Credits Passed']     = ['']    new_row2['Credits Failed']     = ['']    new_row2['Phys/Math Creds Taken'] = ['']    new_row2['Creds 1']            = ['']    new_row2['Creds 2.1']          = ['']    new_row2['Creds 2.2']          = ['']    new_row2['Creds 3']            = ['']    new_row2['Creds CF']           = ['']    new_row2['Creds Total']        = ['']    new_row2['Phys Year Mark']     = ['']    new_row2['Math Year Mark']     = ['']    new_row2['Year Mark']          = ['']    new_row2['Year Av O/P/M']      = ['']    new_row2['Status']             = ['']    new_row2['Mit Circ']           = ['']    new_row2['Referred']           = ['']    new_row2['Deferred']           = ['']    new_row2['Fail']               = ['']    new_row2['Pass / Fail']        = ['']    new_row2['Fail reason']        = ['']    new_row2['Resits']             = ['']    new_row2['Notes']              = ['']    new_row2['Exam Board Minutes'] = ['']        # CF info if available    new_row1['L1CM']         = [Info.L1CM]    new_row1['L2CM']         = [Info.L2CM]    new_row1['L3CM']         = [Info.L3CM]    new_row1['L4CM']         = [Info.L4CM]    new_row1['Phys 1']         = [Info.phys1]    new_row1['Phys 2']         = [Info.phys2]    new_row1['Phys 3']         = [Info.phys3]    new_row1['Math 1']         = [Info.math1]    new_row1['Math 2']         = [Info.math2]    new_row1['Math 3']         = [Info.math3]    new_row1['Overall']        = [Info.overallmarkout]    new_row1['Phys Overall']   = [Info.overallphysmark]    new_row1['Math Overall']   = [Info.overallmathmark]    new_row1['Overall O/P/M']  = [Info.overallmark_opm]    new_row2['L1CM']           = ['']    new_row2['L2CM']           = ['']    new_row2['L3CM']           = ['']    new_row2['L4CM']           = ['']    new_row2['Phys 1']         = ['']    new_row2['Phys 2']         = ['']    new_row2['Phys 3']         = ['']    new_row2['Math 1']         = ['']    new_row2['Math 2']         = ['']    new_row2['Math 3']         = ['']    new_row2['Overall']        = ['']    new_row2['Phys Overall']   = ['']    new_row2['Math Overall']   = ['']    new_row2['Overall O/P/M']  = ['']    if (Info.finalyear == True):  # Final year students        new_row1['Honours']               = [Info.honours]        new_row1['Deg']                   = [Info.degclass]        new_row1['Deg Class']             = [Info.degclass_str]        new_row1['Deg Class Alg']         = [Info.degclass_alg]        new_row1['Deg Class Rev']         = [Info.degclass_review]        new_row1['Deg Class Actual']      = [Info.degclass_actual]  # same as alg except for promotetype B        new_row1['Award']                 = [Info.award] # *algorithmic* award        new_row1['Classification']        = [Info.classification] # *algorithmic* classification        new_row1['Award Alg']             = [''] #  will be an Excel formula        new_row1['Classification Alg']    = [''] # will be an Excel formula        new_row1['Award Actual']          = [''] # will be an Excel formula        new_row1['Classification Actual'] = [''] # will be an Excel formula        new_row1['']                      = ['']        new_row1['Award Change']          = [''] # will be an Excel formula        new_row1['Classification Change'] = [''] # will be an Excel formula                        new_row2['Honours']         = ['']        new_row2['Deg']             = ['']        new_row2['Deg Class']       = ['']        new_row2['Deg Class Alg']   = ['']        new_row2['Deg Class Rev']   = ['']        new_row2['Deg Class Actual']= ['']        new_row2['Award']           = ['']        new_row2['Classification']  = ['']        new_row2['Award Alg'] = ['']        new_row2['Classification Alg'] = ['']         new_row2['Award Actual']      = ['']         new_row2['Classification Actual'] = ['']        new_row1['']                  = ['']        new_row2['Award Change']      = [''] # will be an Excel formula        new_row2['Classification Change'] = [''] # will be an Excel formula    if (Info.classyear == 31): # Keep award/classification in for Y3 progressing as they not progress and get  BSc        new_row1['Award']                 = [''] # (but will be empty for this anyway ready for manual editing at exam board)        new_row2['Award']                 = ['']        new_row1['Classification']        = [''] # (but will be empty for this anyway ready for manual editing at exam board))        new_row2['Classification']        = ['']            if (Info.classyear == 4 and Info.mathstudent == True) : # for 4th M+P students        new_row1['Year 3']         = [Info.year3mark]        new_row2['Year 3']         = ['']    # level 3/4 credits passed for Y3/Y4 students (only for AY=2022)    if (Info.AY >= 2022 and (Info.classyear == 31 or Info.classyear == 32 or Info.classyear == 4)):        new_row1['L3/L4 creds passed'] = [str(Info.credits3passed) + ' + ' + str(Info.credits4passed) + ' = ' + str(Info.credits34passed)]        new_row2['L3/L4 creds passed'] = ['']    # Y3 credits below 40    if (Info.AY >= 2024 and Info.classyear == 4):        new_row1['Y3 creds failed'] = [Info.Y3creds_below40]        new_row2['Y3 creds failed'] = ['']            # if available add in extreme lo/hi yearmark/overall mark    if (Info.dooverall == True and (Info.finalyear == True or Info.classyear==31)):        try:            new_row1['Year Mark lo/hi'] = [Info.yearmark_extremes_str]            new_row1['Overall lo/hi'] = [Info.overallmark_extremes_str]            new_row1['Overall lohi']    = [Info.overallmark_lohi]            new_row2['Year Mark lo/hi'] = ['']            new_row2['Overall lo/hi'] = ['']            new_row2['Overall lohi']    = ['']        except:            pass    # Other rows (e.g. for CS grid)    new_row1['MC'] = Info.mc    new_row2['MC'] = ['']            # If a resit grid then blank some of the marks/final columns on the 2nd row    if (Info.resitgrid == True):        blank_columns = ['Status','Resits']        for col in blank_columns:            new_row1[col] = ['']            new_row2[col] = ['']                # add the new rows to the df    new_row1 = pd.DataFrame(data=new_row1)    new_row2 = pd.DataFrame(data=new_row2)    df = pd.concat([df,new_row1,new_row2], ignore_index=True, sort=False)        return df################################################################# Get maximum unit number used in a dataframe that actually contains datadef get_maxunit_number(df):    maxunit = 0  # counter    for i in range(20):  # max units will be 20        unit_str = 'Unit ' + str(i+1)        data     = df[unit_str].tolist()   # data for this unit number        if (any(data) == True): # check if any non-empty strings            maxunit += 1        return maxunit################################################################# Set output columns for output spreadsheet depending on student type/yeardef set_output_columns(Info,maxunit,doCF):    # First few columns are same for all (no Name if anonymous)    if (encode_sids == True):        columns = ['Emplid*', 'Emplid', 'Name', 'Plan']    elif (Info.anonymous == False):        columns = ['Emplid', 'Name', 'Plan']    else:        columns = ['Emplid*', 'Plan']    # if ID No. exists then add it as 1st column    if (Info.IDnumber != ''):        columns.insert(0,'ID No.')        # Units where data exist    for i in range(maxunit):        unit_str = 'Unit ' + str(i+1)        unitcode_str = 'Code ' + str(i+1)        columns.append(unit_str)        columns.append(unitcode_str)    # Credits passed/taken    columns.append('Creds Passed/Taken')  # combined column to save space    # Level 3/4 credits passed for Y3/Y4 students (for 2022 onwards)    if (Info.AY >= 2022):        if (classyear == 31 or classyear == 32 or classyear == 4): columns.append('L3/L4 creds passed')    # Y3 credits below 40 (for 2024 onwards, Y4 only)    if (Info.AY >= 2024 and Info.classyear == 4): columns.append('Y3 creds failed')                # Physics/maths credits if M+P student (only for <=2022)    if (Info.AY <= 2022 and Info.mathstudent == True):        columns.append('Phys/Math Creds Taken')        # Marks columns depending on years/student type    # Previous years marks (if doCF == True and not a resit grid)    if (Info.dooverall == True and Info.resitgrid == False):        if (Info.classyear == 2):            columns.append('Phys 1')        if (Info.classyear == 31 or Info.classyear == 32):            columns.append('Phys 1')            columns.append('Phys 2')        if (Info.classyear == 4):            columns.append('Phys 1')            columns.append('Phys 2')            columns.append('Phys 3')    # Previous math marks if M+P student (only for <=2022)    if (Info.AY <= 2022 and Info.mathstudent == True and Info.dooverall == True):        if (Info.classyear == 2):            columns.append('Math 1')        if (Info.classyear == 31 or Info.classyear == 32):            columns.append('Math 1')            columns.append('Math 2')        if (Info.classyear == 4):            columns.append('Math 1')            columns.append('Math 2')            columns.append('Math 3')             # Year mark    if (Info.mathstudent == True):  # Math students have O/P/M        if (Info.AY <= 2022):            columns.append('Year Av O/P/M')        else:            columns.append('Phys Year Mark')            columns.append('Math Year Mark')            columns.append('Year Mark')    else:        columns.append('Year Mark')  # default    # Overall mark only for Y3/Y4    if (Info.dooverall == True and classyear != 1 and classyear !=2):        if (Info.mathstudent == True): # extra columns for M+P (only for <=2022)            if (Info.AY <= 2022):                columns.append('Overall O/P/M')                columns.append('Phys Overall')                columns.append('Math Overall')            else:                columns.append('Overall')        else: # default            columns.append('Overall')    # If do_extremes == True, output extreme yearmark/overall mark    if (do_extremes == True):        #columns.append('Year Mark lo/hi')        if (Info.dooverall == True):            columns.append('Overall lo/hi')            #columns.append('Overall lohi')            # Mit Circ (only for 2022 and earlier)    if (AY <= 2022): columns.append('Mit Circ')    # Deg Class if final year otherwise Status if not final year    if (Info.finalyear == True and Info.dooverall == True):        #columns.append('Deg Class')        columns.append('Deg Class Alg')        columns.append('Deg Class Rev')        columns.append('Deg Class Actual')        columns.append('Fail reason')        columns.append('Award')        columns.append('Classification')        columns.append('Award Alg')        columns.append('Award Actual')        columns.append('Classification Alg')        columns.append('Classification Actual')        columns.append('Award Change')        columns.append('Classification Change')    else: # always have status/fail reason        columns.append('Status')        columns.append('Fail reason')    # Keep award in for Y3 MPhys progressing    if (Info.classyear == 31):        columns.insert(columns.index('Status')+1, 'Award')   # immediately after Status            # Resits for Y1/Y2    if (Info.classyear == 1 or Info.classyear == 2):        columns.append('Resits')    # Finally add Boundary Notes if classyear==31 or above)     #if (Info.classyear == 31 or Info.classyear == 32 or Info.classyear == 4):    #    columns.append('Boundary Notes') #            # Finally add Exam Board Minutes and general notes column at the end (this is now combined with boundary_notes)    columns.append('Notes') #     columns.append('Exam Board Minutes')            # If resit grid remove some columns on output    #if (Info.resitgrid == True):    #    remove_columns = ['Resits']    #    remove_columns = []  # Empty (none removed)    #    for cols in remove_columns:    #        columns.remove(cols)                # Put coursenames back to replace Unit numbers if the input was that way    #unitcolumns_dict_reversed = dict([(value, key) for key, value in unitcolumns_dict.items()])    #keys = list(unitcolumns_dict_reversed.keys())    #items = list(unitcolumns_dict_reversed.items())    #for i in np.arange(len(keys)):        return columns################################################################# sort df by year mark (progressing) / overall mark (final year)# also add ID number after sortingdef sort_df(df,Info,sort_output=True):        # if a resit grid or sort_output = False, do not sort    if (Info.resitgrid == True or sort_output == False):        return df    # progressing students    if (Info.finalyear == False):        df = df.copy(deep=True) # to defragment (so to prevent warnings)        df["Year Mark Float"] = pd.Series(dtype=float)  # new column of floats for sorting        for i in np.arange(0,df.shape[0]-1,2): # duplicate float mark on each 2nd row            mark = df["Year Mark"].values[i].split('*') # in case of '*' in the string            if (mark[0] == ''): mark = [-1]            df.at[i,"Year Mark Float"] = float(mark[0])            df.at[i+1,"Year Mark Float"] = float(mark[0])        # finally do the sort        df.sort_values(by="Year Mark Float",ascending=False,inplace=True,kind='mergesort',ignore_index=True)        # remove extra column        df.drop(columns="Year Mark Float",inplace=True)            # graduating students    if (Info.finalyear == True):        df = df.copy(deep=True) # to defragment (so to prevent warnings)        df["Overall Float"] = pd.Series(dtype=float)  # new column of floats for sorting        for i in np.arange(0,df.shape[0]-1,2): # duplicate float mark on each 2nd row            mark = df["Overall"].values[i].split('*') # in case of '*' in the string            if (mark[0] == ''): mark = [-1]            df.at[i,"Overall Float"] = float(mark[0])            df.at[i+1,"Overall Float"] = float(mark[0])        # finally do the sort        df.sort_values(by="Overall Float",ascending=False,inplace=True,kind='mergesort',ignore_index=True)        # remove extra column        df.drop(columns="Overall Float",inplace=True)    # Move "Intercal" or "Interrupt" status rows to the bottom to be clean    #rows = df[df.Status == "Intercal"]    #df.drop(index=df.loc[df["Status"] == 'Intercal'].index, inplace=True)    #df = pd.concat([df, rows])    # add "ID No." column to match df2 which is produces from this    #idnum = [] # list to populate with ID numbers    #num = 1   # ID number to start at    #for i in range(0,len(df)): # loop over each row    #    sid = df.loc[i,"Emplid"]    #    if  (sid != '' and len(sid) >= 7 and sid.isnumeric() == True): # check that looks like an SID    #        idnum.append(num)  # add to list    #        num += 1           # increment ID    #    else:    #        idnum.append('')   # add empty string to list for that row    #df["ID No."] = idnum       # Add column to DataFrame                return df################################################################# Add useful codes to end of spreadsheetdef add_codes_df(df):    code_info = np.array([['',''],                ['Key:',''], ['',''],                 #['Mit Circ','Mitigating Circumstances'],                 #['#','Mit Circs not accepted'],                #['#*','Mit Circs acc; no action'],                #['#**','Mit Circs acc; action taken'],                ['',''],                ['ACTV','Met progression criteria (BSc/MPhys)'],                ['REVW','Review (resits)'],                ['A/D', 'Deferred units'],                ['R/X','MPhys student not achieved 55%'],                ['R/BSc','MPhys student not achieved 52%'],                ['FAIL','Failed due to <40% overall or <40% in lab or <60 credits'],                ['',''],                #['XL','Absent from exam, with reason'],                ['XN','Absent from exam, no reason'],                ['X','Mark excluded'],                #['X1','Resit at first attempt'],                ['',''],                #['*', 'Carry Forward flag in year mark (ongoing mitigating circumstances)'],                ['AUD', 'Marks not being assessed'],                ['',''],                ['P(A)', 'Promotion for borderline student by stage 1 criteria'],                ['P(B)', 'Promotion for borderline student by stage 2 criteria'],                ['P(A_X)', 'Promotion for borderline studeny by 2/3 of assessed credits criteria'],                ['P(B_X)', 'Promotion for borderline student by 2/3 of asssessed credits criteria']])                #['XX_P1 (YY)', 'XX post-penalty mark, YY pre-penalty mark (>=40%)'],                #['XX_P2 (YY)', 'XX post-penalty mark, YY pre-penalty mark (30-39%)'],                #['XX_P3 (YY)', 'XX post-penalty mark, YY pre-penalty mark (<30%)'] ])        nextrarows = np.shape(code_info)[0]   # number of extra rows to add    tempdf_single = df.iloc[0:1,:].copy()  # single line temporary df    tempdf = tempdf_single.copy()  # tempdf to be added to main dataframe    while (tempdf.count()[0] <= nextrarows):  # copy extra rows if they required otherwise will not get full list of codes        tempdf = pd.concat([tempdf,tempdf_single])    tempdf[:] = ''  # blank values    for i in np.arange(nextrarows):  # add code info        tempdf.iloc[i:i+1,4] = code_info[i,0]        tempdf.iloc[i:i+1,5] = code_info[i,1]                df = pd.concat([df,tempdf])   # add df's together        return df, nextrarows################################################################# add header info lines including merged Unit cells and table header (for df2)# THIS IS NOT WORKING PROPERLY AT THE MOMENT - FIX LATERdef add_header_lines(df):    nextrarows = 3 + 2   # number of rows plus one for the merged Unit cells and one for the table header    tempdf = df.iloc[0,:].copy()  # single line temporary df    tempdf[:] = ''  # blank values    tempdf2 = tempdf.copy()    counter = 0    while (counter < nextrarows):  # copy extra rows if they required otherwise will not get full list of codes        counter += 1        tempdf = pd.concat([tempdf,tempdf2])    df = pd.concat([tempdf,df])  # add df's together        return df################################################################# Encode student IDs def encode_emplid(Info):    sid = Info.emplid    ndigits = len(sid)    offsets = [1,2,3]*10  # long list of offsets to add to each digit *except* the last one    lastdigit = int(sid[-1])  # last digit for getting starting point of offset    sid_encoded = 'E'  # always begin with an "E" to show it is encoded        for i in range(ndigits-1):        digit = (int(sid[i]) + offsets[i] + lastdigit)%10   # add offset based on last digit then take last digit        sid_encoded += str(digit)    sid_encoded += str(lastdigit)   # add original last digit back which is needed to decode    Info.emplid_encoded = sid_encoded  # add back to Info                return Info################################################################# Apply CF flags if CF_flagfile availabledef apply_CFflags(dfout,df_CFflags,doCF):    # If no data, do nothing    if (CF_flagfile == '' or doCF == False):        return dfout    # Print statement    print('Applying CF flags...')        # get data from CF flag file    flags_sid = df_CFflags.iloc[:,1].values  # 2nd column    flags_year = df_CFflags.loc[:,"Year"].values     nflags = len(flags_sid)    # loop through each row in CF flag file    for i in range(nflags):        sid = flags_sid[i]        year = str(flags_year[i])        idx = dfout[dfout.loc[:,'Emplid'] == sid].index.values  # row index of student        # skip if no matching student        if (len(idx) < 1):            continue                # edit the mark in the appropriate column by adding a '*'        if (year == '2'): column = 'Phys 2'        if (year == '3'): column = 'Phys 3'        markout = dfout.loc[idx[0]][column]        markout = str(markout) + '*'        dfout.loc[idx[0], column] = markout            return dfout################################################################# Add "_resit" to to outfilename (for resit grids)def add_resit_tofilename(filename, Info):    # If a resit grid, add "resit" to the filename    if (Info.resitgrid == True):        filename_list = filename.split('.')        filename = ''        for i in range(len(filename_list)-1):            filename += filename_list[i]            if (i < len(filename_list)-2):                filename += '.'        filename += '.resit.xlsx'    return filename        ################################################################# output to Excel spreadsheet (strings_to_numbers option so not to store unit numbers as text)# Note that no changes to the actual data (only formatting) should occur from this point onwards# except for adding excel formulaedef df_to_excel(df, Info, columns, nextrarows, outfilename='test.xlsx', df2=None, columns2=None):    sheet1_name = '2 Line format'     # Previous 2-line format    sheet2_name = 'CS 1 Line format'  # New CS format (1-line per student)    # See if the 2nd sheet is required (if df2 and columns2 exist)    dosheet2 = False # default    try:        if (not df2 and not columns2): dosheet2 = False    except:        dosheet2 = True   # If df2 and columns2 exist    try:        writer = pd.ExcelWriter(outfilename, engine='xlsxwriter', engine_kwargs={'options': {'strings_to_numbers': True}})        #writer = pd.ExcelWriter(outfilename, engine='xlsxwriter')    except:        print('\nERROR writing out to {0:s} Please check directory...\n'.format(outfilename))        print('If not, must be a problem using pd.ExcelWriter() - make sure it is installed etc.')        sys.exit(0)    # make dataframe with only columns that we need    df = df.filter(columns, axis=1)        # output columns to excel spredsheet directly from Data Frame    df.to_excel(writer,index=False,sheet_name=sheet1_name,columns=columns, float_format="%.1f")    df.to_excel(writer,index=False,sheet_name=sheet1_name,columns=columns)        # Change column width/formatting before finally writing out    workbook = writer.book    worksheet1 = writer.sheets[sheet1_name]   # Sheet name    format1dp = workbook.add_format({'num_format': '#0.0'})  # Add float formatting to 1.d.p.    format_right_justify = workbook.add_format({'align':'right'})  # Add right justify for yearmark/overallmark (not working because string_to_numbers)        i = 0  # column index is needed    for column_str in columns: # loop over each column        col_idx = i   # column index        format1 = None  # default is no format                # set the widths        if (column_str.find('ID N') >=0): col_width=3        elif (column_str.find('Emplid') ==0): col_width=8        elif (column_str == 'Name'): col_width=10        elif (column_str == 'Plan'): col_width=15        elif (column_str.find('Unit') >= 0): col_width=6        elif (column_str.find('Code') >= 0): col_width=6        elif (column_str.find('Creds') >= 0): col_width=15        elif (column_str.find('L3/L4 cred') >= 0): col_width=14        elif (column_str.find('Y3 creds') >= 0): col_width=11        elif (column_str.find('Year Mark') ==0):            col_width=9            format1 = format_right_justify        elif (column_str.find('Overall') ==0):            col_width=8            format1 = format_right_justify        elif (column_str.find('Final Year Phys Mark') >=0):            col_width=16            format1 = format1dp        elif (column_str.find('Final Year Math Mark') >=0):            col_width=16            format1 = format1dp        elif (column_str.find('Year Mark lo/hi') >=0): col_width=18        elif (column_str.find('Overall lo/hi') >=0): col_width=10        elif (column_str.find('O/P/M') >=0): col_width=14        elif (column_str.find('Phys Overall') >=0): col_width=11        elif (column_str.find('Math Overall') >=0): col_width=11        elif (column_str.find('Phys Year Mark') >=0): col_width=12        elif (column_str.find('Math Year Mark') >=0): col_width=12                elif (column_str.find('Phys') >= 0): col_width=6        elif (column_str.find('Math') >= 0): col_width=7        elif (column_str.find('Year 3 Mark') >=0): col_width=8        elif (column_str.find('Status') >=0): col_width=9        elif (column_str.find('Deg Class') >= 0): col_width=13        elif (column_str.find('Resits') >= 0): col_width=40        elif (column_str.find('Mit') >= 0 or column_str.find('Sp') >=0): col_width=6        elif (column_str.find('Notes') >=0): col_width=35        elif (column_str.lower().find('reason') >=0): col_width=15        elif (column_str.lower().find('minutes') >=0): col_width=25        else: col_width=12  # default column width        # Write the format for this column        writer.sheets[sheet1_name].set_column(col_idx, col_idx, col_width+1,format1)  # Set column width and any other formatting                # Make sure year and overall marks are to 1 d.p. (e.g. 3.0 not 3)        # Doesn't work because mix of types float, strings and objects - need to convert all to floats first        #if (column_str.find('Year') >= 0 or column_str.find('Overall') >=0):        #    writer.sheets[sheet1_name].set_column(col_idx, col_idx, None, format1dp)        #    worksheet1.set_column(col_idx, col_idx, None, format1dp)        i += 1  # increment counter        # Apply 1 d.p. float to specific cells because they are overriden above due to applying to entire column    # Still not quite working so comment out action line below (background format etc not correct)    # First get list of columns that will have floats    cols_1dp = ['Phys 1', 'Phys 2', 'Phys 3', 'Math 1', 'Math 2', 'Math 3', 'Year Mark', 'Overall Mark', 'Phys Year Mark', 'Math Year Mark', 'Phys Overall', 'Math Overall']    # loop over the columns and cells containing float numbers (NOT PROPERLY IMPLEMENTED YET)    #cols_idx = [i for i, s in enumerate(columns) if columns[i] in cols_1dp] # Get column indices for unit coursename    nrows = df.count()[0]-nextrarows    for col in cols_1dp:  # loop over each column        if (col in columns):  # check to see if it exists first            col_idx_df = df.columns.get_loc(col)  # index of column in original df            col_idx    = columns.index(col)  # index of column in the output grid            for row_idx in np.arange(nrows):                temp = df.iloc[row_idx,col_idx_df]                                    #if (type(temp) != str and temp >=0): # only apply float format if it is a number of 0 or above (to leave -1s)                    #print(col, row_idx, col_idx, temp)                    #writer.sheets[sheet1_name].write_number(row_idx+1, col_idx, temp, format1dp)  # Works but overrides background colours etc.                # Make original id and name columns hidden if encode_sids option is set    # Also Award and Classification which is only really used for copying to the CS sheet (in rare cases such as P(B))    if (encode_sids == True):        col_idx = columns.index('Emplid')        worksheet1.set_column(col_idx, col_idx, None, None, {'hidden': True})        col_idx = columns.index('Name')        worksheet1.set_column(col_idx, col_idx, None, None, {'hidden': True})    if ('Award Alg' in columns): # hide column if it exists (final year)        col_idx = columns.index('Award Alg')        worksheet1.set_column(col_idx, col_idx, None, None, {'hidden': True})    if ('Award Actual' in columns): # hide column if it exists (final year)        col_idx = columns.index('Award Actual')        worksheet1.set_column(col_idx, col_idx, None, None, {'hidden': True})    if ('Classification Alg' in columns): # hide column if it exists (final year)        col_idx = columns.index('Classification Alg')        worksheet1.set_column(col_idx, col_idx, None, None, {'hidden': True})    if ('Classification Actual' in columns): # hide column if it exists (final year)        col_idx = columns.index('Classification Actual')        worksheet1.set_column(col_idx, col_idx, None, None, {'hidden': True})    if ('Award Change' in columns): # hide column if it exists (final year)        col_idx = columns.index('Award Change')        worksheet1.set_column(col_idx, col_idx, None, None, {'hidden': True})    if ('Classification Change' in columns): # hide column if it exists (final year)        col_idx = columns.index('Classification Change')        worksheet1.set_column(col_idx, col_idx, None, None, {'hidden': True})    if ('Classification' in columns): # hide column if it exists (final year)        col_idx = columns.index('Classification')        worksheet1.set_column(col_idx, col_idx, None, None, {'hidden': True})    if ('L3/L4 creds passed' in columns): # hide column if it exists (final year)        col_idx = columns.index('L3/L4 creds passed')        worksheet1.set_column(col_idx, col_idx, None, None, {'hidden': True})        # Hide "Award" in most cases but not Y3 MPhys (classyear==31) to allow manual editing    if ('Award' in columns and Info.classyear != 31): # hide column if it exists (final year) # Keep this visible on both sheets        col_idx = columns.index('Award')        worksheet1.set_column(col_idx, col_idx, None, None, {'hidden': True})    # format for grey/marged/headers    grey_colour = '#E0E0E0'    format_merge_header = workbook.add_format({'align': 'center', 'bold': True})  # bold format for merged cells    format_merge_grey = workbook.add_format({'bg_color': grey_colour, 'top':1, 'align': 'center'})    format_merge_white = workbook.add_format({'bg_color': False, 'top':1, 'align': 'center'})    format_grey_topline = workbook.add_format({'bg_color': grey_colour, 'top':1})    format_white_topline = workbook.add_format({'bg_color': False, 'top':1})    format_grey = workbook.add_format({'bg_color': grey_colour})    format_white = workbook.add_format({'bg_color': False})                # find shift for grey banding depending on number of rows per student and number of rows etc.    if (Info.resitgrid == True): rows_shift = 3    else: rows_shift = 2    cellheight = 17  # (Excel default is 15)    nrows = df.count()[0]-nextrarows    # get unit columns for merging    unit_cols_idx = [i for i, s in enumerate(columns) if 'unit' in s.lower()]  # Get columns for unit coursename    # Set format of rows including merging for unit row headers (2 columns for each unit)    if (Info.resitgrid == False):                for col in unit_cols_idx: # for each Unit column            worksheet1.merge_range(0, col, 0, col+1, columns[col], format_merge_header) # first header row        counter = 0 # counter for odd/even students        for row in range(1,nrows,rows_shift): # each row            counter += 1            if (counter % 2 == 0):                worksheet1.set_row(row, cellheight, cell_format=format_grey_topline)                worksheet1.set_row(row+1, cellheight-2, cell_format=format_grey)            else:                worksheet1.set_row(row, cellheight, cell_format=format_white_topline)                worksheet1.set_row(row+1, cellheight-2, cell_format=format_white)                                for col in unit_cols_idx: # for each Unit column                coursename = df.iloc[row-1,col]                #coursename = df.loc[row-1,columns[col]]                if (counter % 2 == 0):                    worksheet1.merge_range(row, col, row, col+1, coursename, format_merge_grey) # each unit row                else:                    worksheet1.merge_range(row, col, row, col+1, coursename, format_merge_white) # each unit row                               # Do it a little different for resit grids with 3 rows per student    elif (Info.resitgrid == True):        for col in unit_cols_idx: # for each Unit column            worksheet1.merge_range(0, col, 0, col+1, columns[col], format_merge_header) # first header row            for row in range(1,nrows,rows_shift): # each row                coursename = df.iloc[row-1,col]                #coursename = df.loc[row-1,columns[col]]                if (row % 2 == 1):                    worksheet1.set_row(row, cellheight-2, cell_format=format_grey_topline)                    worksheet1.set_row(row+1, cellheight-2, cell_format=format_grey)                    worksheet1.set_row(row+2, cellheight-2, cell_format=format_grey)                    worksheet1.merge_range(row, col, row, col+1, coursename, format_merge_grey) # each unit row                else:                    worksheet1.set_row(row, cellheight-2, cell_format=format_white_topline)                    worksheet1.set_row(row+1, cellheight-2, cell_format=format_white)                    worksheet1.set_row(row+2, cellheight-2, cell_format=format_white)                    worksheet1.merge_range(row, col, row, col+1, coursename, format_merge_white) # each unit row        # put box around any failed units in 2-line format    format_box1 = workbook.add_format({'border':6, 'bold':True})    format_box2 = workbook.add_format({'border':8, 'bold':True})    unit_strs = [unit for unit in columns if unit.find('Unit') >=0]    if (Info.resitgrid == True): # determine start/step size for values        start = 2        step = 3    else:        start = 1        step = 2    for unit_str in unit_strs:        vals = df[unit_str].to_list()        code_col = df.columns.get_loc(unit_str) + 1        codes = df.iloc[:,code_col].to_list()  # get codes in case of no mark but XN        for row_id in range(start,len(vals),step):  # re-write each mark with a box around it            col_id = df.columns.get_loc(unit_str)            try:  # if mark exists and < 40                mark = float(vals[row_id])                if (mark < 39.95):                     writer.sheets[sheet1_name].write(row_id+1,col_id, vals[row_id], format_box1)            except:                pass            try: # if no mark both times put a special box there in the first one (for MAB in 2023 e.g. HSTM no marks)                mark1 = str(vals[row_id])                mark2 = str(vals[row_id-1])                coursename = str(vals[row_id-2])                if ((mark1 == '' or mark1 == '-1') and (mark2 == '' or mark2 == '-1') and len(coursename) >8):                    writer.sheets[sheet1_name].write(row_id,col_id, vals[row_id], format_box2)            except:                pass                        try: # if no mark but XN or R2 in previous code (e.g. if A5) - this overrides any previous (different) boxes above                mark = str(vals[row_id])                if ((mark == '' or mark == '-1') and (codes[row_id].find('XN') >=0 or codes[row_id-1].find('R2') >=0)):                    writer.sheets[sheet1_name].write(row_id+1,col_id, vals[row_id], format_box1)            except:                pass                                    # if extremes exist, put box around any that are very different from the main mark or if they cross borders    all_columns = df.columns.to_list()    if ('Overall lohi' in all_columns):  # check original df columns not output columns (we don't output this variable)        col_id = columns.index('Overall lo/hi')  # index of *output* columns        vals = df["Overall lohi"].to_list()    # tell us if should be a box        vals_out = df["Overall lo/hi"].to_list()  # output        for row_id in range(len(vals)):            if (vals[row_id] != ''):                writer.sheets[sheet1_name].write(row_id+1,col_id, vals_out[row_id], format_box2)    # Optionally write a 2nd sheet with 1-line per student in CS format    if (dosheet2 == True):        startrow = 5  # number of header lines        df2.to_excel(writer,index=False,sheet_name=sheet2_name,columns=columns2, float_format="%.1f", header=True, startrow=startrow)        worksheet2 = writer.sheets[sheet2_name]   # Sheet name        # Change column width/formatting before finally writing out        worksheet2 = writer.sheets[sheet2_name]   # Sheet name        i = 0  # column index is needed        for column_str in columns2: # loop over each column            col_idx = i   # column index                    # set the widths            if (column_str.find('ID') >= 0): col_width=4            elif (column_str.find('Admit') >=0): col_width=9            elif (column_str.find('Entry') >=0): col_width=9            elif (column_str.find('Emplid') >=0): col_width=9            elif (column_str == 'Name'): col_width=20            elif (column_str == 'UF'): col_width=6            elif (column_str == 'MC'): col_width=6            elif (column_str == 'BZ'): col_width=6            elif (column_str == 'Plan'): col_width=25            elif (column_str == 'Classification'): col_width=9            elif (column_str.find('Module') >= 0): col_width=14            elif (column_str.find('Mark') == 0): col_width=5            elif (column_str.find('EN') >= 0): col_width=5            elif (column_str.find('Mit Circs') >= 0): col_width=5            elif (column_str.find('GPA') >= 0): col_width=13            elif (column_str.find('Exam') >= 0): col_width=20            elif (column_str.find('Chairs') >= 0): col_width=20            elif (column_str.find('Override') >= 0): col_width=17            elif (column_str.find('CM') >= 0): col_width=5            elif (column_str.find('Pass') >= 0): col_width=6            elif (column_str == '1st'): col_width = 4            elif (column_str == '2.1'): col_width = 4            elif (column_str == '2.2'): col_width = 4            elif (column_str == '3rd'): col_width = 4            elif (column_str == 'CF'): col_width = 4            elif (column_str == 'Fail'): col_width = 4            elif (column_str == 'Total'): col_width = 4            elif (column_str == 'Resits'): col_width = 40            else: col_width=13  # default column width            # Write the format for this column            #print(column_str, col_idx, col_width)            writer.sheets[sheet2_name].set_column(col_idx, col_idx, col_width+1,format1)  # Set column width and any other formatting            i += 1  # increment counter        # EXCEL FORMULAE!!!        # For all years - Exam Board Minutes, Notes -> dynamically copy from 2-line to CS 1-line        col_idx_id1 = columns.index('Emplid') # get column for Emplid on 1st sheet (2-Line)        col_idx_id2 = columns2.index('Emplid') # get column for Emplid on 2nd (CS 1-Line)        col_id1 = xlsxwriter.utility.xl_col_to_name(col_idx_id1)  # get column ID on 1st sheet (2-Line)        col_id2 = xlsxwriter.utility.xl_col_to_name(col_idx_id2)  # get column ID on 1st sheet (2-Line)        col_idx9 = columns2.index('Exam Board Minutes') # column on 2nd sheet        col_idx10 = columns2.index('Notes') # column on 2nd sheet                # Write formulae to sheet 2 (1-Line format) for ALL years        for i in range(startrow+1,len(dfout)+startrow+1):    # zero-indexed            row_idx = i+1  # Excel row (used in formulae)            # Exam Board Minutes (copy over from 2-Line Sheet)            formula1a = 'INDIRECT(ADDRESS(MATCH(' + col_id2 + str(row_idx) + ', \'2 Line format\'!' + col_id1 + ':' + col_id1 +',0), ' + 'MATCH(\"Exam Board Minutes\", \'2 Line format\'!1:1,0), , , \"2 Line format\"))'  # This gets the derived (algorithm) degclass            formula1 = '=\"\" & IFERROR(' + formula1a + ', \"\" )' # full formula (Exam Board Minutes)            # Notes (copy over from 2-Line Sheet)            formula2a = 'INDIRECT(ADDRESS(MATCH(' + col_id2 + str(row_idx) + ', \'2 Line format\'!' + col_id1 + ':' + col_id1 +',0), ' + 'MATCH(\"Notes\", \'2 Line format\'!1:1,0), , , \"2 Line format\"))'  # This gets the derived (algorithm) degclass            formula2 = '=\"\" & IFERROR(' + formula2a + ', \"\" )' # full formula (Notes)            # output formulae!            writer.sheets[sheet2_name].write_formula(i,col_idx9,formula1) # Output to Exam Board Minutes on 2nd sheet            writer.sheets[sheet2_name].write_formula(i,col_idx10,formula2) # Output to Notes on 2nd sheet        # Y1/Y2 only (e.g. resits -> dynamically copy from 2-line to CS 1-line)        if (Info.classyear == 1 or Info.classyear == 2):            col_idx11 = columns.index('Resits') # column number for Emplid on 1st sheet (2-line)            col_idx12 = columns2.index('Resits') # column number for Emplid on CS sheet (1-line)            col_id11 = xlsxwriter.utility.xl_col_to_name(col_idx11)  # get column ID             col_id12 = xlsxwriter.utility.xl_col_to_name(col_idx12)  # get column ID                     for i in range(startrow+1,len(dfout)+startrow+1):    # zero-indexed                row_idx = i+1  # Excel row (used in formulae)                # Resits (copy over from 2-Line Sheet)                formula1a = 'INDIRECT(ADDRESS(MATCH(' + col_id2 + str(row_idx) + ', \'2 Line format\'!' + col_id1 + ':' + col_id1 +',0), ' + 'MATCH(\"Resits\", \'2 Line format\'!1:1,0), , , \"2 Line format\"))'  # This gets the derived (algorithm) degclass                formula1 = '=\"\" & IFERROR(' + formula1a + ', \"\" )' # full formula (Exam Board Minutes)                # output formulae!                writer.sheets[sheet2_name].write_formula(i,col_idx12,formula1) # Output to Exam Board Minutes on 2nd sheet                    # Insert formulae to copy over changes from 2 Line format to CS 1 Line for - only for finalyear students        # Done using matching of Emplid/column name automatically        # Except for those that have been overriden by the algorithm (basically P(B) promotion)        if (Info.finalyear == True and Info.dooverall == True):            col_idx_id3 = columns.index('Award Alg')             col_idx_id4 = columns.index('Award Actual') #            col_idx_id5 = columns.index('Classification Alg') #            col_idx_id6 = columns.index('Classification Actual') #            col_idx_id7 = columns.index('Award Change') #            col_idx_id8 = columns.index('Classification Change') #             col_id3 = xlsxwriter.utility.xl_col_to_name(col_idx_id3)  #            col_id4 = xlsxwriter.utility.xl_col_to_name(col_idx_id4)  #            col_id5 = xlsxwriter.utility.xl_col_to_name(col_idx_id5)  #            col_id6 = xlsxwriter.utility.xl_col_to_name(col_idx_id6)  #            col_id7 = xlsxwriter.utility.xl_col_to_name(col_idx_id7)  #            col_id8 = xlsxwriter.utility.xl_col_to_name(col_idx_id8)  #            col_idx1 = columns2.index('Override Award') # column number on 2nd shhet            col_idx2 = columns2.index('Override Classification') # column number on 2nd sheet            col_idx3 = columns.index('Award Alg')            col_idx4 = columns.index('Award Actual')            col_idx5 = columns.index('Classification Alg')            col_idx6 = columns.index('Classification Actual')            col_idx7 = columns.index('Award Change')            col_idx8 = columns.index('Classification Change')                        # Write formulae to sheet 2 (1-Line format)            for i in range(startrow+1,len(dfout)+startrow+1):    # zero-indexed                row_idx = i+1  # Excel row (used in formulae)                # "Award Alg"                #formula3a = 'AN' + str(row_idx) # just gets value directly                #formula3a = 'MATCH(\"Deg Class Alg\", A1:ZZ1, 0)' # column number                #formula3a = 'ADDRESS(' + str(row_idx) + ', MATCH(' + '\"Deg Class Alg\", A1:ZZ1, 0))' # cell address                formula3a = 'INDIRECT(ADDRESS(' + str(row_idx) + ', MATCH(' + '\"Deg Class Alg\", A1:ZZ1, 0)))' # cell value!                formula3 = '=\"\" & ' + 'IFERROR(LEFT(' + formula3a + ', SEARCH(\" \", ' + formula3a + ',1)-1),' + formula3a + ')'  # better - if only 1 word                            # Award Actual                formula4a = 'INDIRECT(ADDRESS(' + str(row_idx) + ', MATCH(' + '\"Deg Class Actual\", A1:ZZ1, 0)))' # left cell value!!                formula4 = '=\"\" & ' + 'IFERROR(LEFT(' + formula4a + ', SEARCH(\" \", ' + formula4a + ',1)-1), \"\")'  # gets it!!                # Classification Alg                formula5a = 'INDIRECT(ADDRESS(' + str(row_idx) + ', MATCH(' + '\"Deg Class Alg\", A1:ZZ1, 0)))' # cell value!                formula5 = '=\"\" & ' + 'IFERROR(RIGHT(' + formula5a + ', LEN(' + formula5a + ')-SEARCH(\" \", ' + formula5a + ',1)),' + formula5a + ')'                 # Classification Actual                formula6a = 'INDIRECT(ADDRESS(' + str(row_idx) + ', MATCH(' + '\"Deg Class Actual\", A1:ZZ1, 0)))' # left cell value!!                formula6 = '=\"\" & ' + 'IFERROR(RIGHT(' + formula6a + ', LEN(' + formula6a + ')-SEARCH(\" \", ' + formula6a + ',1)), \"\")'  # gets it!!                # Award Change                formula7a = 'INDIRECT(ADDRESS(' + str(row_idx) + ', MATCH(' + '\"Award Alg\", A1:ZZ1, 0)))' # left cell value!!                formula7b = 'INDIRECT(ADDRESS(' + str(row_idx) + ', MATCH(' + '\"Award Actual\", A1:ZZ1, 0)))' # left cell value!!                formula7 = '=\"\" & IFERROR( IF( ' + formula7a + ' = ' + formula7b + ', \"\", ' + formula7b + '), \"\" )' # full formula (award)                # Classification Change                formula7a = 'INDIRECT(ADDRESS(' + str(row_idx) + ', MATCH(' + '\"Classification Alg\", A1:ZZ1, 0)))' # left cell value!!                formula7b = 'INDIRECT(ADDRESS(' + str(row_idx) + ', MATCH(' + '\"Classification Actual\", A1:ZZ1, 0)))' # left cell value!!                formula8 = '=\"\" & IFERROR( IF( ' + formula7a + ' = ' + formula7b + ', \"\", ' + formula7b + '), \"\" )' # full formula (award)                            # write formula to 1st sheet                writer.sheets[sheet1_name].write_formula(i,col_idx3,formula3) # Output to Award Alg on 1st sheet                writer.sheets[sheet1_name].write_formula(i,col_idx4,formula4) # Output to Award Actual on 1st sheet                writer.sheets[sheet1_name].write_formula(i,col_idx5,formula5) # Output to Classification Alg on 1st sheet                writer.sheets[sheet1_name].write_formula(i,col_idx6,formula6) # Output to Classification Alg on 1st sheet                writer.sheets[sheet1_name].write_formula(i,col_idx7,formula7) # Output to Award Change on 1st sheet                writer.sheets[sheet1_name].write_formula(i,col_idx8,formula8) # Output to Classification Change on 1st sheet                        # Write formulae to sheet 2 (CS 1-Line format)            for i in range(startrow+1,len(dfout2)+startrow+1):    # zero-indexed                row_idx = i+1  # Excel row (used in formulae)                        # Write general formulae                                                    # works well including matching emplid column                #formula1 = 'INDIRECT(ADDRESS(MATCH(' + col_id2 + str(row_idx) + ', \'2 Line format\'!' + col_id1 + ':' + col_id1 +',0), ' + 'MATCH(\"Deg Class Alg\", \'2 Line format\'!1:1,0), , , \"2 Line format\"))'  # This gets the derived (algorithm) degclass                #formula2 = 'INDIRECT(ADDRESS(MATCH(' + col_id2 + str(row_idx) + ', \'2 Line format\'!' + col_id1 + ':' + col_id1 + ',0), ' + 'MATCH(\"Deg Class Actual\", \'2 Line format\'!1:1,0), , , \"2 Line format\"))' # This gets the actual deg class                            # older less flexible versions                #formula1 = 'INDIRECT(ADDRESS(MATCH(B' + str(row_idx) + ', \'2 Line format\'!B:B,0), ' + 'MATCH(\"Deg Class Alg\", \'2 Line format\'!1:1,0), , , \"2 Line format\"))'  # This gets the derived (algorithm) degclass                #formula2 = 'INDIRECT(ADDRESS(MATCH(B' + str(row_idx) + ', \'2 Line format\'!B:B,0), ' + 'MATCH(\"Deg Class Actual\", \'2 Line format\'!1:1,0), , , \"2 Line format\"))' # This gets the actual deg class                # Override Award - THIS ONE WORKS!                formula1a = 'INDIRECT(ADDRESS(MATCH(' + col_id2 + str(row_idx) + ', \'2 Line format\'!' + col_id1 + ':' + col_id1 +',0), ' + 'MATCH(\"Deg Class Alg\", \'2 Line format\'!1:1,0), , , \"2 Line format\"))'  # This gets the derived (algorithm) degclass                formula1b = 'INDIRECT(ADDRESS(MATCH(' + col_id2 + str(row_idx) + ', \'2 Line format\'!' + col_id1 + ':' + col_id1 + ',0), ' + 'MATCH(\"Deg Class Actual\", \'2 Line format\'!1:1,0), , , \"2 Line format\"))' # This gets the actual deg class                formula1c = 'INDIRECT(ADDRESS(MATCH(' + col_id2 + str(row_idx) + ', \'2 Line format\'!' + col_id1 + ':' + col_id1 + ',0), ' + 'MATCH(\"Award Change\", \'2 Line format\'!1:1,0), , , \"2 Line format\"))' # This gets the actual deg award                # Override Classification - THIS ONE WORKS!                formula2a = 'INDIRECT(ADDRESS(MATCH(' + col_id2 + str(row_idx) + ', \'2 Line format\'!' + col_id1 + ':' + col_id1 +',0), ' + 'MATCH(\"Deg Class Alg\", \'2 Line format\'!1:1,0), , , \"2 Line format\"))'  # This gets the derived (algorithm) degclass                formula2b = 'INDIRECT(ADDRESS(MATCH(' + col_id2 + str(row_idx) + ', \'2 Line format\'!' + col_id1 + ':' + col_id1 + ',0), ' + 'MATCH(\"Deg Class Actual\", \'2 Line format\'!1:1,0), , , \"2 Line format\"))' # This gets the actual deg class                formula2c = 'INDIRECT(ADDRESS(MATCH(' + col_id2 + str(row_idx) + ', \'2 Line format\'!' + col_id1 + ':' + col_id1 + ',0), ' + 'MATCH(\"Classification Change\", \'2 Line format\'!1:1,0), , , \"2 Line format\"))' # This gets the actual deg classification                            formula1 = '=\"\" & IFERROR( IF( ' + formula1a + ' = ' + formula1b + ', \"\", ' + formula1c + '), \"\" )' # full formula (award)                formula2 = '=\"\" & IFERROR( IF( ' + formula2a + ' = ' + formula2b + ', \"\", ' + formula2c + '), \"\" )' # full formula (classification)                                # Write formula to 2nd sheet (CS 1-Line)                writer.sheets[sheet2_name].write_formula(i,col_idx1,formula1)  # Output to Override Award on 2nd sheet                writer.sheets[sheet2_name].write_formula(i,col_idx2,formula2) # Output to Override Classification on 2nd sheet                                                # For Y3 MPhys (classyear=31) add in formula to copy from 2-Line sheet to Override award (CS 1-line sheet)        if (Info.classyear==31):            col_idx_id1 = columns.index('Emplid') # get column for Emplid on 1st sheet (2-Line)            col_idx_id2 = columns2.index('Emplid') # get column for Emplid on 2nd (CS 1-Line)            col_idx_id3 = columns.index('Award')             col_id1 = xlsxwriter.utility.xl_col_to_name(col_idx_id1)  # get column ID on 1st sheet (2-Line)            col_id2 = xlsxwriter.utility.xl_col_to_name(col_idx_id2)  # get column ID on 1st sheet (2-Line)            col_id3 = xlsxwriter.utility.xl_col_to_name(col_idx_id3)  #            col_idx1 = columns2.index('Override Award') # column number on 2nd shhet                        # Write formulae to sheet 2 (CS 1-Line format)            for i in range(startrow+1,len(dfout2)+startrow+1):    # zero-indexed                row_idx = i+1  # Excel row (used in formulae)                        # Write general formula                # Override Award - THIS ONE WORKS!                formula1a = 'INDIRECT(ADDRESS(MATCH(' + col_id2 + str(row_idx) + ', \'2 Line format\'!' + col_id1 + ':' + col_id1 +',0), ' + 'MATCH(\"Award\", \'2 Line format\'!1:1,0), , , \"2 Line format\"))'  # This gets the derived (algorithm) degclass                formula1 = '=\"\" & IFERROR(' + formula1a + ', \"\" )' # full formula (award)                                # Write formula to 2nd sheet (CS 1-Line0                writer.sheets[sheet2_name].write_formula(i,col_idx1,formula1)  # Output to Override Award on 2nd sheet                    # Write out and finish    workbook.close()    #df.to_excel(outfilename,index=False,sheet_name=sheet1_name,columns=columns,engine='xlsxwriter')    #writer.save()  # deprecated    return None################################################################# write encoded sids to a file if encode_sids == Truedef write_encoded_sids(outfilename,all_sids, all_sids_encoded):    data = np.column_stack([all_sids, all_sids_encoded])    sidfilename = outfilename.split('.xls')[0] + '_sids.txt'    np.savetxt(sidfilename, data, fmt=['%s ','%s'])    return None################################################################# Add resit marks from 3rd row and replace marks as necessarydef get_resit_marks(Info, df, keep_input_resit_codes=False, fill_marks=False):    # determine if resitting - which means there is a 3rd row    if (len(df) != 3):        print('*ERROR: no 3rd row in input expected for resit grids...please check again...')        return Info    # add extra variables for previous marks etc. ('p_XXX')    Info.p_marks = Info.marks.copy()    Info.p_marksout = Info.marksout.copy()   # string for output marks (including potentially codes etc)    Info.p_credits = Info.credits.copy()    Info.p_codes = Info.codes2.copy()          # alternate 2-line version of the codes only for resits    Info.p_creditspassed = Info.creditspassed  # just int so no need to copy    Info.p_creditsfailed = Info.creditsfailed  # just int so no need to copy    Info.p_deferred_idx = Info.deferred_idx.copy()    Info.p_deferredcoursenames = Info.deferredcoursenames    Info.p_referred_idx = Info.referred_idx.copy()    Info.p_referredcoursenames = Info.referredcoursenames    Info.p_compensated_idx = Info.compensated_idx.copy()    Info.p_excluded_idx = Info.excluded_idx.copy()    Info.p_excludedcoursenames = Info.excludedcoursenames    Info.p_yearmark = Info.yearmark    Info.p_nomarks_idx = Info.nomarks_idx.copy()        # add variable to indicate we are working on the 3rd row (resit marks)    Info.secondpass = True        # blank variable to store just the resit marks and idx    Info.resitmarksout = ['']*len(Info.marks)    Info.resitmarks = []    Info.resit_idx = []    # also blank some other variables from the 1st pass so not to confuse later    Info.referred_idx = []    Info.referredcoursenames = ''    Info.deferred_idx = []    Info.deferredcoursenames = ''    Info.failed_idx = []    Info.excluded_idx = []    Info.excludedcoursenames = ''        # loop over each course in the output    columns = df.filter(regex='^Unit\ ',axis=1).columns.to_list()  # just unit columns    coursenames = Info.coursenames    row1 = df.iloc[0,:].to_list()    for i in range(len(Info.coursenames)):                idx = [x for x, s in enumerate(row1) if coursenames[i] in s][0]  # get index of column        data = df.iloc[:,idx].values  # get main data        code = df.iloc[2,idx+1]  # Get new codes for any courses        Info.codes[i] = code # put back into Info        # add mark if available otherwise continue         mark_str = str(data[2])        # for testing non-complete grids with missing marks, optionally add in marks for checking codes/decisions etc.        if (fill_marks == True and mark_str == ''):            mark_str = '50'                if (mark_str == '' and code == ''):    # Keep original mark if nothing there unless there is a code             if (Info.p_codes[i] == 'X' or Info.p_codes[i] == '_X'):                Info.codes[i] = Info.p_codes[i]  #only exclude if 'X'        elif (mark_str == '' and len(code) > 0): # if no mark but a code (e.g. XL, XN) mark as a resit to include in output grid            Info.resit_idx.append(i)            Info.resitmarksout[i] = ''        else: # add resit data            try:  # if just a number (usually is)                Info.marks[i] = round(float(mark_str)+0.000001) # mark as a (rounded) integer                Info.resitmarks.append(Info.marks[i])                Info.resitmarksout[i] = mark_str # store for later                Info.resit_idx.append(i)            except: # if not just a number and code                if (mark_str == ''): # if empty                    Info.marks[i] = -1                    Info.resitmarksout[i] = ''                    Info.resit_idx.append(i)                elif (mark_str[0].isnumeric() == True):  # if XXC or XXR or XX_X get numerical mark                    Info.marks[i] = round(float(''.join([c for c in mark_str if c.isdigit()])))  # get only numerical values                    markcode = ''.join([c for c in mark_str if not c.isdigit()]) # get any code with the mark                    Info.resitmarksout[i] = str(Info.marks[i])  + markcode  # with markcode for reproduction                    Info.resit_idx.append(i)                    if ('C' in markcode and i not in Info.compensated_idx):  # if compensated make a note now                        Info.compensated_idx.append(i)                    #code = code # add mark code back to main code (but can change later)                else: # no numerical mark but not empty!                    print('*WARNING: no numerical (resit) mark [ {0:s} ] but not empty! Please check!...'.format(mark_str))            if i in Info.excluded_idx:        # Remove previous excluded courses now that a mark exists                if (Info.codes[i].find('_C') < 0):  # do not exclude if previously compensated                    Info.excluded_idx.remove(i)                    Info.excludedcoursenames.remove(coursenames[i])            if i in Info.deferred_idx:        # Remove previous deferred courses now that a new mark exists                Info.deferred_idx.remove(i)                temp = Info.deferredcoursenames.split('/')                temp = [s for s in temp if s.find(coursenames[i]) < 0] # remove coursename from list                for j in range(len(temp)):                    Info.deferredcoursenames = temp[j] + ' / '                       # For new input format (from 2024) add in Mit Circs codes for each module directly from input sheet        if (AY >= 2024):            mcc_codes = df.iloc[2,idx+2] # get the codes            if (',' in mcc_codes):  # split with , first                mcc_codes = df.iloc[2,idx+2].split(',')            elif ('/' in mcc_codes): # then try '/' because sometimes they use '/'                mcc_codes = df.iloc[2,idx+2].split('/')                            if (isinstance(mcc_codes,list) and mcc_codes[0] != ''): # if multiple codes add them back and separate with '_'                for j in range(len(mcc_codes)):                    if (code == ''):                        code += mcc_codes[j] + '_'                    else:                        if (j == 0): # add '_' if code already exists                            code += '_' + mcc_codes[j] + '_'                        else:                            code += mcc_codes[j] + '_'                code.replace('__', '_')  # remove extra '_' if exists                code  = code[:-1] # remove trailing '_'                code  = code.replace(' ', '') # remove any white space        Info.codes[i] += code                # if keep_input_codes set to False, blank them, since they will be added in via external MCC file    # (Doesn't matter about code above since Info.codes will also have been blanked)    if (keep_input_resit_codes == False):        Info.codes = ['']*len(Info.codes)    # look for missing resit marks                            # record courses with no mark for later     nomarks_idx = [i for i, j in enumerate(Info.marks) if j < 0]    # add the lists back to the Info object    Info.nomarks_idx = nomarks_idx    # Reset status to ACTV for the 2nd pass (so not to leave A/D for example)    Info.status = 'ACTV'        return Info################################################################# apply resit marks to be used for averages e.g. if capped, or use original mark etc.# Keep final marks array for yearmark for later, but initially output pre-capped etc. resit marksdef apply_resit_marks(Info):    # Copy actual marks to be used to another array    Info.marks_postcapped = Info.marks.copy()        # loop over each course that has been resat     for idx in Info.resit_idx:        # Decide which mark and output to use for resits        if (idx in Info.p_deferred_idx or idx not in Info.secondattempt_idx): # use new mark for previous deferrals or if R1/A1 code (i.e. 1st attempt) unless new mark is lower (and is not excluded) - see Judith email 26-Oct-2022            if (Info.p_marks[idx] > Info.marks[idx] and idx not in Info.excluded_idx):                Info.marks_postcapped[idx] = Info.p_marks[idx]            else:                Info.marks_postcapped[idx] = Info.marks[idx]        elif (idx in Info.compensated_idx and idx in Info.excluded_idx):  # if previously compensated must include in average            Info.excluded_idx.remove(idx)            Info.credweights[idx] = Info.credits[idx]        # if definitely 2nd attempt, apply resit mark caps        if (idx not in Info.p_deferred_idx and idx in Info.secondattempt_idx):            if (Info.p_marks[idx] >= 29.95):    # original mark if not under 30                 Info.marks_postcapped[idx] = Info.p_marks[idx]            elif (Info.p_marks[idx] < 29.95):                   if (Info.marks[idx] > 29.95 and idx not in Info.compensated_idx): # resit mark capped at 30 if original mark < 30 (if not compensated)                    Info.marks_postcapped[idx] = 30                                     # if OM>30 and resit < 30, put main marks back to fix referral issues later (someunitunder30 == True etc)            if (Info.marks[idx] < 29.95 and Info.p_marks[idx] >= 29.95):                Info.marks[idx] = Info.p_marks[idx]        # If lab with OM<40 and new mark is higher, likely that they did extra coursework (see Judith email 23-Apr-2024)        # So use new mark in average        mustpass_idx = [i for i, c in enumerate(Info.coursenames) if (c in mustpass)]         for idx in mustpass_idx:            if (Info.p_marks[idx] < 39.95 and Info.marks[idx] >= 39.95):                Info.marks_postcapped[idx] = Info.marks[idx]                    return Info################################################################# add 3rd row (resit) data from this student (Info) to the output student dataframe# and add other info to the 2nd row like averages/status (not 3rd)def add_resit_data_df(df,Info):    # Blank row    columns = df.columns.to_list()    new_row = {}    for col in columns:        new_row[col] = ['']    # add the rows to the df    new_row = pd.DataFrame(new_row)    df = pd.concat([df,new_row], ignore_index=True, sort=False)    # Put in resit marks into df directly where they exist into 3rd row along with any codes    idx = [x for x, name in enumerate(columns) if name.find('Unit') >= 0]    #for i in Info.resit_idx:  # only do this where there are new resit marks    for i in range(len(Info.coursenames)):        df.iloc[-1,idx[i]] = Info.resitmarksout[i]        df.iloc[-1,idx[i]+1] = Info.codes2[i]   # for 2-line format using codes2            # Put in averages and status to the 2nd row of df    idx = columns.index('Creds Passed/Taken')    df.iloc[-2,idx] = str(Info.creditspassed) + ' / ' + str(Info.creditstaken)    idx = columns.index('Year Mark')    df.iloc[-2,idx] = Info.yearmark    idx = columns.index('Year Av O/P/M')    df.iloc[-2,idx] = Info.year_opm    idx = columns.index('Status')    df.iloc[-2,idx] = Info.status    idx = columns.index('Fail reason')    df.iloc[-2,idx] = Info.failreason    idx = columns.index('Resits')    df.iloc[-2,idx] = Info.deferredcoursenames + Info.referredcoursenames.rstrip(' / ')        return df################################################################# Make new df for 2nd sheet in CS format (1 line per student) and set the columns listdef make_df2(dfout, Info, maxunit):    df = dfout.copy()  # deep copy of main dataframe        # remove 2nd line which is not needed    df.drop(df[df.Name == ''].index, inplace=True)    nrows = len(df)   # number of student rows    # reindex from 0    df.reindex()    # put in ID number for CS sheet if not in dfout for some reason    # (it should exist in dfout and automatically be copied over)    if ('ID No.' not in dfout.columns.to_list()):        df['ID No.'] = [item for item in range(1,nrows+1)]  # ID No. going from 1 to N    # define columns of standard CS output    columns = ['Emplid', 'Name', 'ID No.', 'UF', 'MC', 'BZ', 'Admit Term', 'Entry Type', 'Plan', 'Units Passed']    # add columns for final year     if (Info.finalyear == True and Info.dooverall):         columns += ['Award', 'Classification']    elif (Info.classyear==31): # (and classyear=31 just in case cannot progress)        columns += ['Award', 'Classification']            # loop over units for coursename, marks, codes etc.    for i in range(1,maxunit+1):          unit_str = str(i)        columns.append('Module ?'.replace('?',unit_str))        columns.append('Mark ?'.replace('?',unit_str))        col_name = 'EN ?'.replace('?',unit_str)  # keep column name for later        columns.append(col_name)        columns.append('Mit Circs ?'.replace('?',unit_str))        # also remove any XNs in the codes for each unit column (for CS 1-line output only)        # *Keep XN in EN codes        #codes = df[col_name].to_list()        #row_idx = [k for k, s in enumerate(codes) if 'XN' in s] # rows containing XN for this unit        #for j in range(len(row_idx)): # loop over each code in the row of this column checking for XNs        #    codes[row_idx[j]] = codes[row_idx[j]].replace('XN', '')                  #df[col_name] = codes # put complete column of codes back to the dataframe    # Put the rest of the columns in     columns = columns + ['Units Taken',            'Units Passed 2',            'AS Code',            'Pr. Term GPA',            'Term GPA',            'Cumul. GPA',            'Deg. GPA',            'Pre-Exam Board Minutes',            'Exam Board Minutes',            'Chairs Action',            'Chairs Action Approved By',            'Chairs Action Resolved',            'Chairs Action Date',            'Override Award',            'Override Classification',            'Override Deg. GPA',            'Notes',            'L1CM', 'L2CM', 'L3CM', 'L4CM',            'Pass / Fail',            '1st', '2.1', '2.2', '3rd', 'CF', 'Fail', 'Total',            'ID No.']    # add resits column at the end if Y1/Y2    if (Info.classyear == 1 or Info.classyear == 2):        columns.append('Resits')        # Copy over information to new column names where necessary (i.e. when variable names are different)    for i in range(1,maxunit+1): # loop over units        unitname = 'Unit ' + str(i)        modulename = 'Module ' + str(i)        df[modulename] = df[unitname].copy()            # Other columns with different names    df['Units Taken']  = df['Creds Taken'].copy()    df['Units Passed'] = df['Creds Passed'].copy()    df['AS Code']      = df['Status'].copy()    df['Term GPA']     = df['Year Mark'].copy()    df['Deg. GPA']     = df['Overall'].copy()    df['1st']      = df['Creds 1'].copy()    df['2.1']      = df['Creds 2.1'].copy()    df['2.2']      = df['Creds 2.2'].copy()    df['3rd']      = df['Creds 3'].copy()    df['CF']       = df['Creds CF'].copy()  # Credits 30-39 (Judith email 19-Jun-2023)    df['Fail']     = df['Credits Failed'].copy() - df['Creds CF'] # Creds 0-29 (not 0-39) (Judith email 19-Jun-2023)    df['Total']    = df['Creds Total'].copy() # Total credits (-excluded)    # add data for finalyear students     #if (Info.finalyear == True and Info.dooverall == True):    #    df['Award']          = df['Award'].copy()    #    df['Classification'] = df['Classification'].copy()    #elif (Info.classyear==31): # (also for classyear==31)    #    df['Award']          = df['Award'].copy()    #    df['Classification'] = df['Classification'].copy()        # Add blank columns if they do not exist    for col in columns:        if col not in df.columns:            df[col] = ['']*nrows    # replace any "-1" (no value) with a blank for CS output    df = df.replace(-1, '', regex=True)  # -1 -> '' (blank)                # Sort the df by columns    df = df[columns]        return df, columns################################################################################################################################################################################################# some data definitions################################################################# Credits requiredcreditstogetMPHYS = 80creditstogetMPHYSlower = 60creditstogetMPHYS34 = 200  # from 2024 need to consider credits over Y3+Y4creditstogetMPHYSlower34 = 180  # from 2024 need to consider credits over Y3+Y4creditstogetBScgood=80creditstogetBSclower=60if (int(AY) <= 2019): creditstogetMPHYSalgA = 75 # Used for algA else: creditstogetMPHYSalgA = 80 # New rule for 2020 onwardscreditstogetalgB = 70  # Used for algB# boundaries for degree class (2 d.ps because marks are stored to 1 d.p.)boundaryfirst=69.95boundaryupper2=59.95boundarylower2=49.95boundarythird=39.95# borderlines for promotion consideration if (AY >= 2020 and AY <= 2024):    borderfirst = boundaryfirst - 3.0    borderupper2 = boundaryupper2 - 3.0    borderlower2 = boundarylower2 - 3.0    borderthird = boundarythird - 4.0else:    borderfirst = boundaryfirst - 2.0    borderupper2 = boundaryupper2 - 2.0    borderlower2 = boundarylower2 - 2.0    borderthird = boundarythird - 3.0# any students to skip# For 2021 to omit exception students (see Suzanne's email 11-Jun-2021 and Y2 issues xls file and Judith email 08-Jul-2021) if (int(AY) == 2021): donotprocess=['10304702','10301241','10341954','9954785','9976148','9914290']   # IDs should be strings! else: donotprocess=[]donotprocess_actual = []  # blank one that gets filled as they get to each student and print out at the end#define what must be passed e.g. lab, BSc dissertation.mustpass=['PHYS10180','PHYS10280',          'PHYS20180','PHYS20280',          'PHYS30180','PHYS30280','PHYS30880',          'PHYS40181','PHYS40182']    # define core for purpose of triggered resits i.e.  what gets resat if a student is going to have resits anyway.# This one is for studtype=1, for most Physics studentsif (AY < 2024):    isphyscore=['PHYS10071',    'PHYS10101',    'PHYS10121',    'PHYS10191',    'PHYS10302',    'PHYS10342',    'PHYS10352',    'PHYS10372',    'PHYS20101',    'PHYS20141',    'PHYS20171',    'PHYS20252',    'PHYS20312',    'PHYS20352']elif (AY == 2024):  # removed properties of matter    isphyscore=['PHYS10071',    'PHYS10101',    'PHYS10121',    'PHYS10191',    'PHYS10302',    'PHYS10342',    'PHYS10372',    'PHYS20101',    'PHYS20141',    'PHYS20171',    'PHYS20252',    'PHYS20312',    'PHYS20352']else:    isphyscore=['PHYS10071',    'PHYS10101',    'PHYS10121',    'PHYS10191',    'PHYS10302',    'PHYS10342',    'PHYS10372',    'PHYS20101',    'PHYS20141',    'PHYS20171',    'PHYS20302',  # Y2  changed in 2025    'PHYS20342',  # Y2 changed in 2025    'PHYS20352']        # add must pass to core list for when lab = 39 and is allowed a second chance with essay over the summerisphyscore += mustpass        # M+P students have a different list in *addition* to the iscore list aboveismathcore=['MATH10111', 'MATH10121', 'MATH10212', 'MATH11222', 'MATH11121', 'MATH110222', 'MATH29141', 'MATH24420']# M+P Y1 students have extra non-compensatable units# Pre-2023 - all MATHs courses in Y1 must be passed (non-compensatable)# Post-2023 - only 2 MATHs (20 credit) courses need to be passed (see Judith email 14-May-2022)not_compensatable=['MATH11121', 'MATH11022']# Set the core list depending on whether M+P student or notif (studtype == 1): iscore = isphyscoreelse: iscore = isphyscore + ismathcore# these are where units may have different credits for the marks vs progression (*make sure these are integers, not floats!)credweightunits={'PHYS20040':10,  # main general paper (doesn't count towards progression/resits, but does count towards marks)'PHYS20240':6,            # shorter version worth only 6 (M+P,Phys/Phil, 2nd/3rd year direct entry) 'PHYS20811':5,            # Professional development CD: changed from 9 to 5 in AY2021'PHYS20821':5,            # for the few students resitting the year this course still here'PHYS30010':10,           # General paper (doesn't count towards progression/resits, but does count towards marks)'PHYS30210':6,           # General paper (short version for M+P, Phys/Phil, 2nd/3rd year direct entry)'PHYS30811':3}             # Added back for those few students re-sitting               ##'PHYS20030':0,            # Peer-Assisted Study Sessions (PASS) - no marks, no credits, but here just in case #'ULGE21030':0,            # #'ULFR21030':0,#'ULJA21020':0,#'ULRU11010':0,#'MATH35012':0,#'COMP39112':0,#'MATH49102':0}if (int(AY) <= 2020): credweightunits['PHYS20811'] = 9  # Professional development CD: changed from 9 to 5 in AY2021if (int(AY) >= 2022): credweightunits['PHYS30811'] = 0  # Now 0 (Judith, priv. comm. 24-Jun-2022) # List of general papersgeneralpapers = {'PHYS20040', 'PHYS20240', 'PHYS30010', 'PHYS30210'}# List of units that can't be resit (other than 0 credit units which are not resitable) like lab, general papers etc.noresitlist={'PHYS20040', 'PHYS20240', 'PHYS30010', 'PHYS30210'}  # courses to completley ignore because they don't have a mark e.g. tutorials, PASS etc. ignore_courses={'MPHYS',         # not a course                'MPHYSON',       # not a course                'PHYS10000',    # tutorials/similar                'PHYS20000',    # tutorials/similar                'PHYS30000',    # tutorials/similar                'PHYS40000',    # tutorials/similar                'PHYS10010',                    'PHYS10020',                  'PHYS10030',    # PASS (no mark/credits)                'PHYS10022',                'PHYS11000',    # requested by Judith as not relevant                'PHYS21000',    # requested by Judith as not relevant                #'PHYS31000',   # Keep this in for study abroad for info (even if no marks)                #'PHYS41000',   # Keep this in for study abroad for info (even if no marks)                'PHYS20030',                'PHYS19990',    # PASS Peer=Assissted Self-Study                'PHYS29990',    # PASS Peer=Assissted Self-Study                'PHYS39990',    # PASS Peer=Assissted Self-Study                'PHYS49990',    # PASS Peer=Assissted Self-Study                'MATH S100',    # Math Study module (0 credited) [last 0 omitted on prurpose because of extra gap]                'MATH S200',    # Math Study module (0 credited) [last 0 omitted on prurpose because of extra gap]                'MATH S300',    # Math Study module (0 credited) [last 0 omitted on prurpose because of extra gap]                'MATH S400',    # Math Study module (0 credited) [last 0 omitted on prurpose because of extra gap]                'MATH    S',     # sometimes this format                }# Hard-coded study abroad students (because Plan doesn't always distinguish them!)if (AY == 2024):    abroad_students = {'10631719','10449856','10277160','10631099','10624576','10777366','10639338','10628702','10639485','10496435','10631478','10622219','10654157'}elif (AY == 2023):    abroad_students = {'10139041', '10448445' ,'10513047', '10255376', '10292015', '10453321', '10441740', '10449626', '10519706'}else:    abroad_students = {}# Hard-coded interrupting students (this can be in addition to any that happen to be in the interrupt_file)if (AY == 2023):    interrupt_students = {'10511668'}else:    interrupt_students = {}    # Hard-coded "for manual completion students" because of insufficient/incorrect informationif (AY == 2023):    manual_students = {'10772070'}  # resits    #manual_students = {'10824020', '10833881', '10457454', '10582856', '10639417', '10698944', '10704695', '10740586', '10747135', '10821713', '10833519'}else:    manual_students = {}# Hard-coded course exclusions (for are cases) - remember dictionaries need unique keys so separate courses by commas for each ID (,)if (AY == 2024):    manual_exclusions = {'10654029': 'COMP39112', '10100225':'MATH35001,PHYS40591', '10628683':'PHYS30611'} else:    manual_exclusions = {}    ############################################################################################################################################################################################# NOW THE RUNNING PART OF THE CODE############################################################################################################################################################################################# final filenamefilename = indir + filename# Do Carry Forward or not depending on CFfilename, OR, manually set to False to ignore CFif (CFfilename != ''): doCF = Trueelse:                  doCF = Falseif (AY == 2019 and classyear == 2): doCF = False  # no 2nd year carry forward available in 2018/19#doCF = False  # to manually override if no CF available (usually - just comment out this line with a '#' at the front)    # get input datadfallstudents = read_data(filename,studtype)  # read in file to a Pandas dataframe and remove NaNs (old 2-line format)dfallstudents, resitgrid = check_column_names(dfallstudents) # check column names/1-3 line format and change as necessarydfallstudents = extract_students_by_type(dfallstudents,classyear, studtype, resitgrid) # extract students on progdf_CF         = get_CF_data(doCF, CFfilename)    # Get CarryForward data from separate file (if exists and doCF==True)df_MCC        = read_MCC_file(MCC_filename)      # Get unit codes from MCC file(s) if exists (will override main unit codes)df_MCC_resit  = read_MCC_file(MCC_resit_filename)      # Get unit codes from MCC resit file(s) if exists (will override main unit codes)df_Y3creds_below40 = read_Y3creds_below40_file(Y3creds_below40_filename) # get Y3 credits with mark < 40 for Y4 students onlydf_interrupt  = read_interrupt_file(interrupt_filename) # Read in interrupting students by file if availabledf_boundary_notes = read_boundary_notes_file(boundary_notes_filename)  # read spreadsheet for boundary notesdf_flagCF_notes = read_flagCF_file(flagCF_file)  # read in Flag Carry Forward notesdfout         = make_output_df()                 # Empty output dataframe with all possible columns                       sids          = get_sids(dfallstudents)          # get student ids for all relevant studentscolumn_names  = dfallstudents.columns.to_list()  # get column namesnstudents     = len(sids)                        # Number of students to deal withdf_CFflags    = read_CFflags(CF_flagfile, doCF)  # If CF_flagfile exists and doCF==True, read in the data for later################################################################# loop over SIDscounter = 0           # counter for student numberall_sids = []         # for later if neededall_sids_encoded = [] # for later if neededfor anid in sids:    # info    counter += 1    print('Processing student {0:s} ({1:d}/{2:d})'.format(anid,counter,nstudents))        if (anid in donotprocess):        print('Not processed student {0:s} (in donotprocess list)'.format(anid))          donotprocess_actual.append(anid)         continue            # do most of the work    dfstudent = get_dfstudent(dfallstudents,anid,resitgrid)         # get df for this student including unnamed columns    Info      = make_Info(dfstudent,anid,classyear, ignore_courses, AY, fill_marks=fill_marks) # Make basic Info record class using input data    Info      = add_MCC_data(Info,df_MCC,keep_input_codes=keep_input_codes)   # Add unit codes from MCC file, overriding input grid codes    Info      = add_Y3creds_below40_data(Info,df_Y3creds_below40)   # Get Y3 credits with mark < 40 (Y4 only)    Info      = get_interrupt(Info,df_interrupt,interrupt_students) # See if student is interrupting (based on file or array)    Info      = get_manual(Info,manual_students)                    # See if student is in the "for manual completion" list    Info      = add_boundary_notes_data(Info,df_boundary_notes)     # Get boundary notes information from boundary notes file (if available)    Info      = add_flagCF_notes_data(Info,df_flagCF_notes)         # Get boundary notes information from boundary notes file (if available)    Info      = get_secondattempts(Info)                            # Determine which units are a 2nd attempt i.e. proper resit    Info      = add_CF_data(Info,df_CF, doCF)                       # Add CF data to Info    Info      = get_credweights(Info,credweightunits,useidx=False)  # Get credit weights using credweightunits dictionary    Info      = apply_manual_exclusions(Info, manual_exclusions)    # Manually exclude (for rare cases)    Info      = exclude_courses(Info)                               # Determine excluced courses    Info      = make_codes2(Info)                                   # Populate codes2 as alternative for 2-line output format    Info      = get_math_units(Info)                                # Determine which units are maths, marks/credits/credits takens    Info      = get_core_courses(Info,isphyscore, ismathcore)       # Determine which courses are "core" including Math for M+P students    Info      = get_projectmark(Info)                               # Determine the project mark    Info      = get_passed_failed(Info,mustpass,noresitlist)        # Determine which units are passed/failed    Info      = get_referred_units(Info)                            # Determine which units are referred (resit)    Info      = get_extremes(Info, doCF, do_extremes)               # Calculate extreme lo/hi marks (if do_extremes == True)    Info      = cap_resit_marks(Info)                               # If R2 in input (resit), then cap the mark    Info      = get_yearmark(Info)                                  # Determine average mark for the year    Info      = get_mp_yearmark(Info)                               # Determine math/physics marks separately for M+P students year mark    Info      = get_credits_above(Info)                             # Get credits at and above each level (for promotion and CS output)    Info      = get_overallmark(Info,doCF)                          # Get overall mark if CF available    Info      = get_status(Info)                                    # Determine status code for progression/degree, removing referred courses if failed        # For finalyear students only    if (Info.finalyear):        Info      = get_degclass(Info)                    # Get degree classification        Info      = apply_promotion(Info)                 # Apply "standard" promotion for borderline students in final year        Info      = apply_promotion_x(Info)               # Apply promotion for borderline students in final year using assessed credits        Info      = degclass_to_string(Info)              # Convert degree classification into a string for output        if (Info.classyear == 4):            Info = degclass_MPhys_to_BSc(Info)            # For failed MPhys output BSc based on Y1-Y3 marks if available        Info      = add_CS_award_class(Info)              # Add award/classification variables for CS sheet when final award known                    # If requested (encode_sids == True) then encode them    if (encode_sids == True):        Info   = encode_emplid(Info)        all_sids.append(Info.emplid)        all_sids_encoded.append(Info.emplid_encoded)    Info   = check_extremes(Info, do_extremes)            # See if extremes are a significant problem    Info   = check_status(Info)                           # Check status against input    Info   = cleanup_nomark_students(Info)                # Cleanup output with no year mark e.g. PP students, Europe/abroad, interrupting    Info   = cleanup_manual_students(Info)                # Cleanup output for "manual" students    Info   = check_overallmarks(Info)                     # Check yearmark /overallmark against input    Info   = check_deg_award(Info)                        # Check degree award/classification against input    dfout  = add_data_df(dfout,Info,doCF,encode_sids)     # Add data to final dataframe (including CF if doCF==True)        # for testing resits - stop before resit logic applied below    # Stop at a current student for testing only!    #if (Info.emplid_encoded == 'E22283010'):    #if (Info.emplid == '10486768'):    #    sys.exit(0)        # If resit grid then re-do the marks etc. including the new (resit) marks from the 3rd row    if (Info.resitgrid == True):        Info      = get_resit_marks(Info,dfstudent,keep_input_resit_codes=keep_input_resit_codes,fill_marks=fill_marks) # Get resit marks from 3rd row        Info      = add_MCC_data(Info,df_MCC_resit,keep_input_codes=keep_input_resit_codes)  # Add unit codes from MCC_resit file        Info      = get_manual(Info,manual_students)                # See if student is in the "for manual completion" list        Info      = get_secondattempts(Info)                        # Determine which units are a 2nd attempt i.e. proper resit                Info      = apply_resit_marks(Info)                         # Apply rules to say which resit mark to use (e.g. if capped)        Info      = get_credweights(Info,credweightunits,useidx=False)  # Get credit weights using credweightunits dictionary        Info      = exclude_courses(Info)                           # Determine excluced courses        Info      = make_codes2(Info)                                   # Populate codes2 as alternative for 2-line output format        Info      = get_projectmark(Info)                           # Determine the project mark        Info      = get_passed_failed(Info,mustpass,noresitlist)    # Determine which units are passed/failed        Info      = get_referred_units(Info)                        # Determine which units are referred (resit)        Info      = apply_capped_resit_marks(Info)                  # Make pre/post-capped marks arrays and apply other rules for resits        Info      = get_yearmark(Info)                              # Determine average mark for the year        Info      = get_mp_yearmark(Info)                           # Math/physics marks separately for M+P students year mark        Info      = get_credits_above(Info)                         # Get credits at and above each level (for promotion and CS output)        Info      = get_overallmark(Info,doCF)                      # Get overall mark if CF available        Info      = get_status(Info)                                # Status code for prog/degree removing failed referred units        Info      = cleanup_manual_students(Info)                   # Cleanup output for "manual" students        dfout     = add_resit_data_df(dfout,Info)                   # Add 3rd row (resits) to final dataframe            # Stop at a current student for testing only!    #if (Info.emplid == '10486768'):    #    sys.exit(0)    #sys.exit(0)    # Final tidying up and outputdfout     = dfout.replace(np.nan, '', regex=True)  # Remove any NaNsdfout     = apply_CFflags(dfout,df_CFflags,doCF)   # Add CF flags if availabledfout     = dfout.replace(np.nan, '', regex=True)  # Remove any NaNsmaxunit   = get_maxunit_number(dfout)              # Get maximum unit numbercolumns   = set_output_columns(Info, maxunit,doCF) # Set output columns for grid depending on student type/classyeardfout     = sort_df(dfout,Info,sort_output=sort_output) # Sort by year/overall mark if not a resitgrid/sort_output=Falsedfout2, columns2 = make_df2(dfout, Info, maxunit)  # Extra df for 2nd sheet (CS format: 1-line/student), set columns listdfout, nrows = add_codes_df(dfout)                 # Add useful codes to end of spreadsheet#dfout2           = add_header_lines(dfout2)       # Add header lines including merged Unit cells (still to be fixed)dfout2      = dfout2.replace(np.nan, '', regex=True)  # Remove any NaNsoutfilename = add_resit_tofilename(outfilename, Info) # If a resitgrid add "_resit" to outfilenamedf_to_excel(dfout, Info, columns, nrows, outfilename=outfilename, df2=dfout2, columns2=columns2) # Output to excel spreadsheetif (encode_sids == True):    write_encoded_sids(outfilename,all_sids, all_sids_encoded) # output encoded sids lookup table (encode_sids==True)# Final end statementsif (len(donotprocess_actual) > 0):    print('\nDid not process (ignored) the following students:\n')    print(donotprocess_actual)print('\nFinal output written to {0:s}'.format(outfilename))############################################################################################### End of code##############################################################################################    