# Physics and Astronomy Exam assessment code# Takes in exam grids (csv/xls/xlsx files) and produces output exam grids, with averages, degree classes etc.# This version is for AY2021/2022 and is a complete re-write of the previous version (PyAssess2021.py)# that should, in principle, work for any years.## This script requires Pandas with xlswriter (default writer for pandas, as long as v>0.16)## Checked on ????## Known issues to keep in mind:## 1. Cannot handle "PRO" marks correctly. At the moment, it just ignores this code so the mark will be incorrect!!#    N.B. they should be in the donotprocess list to ensure they are dealt with separately)# 2. Does not not fully handle Physics with Study in Europe 2-3 progression (needs S3 mark which is not available/easy to compute).#    N.B. The code treats them as normal MPhys students - the Phys/Euro coordinator will check these few by hand.# 3. Does not handle M+P aboard students with 3A or A in the programme name# # FUTURE To-do list:## 1. Make module to allow for different year rules e.g. AY=1819, AY=2021 etc.# 2. Put in specific rules for 4th year MPhys fails and determine BSc grade (p78 of handbook)# 3. Tidy up progression and try to fix any loop holes still remaining# 4. Automatically work out how many info lines are at top in case it is not standard 4.## MODIFICATION HISTORY## 23-Feb-2022  C. Dickinson    Start from scratch ##################################################################### importsimport pandas as pdimport numpy as npimport sys#from typing import Any#import matplotlib.pyplot as plt#import itertools#from decimal import Decimalpd.options.mode.chained_assignment = None  # default='warn'################################################################# CLASS DEFINITIONS################################################################# class to include all student info, but start with most important info# and include defaults for important parametersclass StudentInfo:    def __init__(self,emplid,classyear):        # Most important inputs        self.emplid = emplid        self.classyear = classyear        # Default parameters (in case not set and is needed by a function later)        self.status          = 'ACTV'  # default status        self.mitcirc         = ''        self.someunitunder30 = False        self.resitstriggered = False        self.compensation    = False        self.faillabprog     = False        self.referredcoursenames = ''        self.deferredcoursenames = ''        self.referred_idx    = []        self.deferred_idx    = []        self.compensated_idx = []        ################################################################# FUNCTIONS################################################################# used for skipping first few rows of CS grid (note system dependent)def rowskiplogic(index):    if index==0 or index==1 or index==2 or index==3:       return True    return False################################################################# read in student data (usually from a csv file but can be excel)def read_data(filename):    #print('Reading in data from {}'.format(filename))    try:        if (filename.split('.')[-1] == 'csv'): df = pd.read_csv(filename, skiprows=lambda x: +rowskiplogic(x), dtype='str',encoding = "ISO-8859-1")        else: df=pd.read_excel(filename,skiprows=lambda x: +rowskiplogiccourse(x),dtype='str')    except:        print('\nERROR reading the main input file. Please check filename and/or directory and make sure it is xls/xlsx/csv format...\n')        sys.exit(0)    # clean up dataframe of NaNs but leave Unnamed columns for now       df = df.replace(np.nan, '', regex=True)  # Remove NaNs    return df################################################################# Remove Unnamed ('^Unnamed') columns from the dataframedef remove_unnamed_columns(df):        return df.loc[:, ~df.columns.str.contains('^Unnamed')]   # remove Unnamed columns################################################################# extract relevant students from df to another df by typedef extract_students_by_type(df,classyear,studtype):    # get indices of relevant students    if (classyear == 1 or classyear == 2 or classyear == 4):        if (studtype == 1):            idx = df.index[(df['Plan'].str.contains('MPhys')) | (df['Plan'].str.contains('BSc')) & (~df['Plan'].str.contains('Math'))]        else:            idx = df.index[(df['Plan'].str.contains('Math'))]                if(classyear==31):        if (studtype == 1):            idx = df.index[(df['Plan'].str.contains('MPhys'))]        else:            idx = df.index[(df['Plan'].str.contains('MMath'))]    #  Select BScs without maths    if(classyear==32):        if(studtype==1):            idx = df.index[(df['Plan'].str.contains('BSc')) & (df['Plan'].str.contains('Physics'))]        else:            df = df.index[(df['Plan'].str.contains('BSc')) & (df['Plan'].str.contains('Math'))]    # add indices for the 2nd row of each student record    idx2 = []   # array of full indices    idx = idx.to_list()  # array of the first row index    for i in range(len(idx)):        idx2.append(idx[i])        idx2.append(idx[i]+1)    dfstudent = df.iloc[idx2]    # extract all the relevant rows          return dfstudent################################################################# get all student ids from a dataframedef get_sids(df):    #sidsname=list(df.columns)[0]       #sids=(df.loc[:,sidsname])    sids = df.iloc[:,0]  # assumes first column is SID        if (sids.size < 1):        print('No student IDs found...check file and column for SIDs (should be the 1st column)')        sys.exit(0)    sids = sids.to_list()  # make a list    sids = list(filter(None,sids))    # remove empty strings    return sids################################################################def get_dfstudent(df,sid):        dfstudent=df.loc[df['Emplid'] == sid]  # select row with studentID= target    index=dfstudent.index.to_list()          # get index number of this row        dfstudent1 = df.loc[df.index == index[0]]    dfstudent2 = df.loc[df.index == index[0]+1]        dfstudent = pd.concat([dfstudent1, dfstudent2])    return dfstudent################################################################# Make Info student record class filling with basic marks etc.# Ignores courses that are in ignore_coursesdef make_Info(df,anid,classyear,ignore_courses):    Info = StudentInfo(anid,classyear)            # Make Info record and add SID/classyear    Info.Plan = df["Plan"].values[0]    # add Plan    # Determine if progressing or finalyear    if (classyear == 32 or classyear == 4):        Info.finalyear = True    else:        Info.finalyear = False        # Determine if M+P student    if ('Math' in Info.Plan):        Info.mathstudent = True    else:        Info.mathstudent = False            # Determine if MPhys student    if ('MP' in Info.Plan or 'Mp' in Info.Plan or 'MM' in Info.Plan):        Info.mphysstudent = True    else:        Info.mphysstudent = False            columns = df.columns.to_list() # get columns    # add in simple information from input data    if ("Name" in columns): Info.Name = df["Name"].values[0]   # add Name if available    if ("Units\nTaken" in columns): Info.UnitsTaken = df["Units\nTaken"].values[0]    if ("Units\nPassed" in columns): Info.UnitsTaken = df["Units\nPassed"].values[0]    # add all the Unit information including codes    columns = df.filter(regex='^Unit\ ',axis=1).columns.to_list()  # just unit columns    coursenames = []    marks = []    marksout = []   # string for output marks (including potentially codes etc)    credits = []    codes = []    # loop over each Unit column    for col in columns:          data = df.loc[:,col].values  # get main data        coursename = data[0][0:9] # coursename is first 10 characters        if (coursename == '' or coursename in ignore_courses):  # move on if blank            continue        # add mark        if (data[1] == ''):            mark = 0            marksout.append('')        else:            mark = int(data[1]) # mark as an integer            marksout.append(data[1])  # keep as string                     # credits        lbindex = data[0].find('(')        rbindex = data[0].find(')')        thiscredit = int(data[0][lbindex + 1:rbindex])                # Get codes for any courses        idx = df.columns.get_loc(col)  # get indices of column with potential codes        code = df.iloc[1,idx+1]                # Append the valuees to the individual lists if it is a real course        coursenames.append(coursename)          marks.append(mark)  # mark        credits.append(thiscredit)        codes.append(code)            # add the lists back to the Info object    Info.coursenames = coursenames    Info.marks       = marks    Info.marksout    = marksout    Info.credits     = credits    Info.codes       = codes        return Info################################################################# get credit weights from coursename or credweights dictionary if 0# will run through all courses# unless idx set to list of indices to re-do (e.g. if compensated later need to put credweights back for these only)def get_credweights(Info,credweightunits,useidx=False):    credits = Info.credits.copy()  # get credits        # loop over those that are zero using supplied useidx or all zeroes if not    if (useidx):        idx = list([useidx])        credweights = Info.credweights.copy()   # take existing credweights    else:        credweights = credits.copy()  # does not exist yet so take credits as default        idx = [i for i, j in enumerate(credits) if j == 0]    # loop over relevant idx    for i in idx:        coursename = Info.coursenames[i]        if (useidx):            credweights[i] = credits[i]   # if possible compensation put it back to original credits                        if (credits[i] == 0):            try:                credweights[i] = credweightunits[coursename]            except:                print('*WARNING: I do not know the credit weight for ', coursename)    Info.credweights = credweights  # Add back to Info                    return Info################################################################# get core/non-core courses for physics and mathsdef get_core_courses(Info,isphysicscore, ismathscoure):    coursenames     = Info.coursenames.copy()        # Physics core courses    physicscore_idx = [i for i in range(len(coursenames)) if coursenames[i] in isphysicscore]  # get indices where core courses         # Maths core courses (N.B. Y1 all maths courses are core)    mathscore_idx = [i for i in range(len(coursenames)) if coursenames[i] in ismathscore]  # get indices where core courses         # Add any Y1 maths courses for M+P students as well since these must be passed    if (Info.classyear == 1 and Info.mathstudent == True):        math_units_idx = Info.math_units_idx.copy()        mathscore_idx.append(math_units_idx)            # Add back to Info    Info.physicscore_idx = physicscore_idx    Info.mathscore_idx   = mathscore_idx    Info.core_idx        = physicscore_idx + mathscore_idx  # all core course indices    return Info################################################################# determine exluded courses from year mark including which ones to be deferreddef exclude_courses(Info):        # find where codes exist    codes = Info.codes    idx = [i for i in range(len(codes)) if codes[i] != '']  # get indices where codes exist    # loop over each code and excluded if required    excluded_idx = []    excludedcoursenames = []    deferred_idx = []    deferredcoursenames = ''    deferredcredits = 0    creditsexcluded = 0    # loop over each code    for i in idx:        # X = exclude from year mark        if (codes[i] == 'X'):            excluded_idx.append(i)            excludedcoursenames.append(Info.coursenames[i])            creditsexcluded += Info.credweights[i]            Info.marksout[i] = Info.marksout[i] + '_X'  # decide later if compensated or not (if <30, should be X1 anyway)             Info.credweights[i] = 0        # XL = Absent from exam with reason: excludes from the calculation of the year mark and flags as a resit at 1st attempt (deferred)        if (codes[i] == 'XL'):            excluded_idx.append(i)            excludedcoursenames.append(Info.coursenames[i])            creditsexcluded += Info.credweights[i]            Info.marksout[i] = Info.marksout[i] + '_XL'            Info.credweights[i] = 0            # Defer if Y1/Y2 and if resittable (credits>0)            if ((Info.classyear == 1 or Info.classyear == 2) and Info.credits[i] > 0):                Info.marksout[i] = Info.marksout[i] + '_D'                deferred_idx.append(i)                deferredcoursenames += Info.coursenames[i] + '[1] / '                deferredcredits += Info.credits[i]        # X1 = Deferall in Y1/Y2 (same as XL)         if (codes[i] == 'X1'):            excluded_idx.append(i)            excludedcoursenames.append(Info.coursenames[i])            creditsexcluded += Info.credweights[i]            Info.marksout[i] = Info.marksout[i] + '_X1'            Info.credweights[i] = 0            # Defer if Y1/Y2 and if resittable (credits>0)            if ((Info.classyear == 1 or Info.classyear == 2) and Info.credits[i] > 0):                Info.marksout[i] = Info.marksout[i] + '_D'                deferred_idx.append(i)                deferredcoursenames += Info.coursenames[i] + '[1] / '                deferredcredits += Info.credits[i]                  # XN = Missed with no reason - do NOT exclude!        if (codes[i] == 'XN'):            Info.marksout[i] = Info.marksout[i] + '_XN'                # Add extras back to Info    Info.excluded_idx        = excluded_idx    Info.excludedcoursenames = excludedcoursenames    Info.creditsexcluded     = creditsexcluded    Info.deferred_idx        = deferred_idx    Info.deferredcoursenames = deferredcoursenames    Info.deferredcredits     = deferredcredits        return Info################################################################# Function to determine MATH units and marks/credits and also maths credits takendef get_math_units(Info):    math_units = []    coursenames = Info.coursenames    idx = [i for i in range(len(coursenames)) if 'MATH' in coursenames[i]]  # get indices if MATH unit    idx2 = [i for i in range(len(coursenames)) if 'MATH' not in coursenames[i]]  # get indices if not MATH unit    # Physics/maths credits taken    mathscreditstaken = np.sum(np.array(Info.credits)[idx])    physicscreditstaken = np.sum(np.array(Info.credits)[idx2])            # Add back to Info    Info.math_units_idx = idx    Info.physics_units_idx = idx2    Info.mathscreditstaken = mathscreditstaken    Info.physicscreditstaken = physicscreditstaken    Info.creditstaken = mathscreditstaken + physicscreditstaken        return Info################################################################# Determine the overall project mark for S1/S2 or both# taking into account special cases for non-standard projects (Phys/Phil and M+P)def get_projectmark(Info):    # If not Y3/Y4 then skip this function    if (Info.classyear == 1 or Info.classyear == 2):        return Info        # taking into account special cases for non-standard projects (Phys/Phil and M+P)    # or with only 1 project    coursenames = Info.coursenames    project1mark = -1    # -1 means no mark       project2mark = -1    # -1 means no mark        # BSc dissertation for 3rd years    if ('PHYS30880' in coursenames):        idx = coursenames.index('PHYS30880')        projectmark = Info.marks[idx]    if ('PHYS40181' in coursenames and 'PHYS40182' in coursenames):        idx = coursenames.index('PHYS40181')        project1mark = Info.marks[idx]      # S1        project1cred = Info.credits[idx]        idx = coursenames.index('PHYS40182')        project2mark = Info.marks[idx]      # S2        project2cred = Info.credits[idx]            elif ('PHYS40181' in coursenames and 'PHYS40182' not in coursenames):        idx = coursenames.index('PHYS40181')        project1mark = Info.marks[idx]      # S1        project1cred = Info.credits[idx]            elif ('PHYS40181' not in coursenames and 'PHYS40182' in coursenames):        idx = coursenames.index('PHYS40182')        project2mark = Info.marks[idx]      # S2        project2cred = Info.credits[idx]                    # for Phys/Phil who do an essay for one project - only worth 10 credits c.f. 20 credits for physics    if ('PHIL40000' in coursenames and project1mark==-1):        idx = coursenames.index('PHIL40000')        project1mark = Info.marks[idx]        project1cred = Info.credits[idx]    elif ('PHIL40000' in coursenames and project2mark==-1):        idx = coursenames.index('PHIL40000')        project2mark = Info.marks[idx]        project2cred = Info.credits[idx]            # for Maths/Phys Maths projects only 15 credits c.f. 20 credits for physics    if ('MATH40011' in coursenames and project1mark==-1):        idx = coursenames.index('MATH40011')        project1mark = Info.marks[idx]        project1cred = Info.credits[idx]    if ('MATH40022' in coursenames and project2mark==-1):        idx = coursenames.index('MATH40022')        project2mark = Info.marks[idx]        project2cred = Info.credits[idx]    # combine S1/S2 project marks    if (project1mark >=0 and project2mark >=0):        projectmark = ((project1mark*project1cred)+(project2mark*project2cred))/float(project1cred+project2cred)        projectcred = project1cred+project2cred    elif (project1mark >=0 and project2mark == -1):        projectmark = project1mark        projectcred = project1cred    elif (project2mark >=0 and project1mark == -1):        projectmark = project2mark        projectcred = project2cred        # Add to Info    Info.projectmark = round(projectmark+0.000001)    Info.projectcred = projectcred    return Info################################################################# Find which units are passed/faileddef get_passed_failed(Info,mustpass,noresitlist):    marks = Info.marks.copy()  # get numerical marks        # get passed marks/credits    passed_idx = np.array([i for i in range(len(marks)) if marks[i] >= 39.95])  # passed marks    if (len(passed_idx) > 0):        creditspassed = np.sum(np.array(Info.credits)[passed_idx])  # Sum of passed credits    else:        creditspassed = 0            # get nominally failed marks/credits    failed_idx = np.array([i for i in range(len(marks)) if marks[i] < 39.95])  # failed marks    if (len(failed_idx) > 0):        creditsfailed = np.sum(np.array(Info.credits)[failed_idx])  # Sum of "failed" credits    else:        creditsfailed = 0            # Store locations of units in 30-39 range for possible compensation    units30_39_idx = np.array([i for i in range(len(marks)) if (marks[i] >= 29.95 and marks[i] < 39.95)])        # loop through nominally failed courses and determine outcome at end    for i in failed_idx:        # has this course been failed when it must be passed i.e. lab,  project?        if (Info.coursenames[i] in mustpass):            Info.faillabprog = True        #if any course is < 30%, resits triggered for 1st/2nd year (also trigger resits later)        if(marks[i]<29.95 and Info.coursenames[i] not in noresitlist and Info.credits[i] > 0 and i not in Info.excluded_idx):            Info.someunitunder30=True                    # Add back to Info    Info.passed_idx = passed_idx    Info.creditspassed = creditspassed    Info.failed_idx = failed_idx    Info.creditsfailed = creditsfailed    Info.units30_39_idx = units30_39_idx        return Info################################################################# Determine which units are to be referred (resit) or can be compensateddef get_referred_units(Info):        # If not Y1/Y2 then skip this function (no resits in Y3/Y4)    if (Info.classyear != 1 and Info.classyear != 2):        return Info    # if not more than 40 credits < 40% and none below 30%, they can all be compensated (except Y1 maths)    if (Info.someunitunder30==0 and Info.faillabprog==0 and (Info.creditsfailed-Info.deferredcredits <= 40)):        Info.compensation = True        for idx in Info.units30_39_idx:            if (Info.classyear == 1 and Info.mathstudent == True and idx in Info.math_units_idx and idx not in Info.deferred_idx):                Info.referred_idx.append(idx)   # Any Y1 maths units are referred for M+P students                Info.referredcoursenames += Info.coursenames[idx] + ' / '            else:                Info.marksout[idx] = Info.marksout[idx] + '_C'   # add code to show it is compensated                Info.compensated_idx.append(idx)                if ((Info.codes[idx].find('XN') > 0) and (Info.codes[idx].find('X') < 0)): # only if not excluded                    Info = get_credweights(Info,credweightunits,useidx=idx)     # put credit weight back in case it has been zeroed                    print('*', idx, Info.coursenames[idx],Info.credweights[idx])                    # if any mark <30% must be resat and triggers resits of any core course 30-39% (if <40 credits 30-39%)    if (Info.someunitunder30==1 and Info.faillabprog==0 and (Info.creditsfailed-Info.deferredcredits <= 40)):        Info.resitstriggered = True        for idx in Info.failed_idx:            if (Info.marks[idx] < 29.95 and idx not in Info.deferred_idx):  # if <30% must be resat                Info.referred_idx.append(idx)                  Info.marksout[idx] = Info.marksout[idx] + '_R'                Info.referredcoursenames += Info.coursenames[idx] + ' / '            elif (idx in Info.units30_39_idx and idx in Info.core_idx and idx not in Info.deferred_idx): # if 30-39 resit if core course                Info.referred_idx.append(idx)                  Info.marksout[idx] = Info.marksout[idx] + '_R'                Info.referredcoursenames += Info.coursenames[idx] + ' / '            elif (idx not in Info.deferred_idx):        # else will be compensated                Info.marksout[idx] = Info.marksout[idx] + '_C'                Info.compensated_idx.append(idx)                Info.compensation = True                    # if > 40 credits at 30-39%, all core units must be resat    if ((Info.creditsfailed-Info.deferredcredits) > 40):        Info.resitstriggered = True        for idx in Info.failed_idx:  # courses < 30% must be resat            if (Info.marks[idx] < 29.95 and idx not in Info.deferred_idx):                Info.referred_idx.append(idx)                  Info.marksout[idx] = Info.marksout[idx] + '_R'                Info.referredcoursenames += Info.coursenames[idx] + ' / '            elif (idx in Info.core_idx and idx not in Info.deferred_idx):  # only for core courses                Info.referred_idx.append(idx)                  Info.marksout[idx] = Info.marksout[idx] + '_R'                Info.referredcoursenames += Info.coursenames[idx] + ' / '            elif (idx not in Info.deferred_idx): # else must be compensated as an option                Info.compensation = True                Info.compensated_idx.append(idx)                Info.marksout[idx] = Info.marksout[idx] + '_C'                    return Info################################################################# get overall average year markdef get_year_mark(Info):    marks = np.array(Info.marks.copy())    credweights = np.array(Info.credweights.copy())    sumcredweights = np.sum(credweights)    Info.sumcredweights = sumcredweights    if (sumcredweights > 0):        Info.yearmark = round(np.sum(marks*credweights)/sumcredweights + 0.000001,1)  # round to 1 d.p.    else:        Info.yearmark = 0.0        return Info################################################################# get overall average year mark for Physics and Maths separately including overall year mark (for M+P students only)def get_mp_year_mark(Info):        marks = np.array(Info.marks)    credweights = np.array(Info.credweights)        # Physics    idx = Info.physics_units_idx    physicscredweights = np.sum(credweights[idx])    if (physicscredweights > 0):        physics_yearmark = round(np.sum(marks[idx]*credweights[idx])/physicscredweights + 0.000001,1)  # round to 1 d.p.    else:        physics_yearmark = 0.0            # Math    idx = Info.math_units_idx    mathcredweights = np.sum(credweights[idx])    if (mathcredweights > 0):        math_yearmark = round(np.sum(marks[idx]*credweights[idx])/mathcredweights + 0.000001,1)  # round to 1 d.p.    else:        math_yearmark = 0.0            # Overall year mark replaced by weighted average of M+P separately (for M+P students only)    if (Info.mathstudent):        if (physicscredweights >0 and mathcredweights >0 and Info.mathstudent):            yearmark = (physics_yearmark*physicscredweights + math_yearmark*mathcredweights)/(physicscredweights+mathcredweights)        else:            yearmark = 0.0        Info.yearmark           = round(yearmark+0.000001,1)            # Add back to Info    Info.physicscredweights = physicscredweights    Info.mathcredweights    = mathcredweights    Info.physics_yearmark   = round(physics_yearmark+0.000001,1)    Info.math_yearmark      = round(math_yearmark+0.00001,1)        # Add O/M/P string for output    Info.year_omp           = str(Info.yearmark) + ' / ' + str(Info.math_yearmark) + ' / ' + str(Info.physics_yearmark)        return Info################################################################# get status for progression# remove referred/deferred info if already faileddef get_status(Info):    if (Info.deferredcoursenames != ''):        Info.status = 'A/D'         # student with deferrals    if (Info.referredcoursenames != ''):         Info.status = 'REVW'        # student with resits            # MPhys borderline/move to BSc students (for Y2 and above)    if (Info.mphysstudent == True and Info.classyear > 1):        if (Info.yearmark < 54.95 and Info.deferredcredits != 0):            Info.status = 'R/X'        if (Info.yearmark < 51.95 and Info.deferredcredits != 0):            Info.status = 'R/BSc'    if (Info.faillabprog == True):  # student has failed lab        Info.status = 'FAIL'    # If yearmark < 40% or fewer than 60 credits, then fail     if ((Info.creditspassed + Info.deferredcredits) < 60):        Info.status = 'FAIL'    # Remove referred/deferred courses if already failed    if (Info.status == 'FAIL'):        for idx in Info.referred_idx: # remove referred codes            spos = Info.marksout[idx].find('_R')            Info.marksout[idx] = Info.marksout[idx][0:spos]        for idx in Info.deferred_idx: # remove deferred codes            spos = Info.marksout[idx].find('_D')            Info.marksout[idx] = Info.marksout[idx][0:spos]        for idx in Info.compensated_idx: # remove compensated codes            spos = Info.marksout[idx].find('_C')            Info.marksout[idx] = Info.marksout[idx][0:spos]                            # now remove other relevant arrays        Info.referred_idx = []        Info.referredcoursenames = ''        Info.deferred_idx = []        Info.deferredcoursenames = ''                                            return Info################################################################# convert degree class to a string for output griddef degclass_to_string(progtaken,degclass):    # deg classification    degclass_dict = {        4:"1",        3:"2:1",        2:"2:2",        1:"3",        0:"Ord.",        -1:"Fail",        -2:"NOT SET!!!"}    # degree type    degstr = progtaken.split('(')[0] + ' '                return degstr + degclass_dict[degclass]################################################################# make basic output dataframe def make_output_df():    # make list of all possible columns    columns = ['Emplid', 'Name', 'Plan', 'Unit 1', 'Unit 2', 'Unit 3', 'Unit 4', 'Unit 5', 'Unit 6', 'Unit 7', 'Unit 8', 'Unit 9', 'Unit 10', 'Unit 11', 'Unit 12', 'Unit 13', 'Unit 14', 'Unit 15', 'Unit 16', 'Unit 17', 'Unit 18', 'Unit 19', 'Unit 20', 'Credits Taken', 'Credits Passed', 'Year Mark', 'Overall Mark', 'Year O/M/P', 'Status', 'Referred', 'Deferred','Resits', 'Mit Circ']        # make dataframe    df = pd.DataFrame(columns=columns)    return df################################################################# add column data from this student (Info) to the output student dataframedef add_data_df(df,Info):    # First few columns    new_row1 = {'Emplid': Info.emplid, 'Name': Info.Name, 'Plan': Info.Plan}    new_row2 = {'Emplid': '', 'Name': '', 'Plan': ''}        # Add each unit that exists    for i in range(len(Info.coursenames)):           unit_str = 'Unit ' + str(i+1)         new_row1[unit_str] = Info.coursenames[i]        new_row2[unit_str] = Info.marksout[i]     # Rest of default columns    new_row1['Credits Taken']      = Info.creditstaken    new_row1['Credits Passed']     = Info.creditspassed    new_row1['Year Mark']          = Info.yearmark    new_row1['Year O/M/P']         = Info.year_omp    new_row1['Status']             = Info.status    new_row1['Mit Circ']           = Info.mitcirc    new_row1['Referred']           = Info.referredcoursenames    new_row1['Deferred']           = Info.deferredcoursenames    new_row1['Resits']             = Info.deferredcoursenames + Info.referredcoursenames        new_row2['Credits Taken']      = ''    new_row2['Credits Passed']     = ''    new_row2['Year Mark']          = ''    new_row2['Year O/M/P']         = ''    new_row2['Status']             = ''    new_row2['Mit Circ']           = ''    new_row2['Referred']           = ''    new_row2['Deferred']           = ''    new_row2['Resits']             = ''            # add the rows to the df    df = df.append(new_row1, ignore_index=True)    df = df.append(new_row2, ignore_index=True)        return df################################################################# Get maximum unit number used in a dataframe that actually contains datadef get_maxunit_number(df):    maxunit = 0  # counter    for i in range(20):  # max units will be 20        unit_str = 'Unit ' + str(i+1)        data     = df[unit_str].tolist()   # data for this unit number        if (any(data) == True): # check if any non-empty strings            maxunit += 1        return maxunit################################################################# Set output columns for output spreadsheet depending on student type/yeardef set_output_columns(Info,maxunit):    # First few columns are same for all    columns = ['Emplid', 'Name', 'Plan']    # Units where data exist    for i in range(maxunit):        unit_str = 'Unit ' + str(i+1)        columns.append(unit_str)    # Credits passed/taken    columns.append('Credits Taken')    columns.append('Credits Passed')    # Marks columns depending on years/student type    # Previous years marks    if (Info.classyear == 2):        columns.append('Phys 1')    if (Info.classyear == 31 or Info.classyear == 32):        columns.append('Phys 2')    if (Info.classyear == 4):        columns.append('Phys 3')    # Previous maths marks if M+P student    if (Info.mathstudent == True):        if (Info.classyear == 2):            columns.append('Maths 1')        if (Info.classyear == 31 or Info.classyear == 32):            columns.append('Maths 2')        if (Info.classyear == 4):            columns.append('Maths 3')             # Year mark    if (Info.mathstudent == True):  # Maths students have O/M/P        columns.append('Year O/M/P')    else:        columns.append('Year Mark')    # Mit Circ    columns.append('Mit Circ')    # Deg Class if final year otherwise Status if not final year    if (Info.finalyear == True):        columns.append('Deg Class')    else:        columns.append('Status')    # Resits for Y1/Y2    if (Info.classyear == 1 or Info.classyear == 2):        columns.append('Resits')            return columns################################################################# sort df by year mark (progressing) / overall mark (final year)def sort_df(df,Info):    # progressing students    if (Info.classyear==1 or Info.classyear==2 or Info.classyear==31):        for i in np.arange(0,df.shape[0]-1,2): df["Year Mark"].values[i+1] = df["Year Mark"].values[i]        df.sort_values(by="Year Mark",ascending=False,inplace=True,kind='mergesort')        for i in np.arange(0,df.shape[0]-1,2): df["Year Mark"].values[i+1] = ''        # graduating students    if (Info.classyear==32 or Info.classyear==4):        for i in np.arange(0,df.shape[0]-1,2): df["Overall Mark"].values[i+1] = df["Overall Mark"].values[i]        df.sort_values(by="Overall Mark",ascending=False,inplace=True,kind='mergesort')        for i in np.arange(0,df.shape[0]-1,2): df["Overall Mark"].values[i+1] = ''    return df################################################################# Add useful codes to end of spreadsheetdef add_codes_df(df):    code_info = np.array([['',''],                ['Key:',''], ['',''],                 ['Mit Circ','Mitigating Circumstances'],                 ['#','Mit Circs not accepted'],                ['#*','Mit Circs acc; no action'],                ['#**','Mit Circs acc; action taken'],                ['',''],                ['ACTV','Met progression criteria (BSc/MPhys)'],                ['REVW','Review (resits)'],                ['A/D', 'Deferred units'],                ['R/X','MPhys student not achieved 55%'],                ['R/BSc','MPhys student not achieved 52%'],                ['FAIL','Failed due to <40% overall or <40% in lab or <60 credits'],                ['',''],                ['XL','Absent from exam, with reason'],                ['XN','Absent from exam, no reason'],                ['X','Mark excluded'],                ['X1','Resit at first attempt'],                ['',''],                ['XX_P1 (YY)', 'XX post-penalty mark, YY pre-penalty mark (>=40%)'],                ['XX_P2 (YY)', 'XX post-penalty mark, YY pre-penalty mark (30-39%)'],                ['XX_P3 (YY)', 'XX post-penalty mark, YY pre-penalty mark (<30%)'] ])        nrows = np.shape(code_info)[0]   # number of extra rows to add    tempdf_single = df[0:1].copy()  # single line temporary df    tempdf = tempdf_single.copy()  # tempdf to be added to main dataframe    while (tempdf.count()[0] <= nrows):  # copy extra rows if they required otherwise will not get full list of codes        tempdf = pd.concat([tempdf,tempdf_single])        #print(tempdf.count()[0])    tempdf[:] = ''  # blank values    for i in np.arange(nrows):  # add code info        tempdf[columns[0]][i:i+1] = code_info[i,0]        tempdf[columns[1]][i:i+1] = code_info[i,1]        #print(tempdf[-1:].values[0])    df = pd.concat([df,tempdf])   # add df's together    return df, nrows################################################################# output to Excel spreadsheet (strings_to_numbers option so not to store unit numbers as text)def df_to_excel(df, columns, nrows, outfilename='test.xlsx',sheet_name='Sheet 1'):    try:        writer = pd.ExcelWriter(outfilename, engine='xlsxwriter',engine_kwargs={'options': {'strings_to_numbers': True}})    except:        print('\nERROR writing out file. Please check directory...\n')        sys.exit(0)        # output columns to excel spredsheet directly from Data Frame    df.to_excel(writer,index=False,sheet_name=sheet_name,columns=columns)    # Change column width/formatting before finally writing out    workbook = writer.book    worksheet = writer.sheets[sheet_name]    i = 0    for column_str in columns: # loop over each column        col_idx = i  # df.columns.get_loc(column_str)        # set the widths        if (column_str == 'Emplid'): col_width=9        elif (column_str == 'Name'): col_width=15        elif (column_str == 'Plan'): col_width=20        elif (column_str.find('Unit') >= 0): col_width=9        elif (column_str.find('Credits') >= 0): col_width=9        elif (column_str.find('Final Year Physics Mark') >=0): col_width=18        elif (column_str.find('Final Year Maths Mark') >=0): col_width=16        elif (column_str.find('Overall Physics') >=0): col_width=15        elif (column_str.find('Overall Maths') >=0): col_width=13        elif (column_str.find('Phys') >= 0): col_width=6        elif (column_str.find('Maths') >= 0): col_width=7        elif (column_str.find('Year 3 Mark') >=0): col_width=8        elif (column_str.find('O/M/P') >=0): col_width=14        elif (column_str.find('Status') >=0): col_width=8        elif (column_str.find('Deg Class') >= 0): col_width=15        elif (column_str.find('Resits') >= 0): col_width=15        elif (column_str.find('Mit') >= 0 or column_str.find('Sp') >=0): col_width=6        else: col_width=12  # default column width        writer.sheets[sheet_name].set_column(col_idx, col_idx, col_width)        i += 1        # make banded rows and slightly larger cells for easier viewing    #format1_pale = workbook.add_format({'bg_color': '#FFFFCC'})    format1_grey = workbook.add_format({'bg_color': '#E0E0E0'})    cellheight = 17  # (Excel default is 15)    nrows = df.count()[0]-nrows    for row in range(1, nrows, 2):        worksheet.set_row(row, cellheight, cell_format=format1_grey)        # Write out and finish    writer.save()    return None################################################################    ################################################################################################################################# INPUTS AND READIING DATA################################################################# Define year (1=1st year, 2=2nd year, 31=3rd prog, 32=3rd complete ,4=4th year)classyear=1# Student type (1=physics, 2=Maths+Physics)#########studtype=1# Input directory for files (default is './' for current directory)indir = './'# Late penalty filename - put these in to store pre-penalty scores with _P codes# _P1 = premark >40, _P2 = premark =30-30, _P3 = premark < 30# If set to blank ('') then nothing is applid# File should be for both semesters, with col1=coursename, col2=ID, col3=pre-penalty mark, col4=post-penalty mark#late_penalty_filename = ''#late_penalty_filename = './data2021/Late-Penalties-both-semesters-JMcG-.xlsx'# Input and output files for each cohort# Input filename (filename) can be .csv or .xls/.xlsx - the code will automatically read it in whichever the format if(classyear==1):    filename = './data1819/1styr_28_06_19_postmcc.csv'    #filename = './data2021/1st year exam grid_10.06.21.csv'    #filename = './data2021/1st year exam grid_02.07.21_mcc anonymous.xlsx'        # output filename    if (studtype==1): outfilename = '1styear_Physics.AY2018.prelimfinal.xlsx'   # Physics filename    else: outfilename = '1styear_MathsPhysics.AY2018.prelimfinal.xlsx'   # M+P filename    elif (classyear == 2):    #filename = '/data1819/2ndyr_26_06_19.csv'    #filename = './data2021/2nd year exam grid_25.06.21.csv'    #filename = './data2021/2nd year exam grid_02.07.21_mcc anonymous.xlsx'    filename = './data2021/2nd year exam grid_16.07.21.xlsx'    # If CFfilename to be used, set deganalysis to 1 (below)    CFfilename = './data2021/2nd year carry forward.xlsx'        # output filename    if (studtype==1): outfilename = '2ndyear_Physics.AY2021.prelimfinal.xlsx'   # Physics filename    else: outfilename = '2ndyear_MathsPhysics.AY2021.prelimfinal.xlsx'   # M+P filenameelif(classyear==32):    #filename = './data1819/3rdyr_18_06_19_external.csv'    #filename = './data2021/3rd year exam grid_10.06.21.csv'    #filename = './data2021/3rd year exam grid_07.07.21_mcc anonymous.xlsx'    filename = './data2021/3rd year exam grid_10.07.21_postmcc.xlsx'        #CFfilename = './data1819/3rdyr_carryforward.csv'    CFfilename = './data2021/3rd year carry forward.xlsx'    # output filename    if (studtype==1): outfilename = 'FinalYear_BSc_Physics.AY2021.prelimfinal.xlsx'   # Physics filename    else: outfilename = 'FinalYear_BSc_MathsPhysics.AY2021.prelimfinal.xlsx'   # M+P filename    elif (classyear == 31):    #filename = '/data1819/3rdyr_18_06_19_external.csv'    #filename = './data2021/3rd year exam grid_10.06.21.csv'    #filename = './data2021/3rd year exam grid_07.07.21_mcc anonymous.xlsx'    filename = './data2021/3rd year exam grid_10.07.21_postmcc.xlsx'        #CFfilename = './data1819//3rdyr_carryforward.csv'    CFfilename = './data2021/3rd year carry forward.xlsx'    # output filename    if (studtype==1): outfilename = '3rdyear_MPhys.AY2021.prelimfinal.xlsx'   # Physics filename    else: outfilename = '3rdyear_MMath.AY2021.prelimfinal.xlsx'   # M+P filename    elif(classyear==4):    #filename = '/data1819/4thyr_18_06_19_external.csv'    #filename = './data2021/4th year exam grid_10.06.21.csv'    #filename = './data2021/4th year exam grid_07.07.21_mcc anonymous.xlsx'    filename = './data2021/4th year exam grid_10.07.21_with year abroad flags.xlsx'        #CFfilename='./data1819/4thyr_carryforward.csv'    CFfilename = './data2021/4th year carry forward.xlsx'    # output filename    if (studtype==1): outfilename = 'FinalYear_MPhys.AY2021.prelimfinal.xlsx'   # Physics filename    else: outfilename = 'FinalYear_MMath.AY2021.prelimfinal.xlsx'   # M+P filenameelse:    print('*ERROR: Classyear not defined correctly (should be 1, 2, 31, 32, or 4)')    sys.exit(0)    # final filenamefilename= indir + filename################################################################# some data definitions################################################################# Credits requiredcreditstogetMPHYS = 80  creditstogetBScgood=80creditstogetBSclower=60creditstogetMPHYSalgA = 75 # Used for algA creditstogetalgB = 70  # Used for algB# testing only for 2018/19 data! ***REMOVE/COMMENT OUT!!!creditstogetMPHYS = 80  creditstogetBScgood=80creditstogetBSclower=60creditstogetMPHYSalgA = 80 # Used for algA creditstogetalgB = 70  # Used for algB# boundaries for degree class (2 d.ps because marks are stored to 1 d.p.)boundaryfirst=69.95boundaryupper2=59.95boundarylower2=49.95boundarythird=39.95# borderlines for promotion consideration borderfirst = boundaryfirst - 3.0borderupper2 = boundaryupper2 - 3.0borderlower2 = boundarylower2 - 3.0borderthird = boundarythird - 4.0# any students to skip# For 2021 to omit exception students (see Suzanne's email 11-Jun-2021 and Y2 issues xls file and Judith email 08-Jul-2021) donotprocess={'10304702','10301241','10341954','9954785','9976148','9914290'}   # IDs should be strings! #donotprocess={}  # FOR TESTING ONLY!# define core for purpose of triggered resits i.e.  what gets resat if a student is going to have resits anyway.# This one is for studtype=1, for most Physics studentsisphysicscore={'PHYS10071','PHYS10101','PHYS10121','PHYS10191','PHYS10302','PHYS10342','PHYS10352','PHYS10372','PHYS20101','PHYS20141','PHYS20171','PHYS20252','PHYS20312','PHYS20352'}# M+P students have a different list in *addition* to the iscore list above# (only need 2nd year courses because all MATHs courses in Y1 must be passed - these courses add later when they are known)ismathscore={'MATH20401', 'MATH29142'}# Set the core list depending on whether M+P student or notif (studtype == 1): iscore = isphysicscoreelse: iscore = isphysicscore.union(ismathscore)#define what must be passed e.g. lab, BSc dissertation.mustpass={'PHYS10180','PHYS10280',          'PHYS20180','PHYS20280',          'PHYS30180','PHYS30280','PHYS30880',          'PHYS40181','PHYS40182'}# these are where units may have different credits for the marks vs progression (*make sure these are integers, not floats!)credweightunits={'PHYS20040':10,  # main general paper (doesn't count towards progression/resits, but does count towards marks)'PHYS20240':6,            # shorter version worth only 6 (M+P,Phys/Phil, 2nd/3rd year direct entry) 'PHYS20811':5,            # Professional development CD: changed from 9 to 5 in AY2021'PHYS20821':5,            # for the few students resitting the year this course still here'PHYS30010':10,           # General paper (doesn't count towards progression/resits, but does count towards marks)'PHYS30210':6,           # General paper (short version for M+P, Phys/Phil, 2nd/3rd year direct entry)'PHYS30811':3}             # Added back for those few students re-sitting#'PHYS20030':0,            # Peer-Assisted Study Sessions (PASS) - no marks, no credits, but here just in case #'ULGE21030':0,            # #'ULFR21030':0,#'ULJA21020':0,#'ULRU11010':0,#'MATH35012':0,#'COMP39112':0,#'MATH49102':0}noresitlist={}  # any units that can't be resit (other than 0 credit units (which are not resitable) like lab etc.)# courses to completley ignore because they don't have a mark e.g. tutorials, PASS etc. ignore_courses={'MPHYS',         # not a course                'MPHYSON',       # not a course                'PHYS10000',    # tutorials/similar                'PHYS20000',    # tutorials/similar                'PHYS30000',    # tutorials/similar                'PHYS40000',    # tutorials/similar                'PHYS10010',                'PHYS10020',                'PHYS10030',                'PHYS10022',                'PHYS11000',                'PHYS21000',                'PHYS31000',                'PHYS41000',                'PHYS20030',                'PHYS19990',    # PASS Peer=Assissted Self-Study                'PHYS29990',    # PASS Peer=Assissted Self-Study                'PHYS39990',    # PASS Peer=Assissted Self-Study                'PHYS49990',    # PASS Peer=Assissted Self-Study                'MATH S100',    # Maths Study module (0 credited) [last 0 omitted on prurpose because of extra gap]                'MATH S200',    # Maths Study module (0 credited) [last 0 omitted on prurpose because of extra gap]                'MATH S300',    # Maths Study module (0 credited) [last 0 omitted on prurpose because of extra gap]                'MATH S400',    # Maths Study module (0 credited) [last 0 omitted on prurpose because of extra gap]                'MATH    S',     # sometimes this format                'ULGE12010',                'ULSP21030',}                # BELOW IS JUST FOR TESTING WITH 2018/19 DATA!! ***REMOVE/COMMENT OUT!!!#credweightunits={'PHYS20040':10,#'PHYS20240':6,  #6  #'PHYS20811':9,  #9#'PHYS20821':5,#'PHYS30010':10,#'PHYS30210':6,#'PHYS30811':3,#'PHYS20030':0,#'ULGE21030':0,#'ULFR21030':0,#'ULJA21020':0,#'ULRU11010':0,#'MATH35012':0,#'COMP39112':0,#'MATH49102':0#}    ############################################################################################################################################################################################# NOW THE RUNNING PART OF THE CODE############################################################################################################################################################################################# get input datadfallstudents = read_data(filename)              # read in file to a Pandas dataframe and remove NaNsdfallstudents = extract_students_by_type(dfallstudents,classyear, studtype) # extract relevant students on programmedfout         = make_output_df()                 # Empty output dataframe with all possible columns                            sids          = get_sids(dfallstudents)          # get student ids for all relevant studentscolumn_names  = dfallstudents.columns.to_list()  # get column namesnstudents     = len(sids)                        # Number of students to deal with# loop over SIDscounter = 0           # counter for student numberfor anid in sids:    # info    counter += 1    print('Processing student ID {0:s} ({1:d}/{2:d})'.format(anid,counter,nstudents))    # do most of the work    dfstudent = get_dfstudent(dfallstudents,anid)                   # get df for this student including unnamed columns    Info      = make_Info(dfstudent,anid,classyear, ignore_courses) # Make basic Info record class using input data (courses/marks/credits etc)    Info      = get_credweights(Info,credweightunits,useidx=False)  # Get credit weights using credweightunits dictionary    Info      = exclude_courses(Info)                               # Determine excluced courses    Info      = get_math_units(Info)                                # Determine which units are maths, marks/credits/credits takens    Info      = get_core_courses(Info,isphysicscore, ismathscore)   # Determine which courses are "core" including MATHs for M+P students    Info      = get_projectmark(Info)                               # Determine the project mark    Info      = get_passed_failed(Info,mustpass,noresitlist)        # Determine which units are passed/failed    #print(Info.credweights)    Info      = get_referred_units(Info)                            # Determine which units are referred (resit)    #print(Info.credweights)    Info      = get_year_mark(Info)                                 # Determine average mark for the year    Info      = get_mp_year_mark(Info)                              # Determine maths/physics marks separately for M+P students year mark    Info      = get_status(Info)                                    # Determine status code for progression/degree, removing referred courses if failed        dfout     = add_data_df(dfout,Info)                             # Add data to final dataframe    # testing    #print(Info.marksout)    #print(Info.codes)    #print(Info.credits)    #print(Info.credweights)    #print(Info.yearmark)    #if (anid == '10304562'):    #    sys.exit(0)dfout     = dfout.replace(np.nan, '', regex=True)  # Remove NaNsmaxunit   = get_maxunit_number(dfout)                                 # Get maximum unit numbercolumns   = set_output_columns(Info, maxunit)                         # Set output columns for output spreadsheet depending on student type/classyear dfout     = sort_df(dfout,Info)                                       # Sort students by year mark (progressing) or overall mark (final year)dfout, nrows = add_codes_df(dfout)                                       # Add useful codes to end of spreadsheetdf_to_excel(dfout, columns, nrows, outfilename=outfilename,sheet_name='Sheet 1') # Output to excel spreadsheet    