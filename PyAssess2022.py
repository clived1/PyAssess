# Physics and Astronomy Exam assessment code# Takes in exam grids (csv/xls/xlsx files) and produces output exam grids, with averages, degree classes etc.# This version is for AY2021/2022 and is a complete re-write of the previous version (PyAssess2021.py)# that should, in principle, work for any years.## This script requires Pandas with xlswriter (default writer for pandas, as long as v>0.16)## Checked on ????## Known issues to keep in mind:## 1. Cannot handle "PRO" marks correctly. At the moment, it just ignores this code so the mark will be incorrect!!#    N.B. they should be in the donotprocess list to ensure they are dealt with separately)# 2. Does not not fully handle Physics with Study in Europe 2-3 progression (needs S3 mark which is not available/easy to compute).#    N.B. The code treats them as normal MPhys students - the Phys/Euro coordinator will check these few by hand.# 3. Does not handle M+P aboard students with 3A or A in the programme name# # FUTURE To-do list:## 1. Make module to allow for different year rules e.g. AY=1819, AY=2021 etc.# 2. Put in specific rules for 4th year MPhys fails and determine BSc grade (p78 of handbook)# 3. Tidy up progression and try to fix any loop holes still remaining# 4. Automatically work out how many info lines are at top in case it is not standard 4.## MODIFICATION HISTORY## 23-Feb-2022  C. Dickinson    Start from scratch ##### Row definitions for dfstudent# Row 0 = Headers/name/coursenames etc.# Row 1 = Original marks# Row 2 = Codes (if they exist)# Row 3 = Course credits# Row 4 = Credit weights (used for mean)################################################################# importsimport pandas as pdimport numpy as npimport sys#from typing import Any#import matplotlib.pyplot as plt#import itertools#from decimal import Decimalpd.options.mode.chained_assignment = None  # default='warn'################################################################# CLASS DEFINITIONS################################################################# class to include all student info, but start with most important info# and include deafults for important parametersclass StudentInfo:    def __init__(self,emplid,classyear):        # Most important inputs        self.emplid = emplid        self.classyear = classyear        # Default parameters (in case not set and is needed by a function later)        self.someunitunder30 = False        ################################################################# FUNCTIONS################################################################# used for skipping first few rows of CS grid (note system dependent)def rowskiplogic(index):    if index==0 or index==1 or index==2 or index==3:       return True    return False################################################################# read in student data (usually from a csv file but can be excel)def read_data(df):    try:        if (filename.split('.')[-1] == 'csv'): df = pd.read_csv(filename, skiprows=lambda x: +rowskiplogic(x), dtype='str',encoding = "ISO-8859-1")        else: df=pd.read_excel(filename,skiprows=lambda x: +rowskiplogiccourse(x),dtype='str')    except:        print('\nERROR reading the main input file. Please check filename and/or directory and make sure it is xls/xlsx/csv format...\n')        sys.exit(0)    # clean up dataframe of NaNs but leave Unnamed columns for now       df = df.replace(np.nan, '', regex=True)  # Remove NaNs    return df################################################################# Remove Unnamed ('^Unnamed') columns from the dataframedef remove_unnamed_columns(df):        return df.loc[:, ~df.columns.str.contains('^Unnamed')]   # remove Unnamed columns################################################################# extract relevant students from df to another df by typedef extract_students_by_type(df,classyear,studtype):    # get indices of relevant students    if (classyear == 1 or classyear == 2 or classyear == 4):        if (studtype == 1):            idx = df.index[(df['Plan'].str.contains('MPhys')) | (df['Plan'].str.contains('BSc')) & (~df['Plan'].str.contains('Math'))]        else:            idx = df.index[(df['Plan'].str.contains('Math'))]                if(classyear==31):        if (studtype == 1):            idx = df.index[(df['Plan'].str.contains('MPhys'))]        else:            idx = df.index[(df['Plan'].str.contains('MMath'))]    #  Select BScs without maths    if(classyear==32):        if(studtype==1):            idx = df.index[(df['Plan'].str.contains('BSc')) & (df['Plan'].str.contains('Physics'))]        else:            df = df.index[(df['Plan'].str.contains('BSc')) & (df['Plan'].str.contains('Math'))]    # add indices for the 2nd row of each student record    idx2 = []   # array of full indices    idx = idx.to_list()  # array of the first row index    for i in range(len(idx)):        idx2.append(idx[i])        idx2.append(idx[i]+1)    dfstudent = df.iloc[idx2]    # extract all the relevant rows          return dfstudent################################################################# get all student ids from a dataframedef get_sids(df):    #sidsname=list(df.columns)[0]       #sids=(df.loc[:,sidsname])    sids = df.iloc[:,0]  # assumes first column is SID        if (sids.size < 1):        print('No student IDs found...check file and column for SIDs (should be the 1st column)')        sys.exit(0)    sids = sids.to_list()  # make a list    sids = list(filter(None,sids))    # remove empty strings    return sids################################################################def get_dfstudent(df,sid):        dfstudent=df.loc[df['Emplid'] == sid]  # select row with studentID= target    index=dfstudent.index.to_list()          # get index number of this row        dfstudent1 = df.loc[df.index == index[0]]    dfstudent2 = df.loc[df.index == index[0]+1]        dfstudent = pd.concat([dfstudent1, dfstudent2])    return dfstudent################################################################# Make Info student record class filling with basic marks etc.# Ignores courses that are in ignore_coursesdef make_Info(df,anid,classyear,ignore_courses):    Info = StudentInfo(anid,classyear)            # Make Info record and add SID/classyear    Info.Plan = df["Plan"].values[0]    # add Plan    columns = df.columns.to_list() # get columns    # add in simple information from input data    if ("Name" in columns): Info.Name = df["Name"].values[0]   # add Name if available    if ("Units\nTaken" in columns): Info.UnitsTaken = df["Units\nTaken"].values[0]    if ("Units\nPassed" in columns): Info.UnitsTaken = df["Units\nPassed"].values[0]    # add all the Unit information including codes    columns = df.filter(regex='^Unit\ ',axis=1).columns.to_list()  # just unit columns    coursenames = []    marks = []    marksout = []   # string for output marks (including potentially codes etc)    credits = []    codes = []    # loop over each Unit column    for col in columns:          data = df.loc[:,col].values  # get main data        coursename = data[0][0:9] # coursename is first 10 characters        if (coursename == '' or coursename in ignore_courses):  # move on if blank            continue        # add mark        if (data[1] == ''):            mark = 0            marksout.append('')        else:            mark = int(data[1]) # mark as an integer            marksout.append(data[1])  # keep as string                     # credits        lbindex = data[0].find('(')        rbindex = data[0].find(')')        thiscredit = int(data[0][lbindex + 1:rbindex])                # Get codes for any courses        idx = df.columns.get_loc(col)  # get indices of column with potential codes        code = df.iloc[1,idx+1]                # Append the valuees to the individual lists if it is a real course        coursenames.append(coursename)          marks.append(mark)  # mark        credits.append(thiscredit)        codes.append(code)                # add the lists back to the Info object        Info.coursenames = coursenames        Info.marks       = marks        Info.marksout    = marksout        Info.credits     = credits        Info.codes       = codes            return Info################################################################# get credit weights from coursename or credweights dictionary if 0def get_credweights(Info,credweightunits):    credits = Info.credits  # get credits    nunits  = len(credits)    credweights = credits   # take usual credits as default (ok for most courses)    # loop over those that are zero    zeros = [i for i, j in enumerate(credits) if j == 0]    nzeros = len(zeros)    for i in range(nzeros):                if (credits[i] == 0):             try:                credweights[i] = credweightunits[coursename]            except:                print('*WARNING: I do not know the credit weight for ', coursename)    Info.credweights = credweights  # Add to Info                    return Info################################################################# get core/non-core courses for physics and mathsdef get_core_courses(Info,isphysicscore, ismathscoure):    coursenames     = Info.coursenames    physicscore_idx = [False]*len(coursenames)    mathscore_idx   = [False]*len(coursenames)           # Physics core courses    idx = [i for i in range(len(coursenames)) if coursenames[i] in isphysicscore]  # get indices where core courses     for i in idx: physicscore_idx[i] = True        # Maths core courses (N.B. Y1 all maths courses are core)    idx = [i for i in range(len(coursenames)) if coursenames[i] in ismathscore]  # get indices where core courses     for i in idx: mathscore_idx[i] = True    # Add any Y1 maths courses for M+P students as well since these must be passed    if (Info.classyear == 1):        math_units_idx = Info.math_units_idx        for i in math_units_idx: mathscore_idx[i] = True                  # Add back to Info    Info.physicscore_idx = physicscore_idx    Info.mathscore_idx   = mathscore_idx    Info.core_idx        = physicscore_idx + mathscore_idx  # all core course indices    return Info################################################################# determine exluded courses from year mark including which ones to be deferreddef exclude_courses(Info):    # find where codes exist    codes = Info.codes    idx = [i for i in range(len(codes)) if codes[i] != '']  # get indices where codes exist    # loop over each code and excluded if required    excludedcourses_idx = []    excludedcoursenames = []    deferredcourses_idx = []    deferredcoursenames = []    deferredcredits = 0    creditsexcluded = 0    # loop over each code    for i in idx:        # X = exclude from year mark        if (codes[i] == 'X'):            excludedcourses_idx.append(i)            excludedcoursenames.append(Info.coursenames[i])            creditsexcluded += Info.credweights[i]            Info.marksout[i] = Info.marksout[i] + '_X'  # decide later if compensated or not (if <30, should be X1 anyway)             Info.credweights[i] = 0        # XL = Absent from exam with reason: excludes from the calculation of the year mark and flags as a resit at 1st attempt (deferred)        if (codes[i] == 'XL'):            excludedcourses_idx.append(i)            excludedcoursenames.append(Info.coursenames[i])            creditsexcluded += Info.credweights[i]            Info.marksout[i] = Info.marksout[i] + '_XL'            Info.credweights[i] = 0            # Defer if Y1/Y2 and if resittable (credits>0)            if ((Info.classyear == 1 or Info.classyear == 2) and Info.credits[i] > 0):                Info.marksout[i] = Info.marksout[i] + '_D'                deferredcourses_idx.append(i)                deferredcoursenames.append(Info.coursenames[i])                deferredcredits += Info.credits[i]        # X1 = Deferall in Y1/Y2 (same as XL)         if (codes[i] == 'X1'):            excludedcourses_idx.append(i)            excludedcoursenames.append(Info.coursenames[i])            creditsexcluded += Info.credweights[i]            Info.marksout[i] = Info.marksout[i] + '_X1'            Info.credweights[i] = 0            # Defer if Y1/Y2 and if resittable (credits>0)            if ((Info.classyear == 1 or Info.classyear == 2) and Info.credits[i] > 0):                Info.marksout[i] = Info.marksout[i] + '_D'                deferredcourses_idx.append(i)                deferredcoursenames.append(Info.coursenames[i])                deferredcredits += Info.credits[i]                  # XN = Missed with no reason - do NOT exclude!        if (codes[i] == 'XN'):            Info.marksout[i] = Info.marksout[i] + '_XN'                # Add extras back to Info    Info.excludedcourses_idx = excludedcourses_idx    Info.excludedcoursenames  = excludedcoursenames    Info.creditsexcluded     = creditsexcluded    Info.deferredcoursenames = deferredcoursenames    Info.deferredcredits     = deferredcredits        return Info################################################################# Function to determine MATH units and marks/credits and also maths credits takendef get_math_units(Info):    math_units = []    coursenames = Info.coursenames    idx = [i for i in range(len(coursenames)) if 'MATH' in coursenames[i]]  # get indices if MATH unit    idx2 = [i for i in range(len(coursenames)) if 'MATH' not in coursenames[i]]  # get indices if not MATH unit    # Physics/maths credits taken    mathscreditstaken = np.sum(np.array(Info.credits)[idx])    physicscreditstaken = np.sum(np.array(Info.credits)[idx2])            # Add back to Info    Info.math_units_idx = idx    Info.physics_units_idx = idx2    Info.mathscreditstaken = mathscreditstaken    Info.physicscreditstaken = physicscreditstaken    Info.creditstaken = mathscreditstaken + physicscreditstaken        return Info################################################################# Determine the overall project mark for S1/S2 or both# taking into account special cases for non-standard projects (Phys/Phil and M+P)def get_projectmark(Info):    # If not Y3/Y4 then skip this function    if (Info.classyear == 1 or Info.classyear == 2):        return Info        # taking into account special cases for non-standard projects (Phys/Phil and M+P)    # or with only 1 project    coursenames = Info.coursenames    project1mark = -1    # -1 means no mark       project2mark = -1    # -1 means no mark        # BSc dissertation for 3rd years    if ('PHYS30880' in coursenames):        idx = coursenames.index('PHYS30880')        projectmark = Info.marks[idx]    if ('PHYS40181' in coursenames and 'PHYS40182' in coursenames):        idx = coursenames.index('PHYS40181')        project1mark = Info.marks[idx]      # S1        project1cred = Info.credits[idx]        idx = coursenames.index('PHYS40182')        project2mark = Info.marks[idx]      # S2        project2cred = Info.credits[idx]            elif ('PHYS40181' in coursenames and 'PHYS40182' not in coursenames):        idx = coursenames.index('PHYS40181')        project1mark = Info.marks[idx]      # S1        project1cred = Info.credits[idx]            elif ('PHYS40181' not in coursenames and 'PHYS40182' in coursenames):        idx = coursenames.index('PHYS40182')        project2mark = Info.marks[idx]      # S2        project2cred = Info.credits[idx]                    # for Phys/Phil who do an essay for one project - only worth 10 credits c.f. 20 credits for physics    if ('PHIL40000' in coursenames and project1mark==-1):        idx = coursenames.index('PHIL40000')        project1mark = Info.marks[idx]        project1cred = Info.credits[idx]    elif ('PHIL40000' in coursenames and project2mark==-1):        idx = coursenames.index('PHIL40000')        project2mark = Info.marks[idx]        project2cred = Info.credits[idx]            # for Maths/Phys Maths projects only 15 credits c.f. 20 credits for physics    if ('MATH40011' in coursenames and project1mark==-1):        idx = coursenames.index('MATH40011')        project1mark = Info.marks[idx]        project1cred = Info.credits[idx]    if ('MATH40022' in coursenames and project2mark==-1):        idx = coursenames.index('MATH40022')        project2mark = Info.marks[idx]        project2cred = Info.credits[idx]    # combine S1/S2 project marks    if (project1mark >=0 and project2mark >=0):        projectmark = ((project1mark*project1cred)+(project2mark*project2cred))/float(project1cred+project2cred)        projectcred = project1cred+project2cred    elif (project1mark >=0 and project2mark == -1):        projectmark = project1mark        projectcred = project1cred    elif (project2mark >=0 and project1mark == -1):        projectmark = project2mark        projectcred = project2cred        # Add to Info    Info.projectmark = round(projectmark+0.000001)    Info.projectcred = projectcred    return Info################################################################# Find which units are passed/faileddef get_passed_failed(Info,mustpass,noresitlist):    marks = Info.marks  # get numerical marks        # get passed marks/credits    passed_idx = np.array([i for i in range(len(marks)) if marks[i] >= 39.95])  # passed marks    creditspassed = np.sum(np.array(Info.credits)[passed_idx])  # Sum of passed credits    # get nominally failed marks/credits    failed_idx = np.array([i for i in range(len(marks)) if marks[i] < 39.95])  # failed marks    # loop through nominally failed courses and determine outcome at end    for i in failed_idx:        # has this course been failed when it must be passed i.e. lab,  project?        if (Info.coursenames[i] in mustpass):            Info.faillabprog = True        #if any course is < 30%, resits triggered for 1st/2nd year (also trigger resits later)        if(marks[i]<29.95 and Info.coursenames[i] not in noresitlist and Info.credits[i] > 0 and i not in Info.excludedcourses_idx):            Info.someunitunder30=True                        # Add back to Info    Info.creditspassed = creditspassed        return Info################################################################# get overall average year markdef get_year_mark(Info):    marks = np.array(Info.marks)    credweights = np.array(Info.credweights)    sumcredweights = np.sum(credweights)    Info.sumcredweights = sumcredweights    Info.yearmark = round(np.sum(marks*credweights)/sumcredweights + 0.000001,1)  # round to 1 d.p.    return Info################################################################# get overall average year mark for Physics and Maths separately including overall year mark for M+P studentsdef get_mp_year_mark(Info):        marks = np.array(Info.marks)    credweights = np.array(Info.credweights)        # Physics    idx = Info.physics_units_idx    physicscredweights = np.sum(credweights[idx])    physics_yearmark = round(np.sum(marks[idx]*credweights[idx])/physicscredweights + 0.000001,1)  # round to 1 d.p.    # Math    idx = Info.math_units_idx    mathcredweights = np.sum(credweights[idx])    math_yearmark = round(np.sum(marks[idx]*credweights[idx])/mathcredweights + 0.000001,1)  # round to 1 d.p.    # Overall year mark replaced by weighted average of M+P separately    yearmark = (physics_yearmark*physicscredweights + math_yearmark*mathcredweights)/(physicscredweights+mathcredweights)    # Add back to Info    Info.physicscredweights = physicscredweights    Info.mathcredweights    = mathcredweights    Info.yearmark           = round(yearmark+0.000001,1)        return Info################################################################# convert degree class to a string for output griddef degclass_to_string(progtaken,degclass):    # deg classification    degclass_dict = {        4:"1",        3:"2:1",        2:"2:2",        1:"3",        0:"Ord.",        -1:"Fail",        -2:"NOT SET!!!"}    # degree type    degstr = progtaken.split('(')[0] + ' '                return degstr + degclass_dict[degclass]################################################################################################################################################################################################# INPUTS AND READIING DATA################################################################# Define year (1=1st year, 2=2nd year, 31=3rd prog, 32=3rd complete ,4=4th year)classyear=1# Student type (1=physics, 2=Maths+Physics)#########studtype=2# Input directory for files (default is './' for current directory)indir = './'# Late penalty filename - put these in to store pre-penalty scores with _P codes# _P1 = premark >40, _P2 = premark =30-30, _P3 = premark < 30# If set to blank ('') then nothing is applid# File should be for both semesters, with col1=coursename, col2=ID, col3=pre-penalty mark, col4=post-penalty mark#late_penalty_filename = ''#late_penalty_filename = './data2021/Late-Penalties-both-semesters-JMcG-.xlsx'# Input and output files for each cohort# Input filename (filename) can be .csv or .xls/.xlsx - the code will automatically read it in whichever the format if(classyear==1):    filename = './data1819/1styr_28_06_19_postmcc.csv'    #filename = './data2021/1st year exam grid_10.06.21.csv'    #filename = './data2021/1st year exam grid_02.07.21_mcc anonymous.xlsx'        # output filename    if (studtype==1): outfilename = '1styear_Physics.AY2018.prelimfinal.xlsx'   # Physics filename    else: outfilename = '1styear_MathsPhysics.AY2018.prelimfinal.xlsx'   # M+P filename    elif (classyear == 2):    #filename = '/data1819/2ndyr_26_06_19.csv'    #filename = './data2021/2nd year exam grid_25.06.21.csv'    #filename = './data2021/2nd year exam grid_02.07.21_mcc anonymous.xlsx'    filename = './data2021/2nd year exam grid_16.07.21.xlsx'    # If CFfilename to be used, set deganalysis to 1 (below)    CFfilename = './data2021/2nd year carry forward.xlsx'        # output filename    if (studtype==1): outfilename = '2ndyear_Physics.AY2021.prelimfinal.xlsx'   # Physics filename    else: outfilename = '2ndyear_MathsPhysics.AY2021.prelimfinal.xlsx'   # M+P filenameelif(classyear==32):    #filename = './data1819/3rdyr_18_06_19_external.csv'    #filename = './data2021/3rd year exam grid_10.06.21.csv'    #filename = './data2021/3rd year exam grid_07.07.21_mcc anonymous.xlsx'    filename = './data2021/3rd year exam grid_10.07.21_postmcc.xlsx'        #CFfilename = './data1819/3rdyr_carryforward.csv'    CFfilename = './data2021/3rd year carry forward.xlsx'    # output filename    if (studtype==1): outfilename = 'FinalYear_BSc_Physics.AY2021.prelimfinal.xlsx'   # Physics filename    else: outfilename = 'FinalYear_BSc_MathsPhysics.AY2021.prelimfinal.xlsx'   # M+P filename    elif (classyear == 31):    #filename = '/data1819/3rdyr_18_06_19_external.csv'    #filename = './data2021/3rd year exam grid_10.06.21.csv'    #filename = './data2021/3rd year exam grid_07.07.21_mcc anonymous.xlsx'    filename = './data2021/3rd year exam grid_10.07.21_postmcc.xlsx'        #CFfilename = './data1819//3rdyr_carryforward.csv'    CFfilename = './data2021/3rd year carry forward.xlsx'    # output filename    if (studtype==1): outfilename = '3rdyear_MPhys.AY2021.prelimfinal.xlsx'   # Physics filename    else: outfilename = '3rdyear_MMath.AY2021.prelimfinal.xlsx'   # M+P filename    elif(classyear==4):    #filename = '/data1819/4thyr_18_06_19_external.csv'    #filename = './data2021/4th year exam grid_10.06.21.csv'    #filename = './data2021/4th year exam grid_07.07.21_mcc anonymous.xlsx'    filename = './data2021/4th year exam grid_10.07.21_with year abroad flags.xlsx'        #CFfilename='./data1819/4thyr_carryforward.csv'    CFfilename = './data2021/4th year carry forward.xlsx'    # output filename    if (studtype==1): outfilename = 'FinalYear_MPhys.AY2021.prelimfinal.xlsx'   # Physics filename    else: outfilename = 'FinalYear_MMath.AY2021.prelimfinal.xlsx'   # M+P filenameelse:    print('*ERROR: Classyear not defined correctly (should be 1, 2, 31, 32, or 4)')    sys.exit(0)    # final filenamefilename= indir + filename################################################################# some data definitions################################################################# Credits requiredcreditstogetMPHYS = 80  creditstogetBScgood=80creditstogetBSclower=60creditstogetMPHYSalgA = 75 # Used for algA creditstogetalgB = 70  # Used for algB# testing only for 2018/19 data! ***REMOVE/COMMENT OUT!!!creditstogetMPHYS = 80  creditstogetBScgood=80creditstogetBSclower=60creditstogetMPHYSalgA = 80 # Used for algA creditstogetalgB = 70  # Used for algB# boundaries for degree class (2 d.ps because marks are stored to 1 d.p.)boundaryfirst=69.95boundaryupper2=59.95boundarylower2=49.95boundarythird=39.95# borderlines for promotion consideration borderfirst = boundaryfirst - 3.0borderupper2 = boundaryupper2 - 3.0borderlower2 = boundarylower2 - 3.0borderthird = boundarythird - 4.0# any students to skip# For 2021 to omit exception students (see Suzanne's email 11-Jun-2021 and Y2 issues xls file and Judith email 08-Jul-2021) donotprocess={'10304702','10301241','10341954','9954785','9976148','9914290'}   # IDs should be strings! #donotprocess={}  # FOR TESTING ONLY!# define core for purpose of triggered resits i.e.  what gets resat if a student is going to have resits anyway.# This one is for studtype=1, for most Physics studentsisphysicscore={'PHYS10071','PHYS10101','PHYS10121','PHYS10191','PHYS10302','PHYS10342','PHYS10352','PHYS10372','PHYS20101','PHYS20141','PHYS20171','PHYS20252','PHYS20312','PHYS20352'}# M+P students have a different list in *addition* to the iscore list above# (only need 2nd year courses because all MATHs courses in Y1 must be passed - these courses add later when they are known)ismathscore={'MATH20401', 'MATH29142'}# Set the core list depending on whether M+P student or notif (studtype == 1): iscore = isphysicscoreelse: iscore = isphysicscore.union(ismathscore)#define what must be passed e.g. lab, BSc dissertation.mustpass={'PHYS10180','PHYS10280',          'PHYS20180','PHYS20280',          'PHYS30180','PHYS30280','PHYS30880',          'PHYS40181','PHYS40182'}# these are where units may have different credits for the marks vs progression (*make sure these are integers, not floats!)credweightunits={'PHYS20040':10,  # main general paper (doesn't count towards progression/resits, but does count towards marks)'PHYS20240':6,            # shorter version worth only 6 (M+P,Phys/Phil, 2nd/3rd year direct entry) 'PHYS20811':5,            # Professional development CD: changed from 9 to 5 in AY2021'PHYS20821':5,            # for the few students resitting the year this course still here'PHYS30010':10,           # General paper (doesn't count towards progression/resits, but does count towards marks)'PHYS30210':6,           # General paper (short version for M+P, Phys/Phil, 2nd/3rd year direct entry)'PHYS30811':3}             # Added back for those few students re-sitting#'PHYS20030':0,            # Peer-Assisted Study Sessions (PASS) - no marks, no credits, but here just in case #'ULGE21030':0,            # #'ULFR21030':0,#'ULJA21020':0,#'ULRU11010':0,#'MATH35012':0,#'COMP39112':0,#'MATH49102':0}noresitlist={}  # any units that can't be resit (other than 0 credit units (which are not resitable) like lab etc.)# courses to completley ignore because they don't have a mark e.g. tutorials, PASS etc. ignore_courses={'MPHYS',         # not a course                'MPHYSON',       # not a course                'PHYS10000',    # tutorials/similar                'PHYS20000',    # tutorials/similar                'PHYS30000',    # tutorials/similar                'PHYS40000',    # tutorials/similar                'PHYS10010',                'PHYS10020',                'PHYS10030',                'PHYS10022',                'PHYS11000',                'PHYS21000',                'PHYS31000',                'PHYS41000',                'PHYS20030',                'PHYS19990',    # PASS Peer=Assissted Self-Study                'PHYS29990',    # PASS Peer=Assissted Self-Study                'PHYS39990',    # PASS Peer=Assissted Self-Study                'PHYS49990',    # PASS Peer=Assissted Self-Study                'MATH S100',    # Maths Study module (0 credited) [last 0 omitted on prurpose because of extra gap]                'MATH S200',    # Maths Study module (0 credited) [last 0 omitted on prurpose because of extra gap]                'MATH S300',    # Maths Study module (0 credited) [last 0 omitted on prurpose because of extra gap]                'MATH S400',    # Maths Study module (0 credited) [last 0 omitted on prurpose because of extra gap]                'MATH    S'     # sometimes this format}                # BELOW IS JUST FOR TESTING WITH 2018/19 DATA!! ***REMOVE/COMMENT OUT!!!#credweightunits={'PHYS20040':10,#'PHYS20240':6,  #6  #'PHYS20811':9,  #9#'PHYS20821':5,#'PHYS30010':10,#'PHYS30210':6,#'PHYS30811':3,#'PHYS20030':0,#'ULGE21030':0,#'ULFR21030':0,#'ULJA21020':0,#'ULRU11010':0,#'MATH35012':0,#'COMP39112':0,#'MATH49102':0#}    ############################################################################################################################################################################################# NOW THE RUNNING PART OF THE CODE############################################################################################################################################################################################# get input datadfallstudents = read_data(filename)     # read in file to a Pandas dataframe and remove NaNsdfallstudents = extract_students_by_type(dfallstudents,classyear, studtype) # extract relevant students on programmesids          = get_sids(dfallstudents)          # get student ids for all relevant studentscolumn_names  = dfallstudents.columns.to_list()  # get column namesnstudents     = len(sids)             # Number of students to deal withdidnotprocess = ['']  # array for storing which students were actually ignored# loop over SIDscounter = 0           # counter for student numberfor anid in sids:    # info    counter += 1    print('Processing student ID {0:s} ({1:d}/{2:d})'.format(anid,counter,nstudents))    dfstudent = get_dfstudent(dfallstudents,anid)                   # get df for this student including unnamed columns    Info      = make_Info(dfstudent,anid,classyear, ignore_courses) # Make basic Info record class using available data (courses, marks, credits etc)    Info      = get_credweights(Info,credweightunits)               # Get credit weights using credweightunits dictionary    Info      = exclude_courses(Info)                               # Determine excluced courses    Info      = get_math_units(Info)                                # Determine which units are maths, and maths marks/credits, also maths credits taken    Info      = get_core_courses(Info,isphysicscore, ismathscore)   # Determine which courses are "core" including MATHs units for M+P students    Info      = get_projectmark(Info)                               # Determine the project mark    Info      = get_passed_failed(Info,mustpass,noresitlist)        # Determine which units are passed/failed        Info      = get_year_mark(Info)                                 # Determine average mark for the year    Info      = get_mp_year_mark(Info)                              # Determine maths and physics marks separately to get year mark (for M+P students)    # testing    #print(Info.marksout)    #print(Info.codes)    #print(Info.credits)    #print(Info.credweights)    #print(Info.yearmark)    #if (anid == '10402822'):    #    sys.exit(0)            #sys.exit(0)        