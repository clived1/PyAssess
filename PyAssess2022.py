# Physics and Astronomy Exam assessment code# Takes in exam grids (csv/xls/xlsx files) and produces output exam grids, with averages, degree classes etc.# This version is for AY2021/2022 and is a complete re-write of the previous version (PyAssess2021.py)# that should, in principle, work for any years.## This script requires numpy and Pandas with xlswriter (default writer for pandas, as long as v>0.16)## Checked on:# 2018/19 Y1 M+P (perfect)#         Y1 Physics (perfect)#         Y2 M+P (perfect)   #         Y2 Physics (virtually perfect - just one score 0.1 off!)#         Y31 MPhys Physics (progressing) - cum averages slightly out#         Y3 MMath M+P (progressing) - cum averages slightly out on occasion#         Y3 BSc Physics - overall marks slightly out on occasion (probably due to slightly different weights)#         Y3 BSc M+P - marks perfect!#         Y4 MPhys - marks slightly out on occasion#         Y4 MMath - perfect!## 2020/2021#         Y1 Physics - looks ok except for late-penalties _P marks#         Y1 M+P (perfect except for Jodie Farrar average is 0.2 off 62.1 vs 62.3??? - M/P credit split (60:60 vs 60:50)#         Y2 Physics - perfect averages, perfect except for one R/BSc which should be R/X and late penalties still to be applied#         Y2 M+P   - perfect except for Yang Dan averges slightly out - M/P split???#         Y31 Physics - correct except for small differences in overall mark (occassionally 0.1)#         Y31 M+P - perfect (couple of overall averages 0.1 out, presumably because of not-rounding before averaging)#         Y32 BSc M+P - perfect#         Y32 BSc - correct#         Y4 MMath - perfect#         Y4 MPhys - good (occassional 0.1 off in overall mark)### Known issues to keep in mind:#### Immediate to-do list:## 1. Missing marks including letter codes - ignore in the final average # 2. Check level 5 courses e.g ULF5xxxx:# Judith email 19/06/22: LEAP courses with codes like ULFR5xxx will NOT count as “final year course units” for the purposes of counting credits “at the level of the award” for the BSc.  To get a first or second class degree they need at least 80 credits with 3 or 4 after the subject indicators (PHYS30101, PHYS40642).  Similarly for an MPhys (where this year we are only looking at the current year, but next year we will need to look across years 3&4 together).# 3. 1. Does not not fully handle Physics with Study in EurPope 2-3 progression or degree classification (needs S3 mark which is not available/easy to compute).#    N.B. The code treats them as normal MPhys students - the Phys/Euro coordinator will check these few by hand.## 4. Add column for passed level 3 and 4 credits. If possible, add flags why students are failing e.g. lab/project fail; insufficient level 3 credits.# 5. Fix issue with BSc fails - credits3passed is <60!!! ????# 6. ### FUTURE To-do list:## 1. From AY=2023, M+P Yr 1 students, *only* two 20 credits units MATH11121 and MATH11022 will be non-compensatable (see emails 13 May 2022)## 2. From AY=2023 Judith email 01/03/22: Looking forward, an issue for next year’s third year is that students are to be restricted to 40 failed credits across both years 3 and 4.  So the carry-forward file will have to have a column for credits failed in third year, and we may have to restrict progression to those with no more than 20 such credits. (In case you were wondering, there will be no need to worry about passed credits at the level of the award for fourth year students, because they need to take at least 120 level 4 units across years 3&4 and will not be allowed fail more than 40 across the two years anyway.  So it isn’t a separate constraint.)### MODIFICATION HISTORY## 23-Feb-2022  C. Dickinson    Re-write of PyAssess2021.py (start from scratch!) # 11-Apr-2022                  Works for virtually all 2018/19 and 2020/21 cases (where it is supposed to anyway!)# 11-Apr-2022                  Implemented credits3passed for Y3 BSc criteria# 22-Jun-2022                  Added catch for non-numeric marks to be 0 but output the non-numeric mark#                              Fix so that it still continues if no student matched in CF file# 23-Jun-2022                  Added encode_sids option to encode SIDs, not output names, and output sid lookup table# 26-Jun-2022                  Moved main inputs to near the top#                              Automatically hides original SID and Name if encode_sids == True#                              Updated PHYS30811 to 0 credweights#                              Put full coursenames+credits back in output (but column width still the same)#                              Implemented CF_flagsfile to apply '*' to students flagged in this file#                              Fixed encoded SIDs and added "E" to the beginning################################################################## importsimport pandas as pdimport numpy as npimport sys#from typing import Any#import matplotlib.pyplot as plt#import itertools#from decimal import Decimalpd.options.mode.chained_assignment = None  # default='warn'################################################################# MAIN INPUTS TO BE CHANGED################################################################# Set academic year e.g. 2021 is for 2020/21 (for filename and rules!)#AY = 2019  # for 2018/19#AY = 2021  # for 2020/2021AY = 2022  # for 2021/2022# Define year (1=1st year, 2=2nd year, 31=3rd prog, 32=3rd complete ,4=4th year)classyear=32# Student type (1=physics, 2=Math+Physics)studtype=1# Encode student IDs - if set to True (or 1) then encode the IDs, do not output names, and produce a look up table separatelyencode_sids = True# Input directory for files (default is './' for current directory)indir = './'# CF flag file - if set to '' (blank) then ignore, otherwise use this to flag mitigating yearly averagesCF_flagfile = './data2022/Flag for CF with IDs.xlsx'#CF_flagfile = ''# Input and output files for each cohort# Input filename (filename) can be .csv or .xls/.xlsx - the code will automatically read it in whichever the format if(classyear==1):    #filename = './data1819/1styr_28_06_19_postmcc.csv'    filename = 'data2021/Input grids/1st year exam grid_21.07.21.xlsx'    #filename = 'PyAssessAY2021/Y1_test_input.xlsx'        CFfilename = '' # (no CF file)        # output filename    if (studtype==1): outfilename = '1styear_Physics.' + 'AY' + str(AY) + '.prelimfinal.xlsx'   # Physics filename    else: outfilename = '1styear_MathsPhysics.' + 'AY' + str(AY) + '.prelimfinal.xlsx'   # M+P filename    elif (classyear == 2):    #filename = '/data1819/2ndyr_26_06_19.csv'    #filename = 'data1819/2ndyr_28_06_19_postmcc_edited.csv'    filename = './data2021/Input grids/2nd year exam grid_19.07.21.xlsx'        # If CFfilename to be used (otherwise leave as blank '' to ignore or set doCF=False below)    #CFfilename = ''    CFfilename = './data2021/2nd year carry forward.xlsx'        # output filename    if (studtype==1): outfilename = '2ndyear_Physics.' + 'AY' + str(AY) + '.prelimfinal.xlsx'   # Physics filename    else: outfilename = '2ndyear_MathsPhysics.' + 'AY' + str(AY) + '.prelimfinal.xlsx'   # M+P filenameelif(classyear==32):    #filename = './data1819/3rdyr_18_06_19_external.csv'    #filename  = './data2021/Input grids/3rd year exam grid_13.07.21_v2.xlsx'    filename  = './data2022/3rd year exam grid_25.06.22_v1.xlsx'        #CFfilename = './data1819/3rdyr_carryforward.csv'    #CFfilename = './data2021/3rd year carry forward.xlsx'    CFfilename = './data2022/3rd year carry forward.xlsx'        # output filename    if (studtype==1): outfilename = 'FinalYear_BSc_Physics.' + 'AY' + str(AY) + '.prelimfinal.xlsx'   # Physics filename    else: outfilename = 'FinalYear_BSc_MathsPhysics.' + 'AY' + str(AY) + '.prelimfinal.xlsx'   # M+P filename    elif (classyear == 31):    #filename = '/data1819/3rdyr_18_06_19_external.csv'    #filename = './data2021/Input grids/3rd year exam grid_13.07.21_v2.xlsx'    filename  = './data2022/3rd year exam grid_25.06.22_v1.xlsx'        #CFfilename = './data1819/3rdyr_carryforward.csv'    #CFfilename = './data2021/3rd year carry forward.xlsx'    CFfilename = './data2022/3rd year carry forward.xlsx'        # output filename    if (studtype==1): outfilename = '3rdyear_MPhys.' + 'AY' + str(AY) + '.prelimfinal.xlsx'   # Physics filename    else: outfilename = '3rdyear_MMath.' + 'AY' + str(AY) + '.prelimfinal.xlsx'   # M+P filename    elif(classyear==4):    #filename = '/data1819/4thyr_18_06_19_external.csv'    #filename = './data2021/Input grids/4th year exam grid_22.07.21_Abroad.xlsx'    filename = './data2022/4th year exam grid_25.06.22_v1.xlsx'        #CFfilename='./data1819/4thyr_carryforward.csv'    #CFfilename = './data2021/4th year carry forward.xlsx'    CFfilename = './data2022/4th year carry forward.xlsx'        # output filename    if (studtype==1): outfilename = 'FinalYear_MPhys.' + 'AY' + str(AY) + '.prelimfinal.xlsx'   # Physics filename    else: outfilename = 'FinalYear_MMath.' + 'AY' + str(AY) + '.prelimfinal.xlsx'   # M+P filenameelse:    print('*ERROR: Classyear not defined correctly (should be 1, 2, 31, 32, or 4)')    sys.exit(0)################################################################# CLASS DEFINITIONS################################################################# class to include all student info, but start with most important info# and include defaults for important parametersclass StudentInfo:    def __init__(self,emplid,classyear):        # Most important inputs        self.emplid = emplid        self.classyear = classyear        # Default parameters (in case not set and is needed by a function later)        self.status          = 'ACTV'  # default status        self.mitcirc         = ''        self.anonymous       = False        self.someunitunder30 = False        self.resitstriggered = False        self.compensation    = False        self.faillabprog     = False        self.fail            = False        self.referredcoursenames = ''        self.deferredcoursenames = ''        self.referred_idx    = []        self.deferred_idx    = []        self.compensated_idx = []        ################################################################# FUNCTIONS################################################################# used for skipping first few rows of CS grid (note system dependent)def rowskiplogic(index):    if index==0 or index==1 or index==2 or index==3:       return True    return False################################################################# read in student data (usually from a csv file but can be excel)def read_data(filename):    #print('Reading in data from {}'.format(filename))    try:        if (filename.split('.')[-1] == 'csv'): df = pd.read_csv(filename, skiprows=lambda x: +rowskiplogic(x), dtype='str',encoding = "ISO-8859-1")        else: df=pd.read_excel(filename,skiprows=lambda x: +rowskiplogic(x),dtype='str')    except:        print('\nERROR reading the main input file: {0:s}\nPlease check filename and/or directory and make sure it is xls/xlsx/csv format...\n'.format(filename))        sys.exit(0)    # clean up dataframe of NaNs but leave Unnamed columns for now       df = df.replace(np.nan, '', regex=True)  # Remove NaNs    return df################################################################# Remove Unnamed ('^Unnamed') columns from the dataframedef remove_unnamed_columns(df):        return df.loc[:, ~df.columns.str.contains('^Unnamed')]   # remove Unnamed columns################################################################# read in student data (usually from a csv file but can be excel)def read_CFflags(CF_flagfile,doCF):    # If no CF or flags then skip    if (doCF == False or CF_flagfile == ''):        return None        try:        if (filename.split('.')[-1] == 'csv'): df = pd.read_csv(CF_flagfile, dtype='str',encoding = "ISO-8859-1")        else: df=pd.read_excel(CF_flagfile,dtype='str')    except:        print('\nERROR reading the CF flasg file: {0:s}\nPlease check filename and/or directory and make sure it is xls/xlsx/csv format...\n'.format(CF_flagfile))        sys.exit(0)    # clean up dataframe of NaNs but leave Unnamed columns for now       df = df.replace(np.nan, '', regex=True)  # Remove NaNs        return df################################################################# extract relevant students from df to another df by typedef extract_students_by_type(df,classyear,studtype):    # get indices of relevant students    if (classyear == 1 or classyear == 2 or classyear == 4):        if (studtype == 1):            idx = df.index[(df['Plan'].str.contains('MPhys')) | (df['Plan'].str.contains('BSc')) & (~df['Plan'].str.contains('Math'))]        else:            idx = df.index[(df['Plan'].str.contains('Math'))]                if(classyear==31):        if (studtype == 1):            idx = df.index[(df['Plan'].str.contains('MPhys'))]        else:            idx = df.index[(df['Plan'].str.contains('MMath'))]    #  Select BScs without math    if(classyear==32):        if(studtype==1):            idx = df.index[(df['Plan'].str.contains('BSc')) & (df['Plan'].str.contains('Physics'))]        else:            idx = df.index[(df['Plan'].str.contains('BSc')) & (df['Plan'].str.contains('Math'))]    # add indices for the 2nd row of each student record    idx2 = []   # array of full indices    idx = idx.to_list()  # array of the first row index    for i in range(len(idx)):        idx2.append(idx[i])        idx2.append(idx[i]+1)    dfstudent = df.iloc[idx2]    # extract all the relevant rows          return dfstudent################################################################# get all student ids from a dataframedef get_sids(df):    #sidsname=list(df.columns)[0]       #sids=(df.loc[:,sidsname])    sids = df.iloc[:,0]  # assumes first column is SID        if (sids.size < 1):        print('No student IDs found...check file and column for SIDs (should be the 1st column)')        sys.exit(0)    sids = sids.to_list()  # make a list    sids = list(filter(None,sids))    # remove empty strings    return sids################################################################def get_dfstudent(df,sid):        dfstudent=df.loc[df['Emplid'] == sid]  # select row with studentID= target    index=dfstudent.index.to_list()          # get index number of this row        dfstudent1 = df.loc[df.index == index[0]]    dfstudent2 = df.loc[df.index == index[0]+1]        dfstudent = pd.concat([dfstudent1, dfstudent2])    return dfstudent################################################################# Make Info student record class filling with basic marks etc.# Ignores courses that are in ignore_coursesdef make_Info(df,anid,classyear,ignore_courses):    Info = StudentInfo(anid,classyear)            # Make Info record and add SID/classyear    Info.Plan = df["Plan"].values[0]    # add Plan        # Determine if progressing or finalyear    if (classyear == 32 or classyear == 4):        Info.finalyear = True    else:        Info.finalyear = False        # Determine if M+P student    if ('Math' in Info.Plan):        Info.mathstudent = True    else:        Info.mathstudent = False            # Determine if MPhys student    if ('MP' in Info.Plan or 'Mp' in Info.Plan or 'MM' in Info.Plan):        Info.mphysstudent = True    else:        Info.mphysstudent = False            columns = df.columns.to_list() # get columns    # add in simple information from input data    if ("Name" in columns):        Info.Name = df["Name"].values[0] # add Name if available    else: Info.anonymous = True  # anonymous file    # Credits taken/passed    if ("Units\nTaken" in columns): Info.UnitsTaken = df["Units\nTaken"].values[0]    if ("Units\nPassed" in columns): Info.UnitsTaken = df["Units\nPassed"].values[0]    # Mit Circ/Sp if exists    mitcirc_name = [s for s in columns if ('Mit' in s or 'Sp' in s)] # get name of column if it exists    if (mitcirc_name): Info.mitcirc = df[mitcirc_name[0]].values[0]        # add all the Unit information including codes    columns = df.filter(regex='^Unit\ ',axis=1).columns.to_list()  # just unit columns    coursenames = []    coursenamesout = []    marks = []    marksout = []   # string for output marks (including potentially codes etc)    credits = []    codes = []    # loop over each Unit column    for col in columns:          data = df.loc[:,col].values  # get main data        coursename = data[0][0:9] # coursename is first 10 characters        if (coursename == '' or coursename in ignore_courses):  # move on if blank            continue        # add mark        if (str(data[1]).isnumeric() == False):  # for non-numeric marks (also catches empty string '')            mark = 0            marksout.append(str(data[1]))            print('*WARNING: No mark for {0:s} ({1:s})'.format(coursename,data[1]))        else:            mark = round(float(data[1])+0.000001) # mark as a (rounded) integer            marksout.append(data[1])  # keep as string                     # credits        lbindex = data[0].find('(')        rbindex = data[0].find(')')        thiscredit = int(data[0][lbindex + 1:rbindex])                # Get codes for any courses        idx = df.columns.get_loc(col)  # get indices of column with potential codes        code = df.iloc[1,idx+1]                # Append the valuees to the individual lists if it is a real course        coursenamesout.append(data[0])  # Keep original coursename + credits for output        coursenames.append(coursename)          marks.append(mark)  # mark        credits.append(thiscredit)        codes.append(code)    # add the lists back to the Info object    Info.coursenamesout = coursenamesout    Info.coursenames = coursenames    Info.marks       = marks    Info.marksout    = marksout    Info.credits     = credits    Info.codes       = codes        return Info################################################################# Get CarryForward data from xls file (if doCF == True)def get_CF_data(doCF, CFfilename):    # do nothing if doCF == False or no CFfilename    if (doCF == False or CFfilename == ''):        return None    # Read in data    try:        if (CFfilename.split('.')[-1] == 'csv'):            df_CF = pd.read_csv(CFfilename, skiprows=lambda x: +rowskiplogic(x), dtype='str', engine='python')        else:            df_CF = pd.read_excel(CFfilename, skiprows=lambda x: +rowskiplogic(x), dtype='str')    except:        print('\nERROR reading Carry Forward file: {0:s}\nPlease check filename and/or directory...\n'.format(CFfilename))        sys.exit(0)    df_CF = df_CF.replace(np.nan, '', regex=True)  # Remove NaNs    return df_CF################################################################# add CF data to Info from df_CF already read-indef add_CF_data(Info,df_CF, anid):    if (doCF == False):  # do nothing if no CF file        Info.CF = False        return Info        selected = df_CF.loc[df_CF['Emplid'] == anid]   # get student data from 1st column        # Check if empty - if so, stop and give warning - usually, CF file not correct or not used (doCF should be 0)    # Put in -1 marks so that code will continue    if (selected.empty):        print('*WARNING: Cannot find student {0:s} in CF file (but file read in ok)... '.format(anid))        #print('***If no relevant CF file, set doCF = False or set CFfilename = '' to ignore carry forwards')        Info.CF = False        Info.phys1 = -1        Info.phys2 = -1        Info.phys3 = -1        Info.math1 = -1        Info.math2 = -1        Info.math3 = -1        Info.year3mark = -1        return Info    else:        Info.CF = True        # get index number of this row and extract the numbers    selectedindex = selected.index    data=df_CF.iloc[selectedindex].values    data=data.flatten()    ndata = np.size(data)        if (ndata < 9):        print('*WARNING: < 9 columns in CF file')        print('***If no relevant CF file, set doCF = False or set CFfilename = '' to ignore carry forwards')            outnames = ['phys1','phys2','phys3','math1','math2','math3']            # loop over each column to get Phys/Math marks from columns 4-9    cols = [3,4,5,6,7,8]  # 6 columns expected after the first 3    for i in cols:        outname = outnames[i-3]        #print('***', data[i])        if (data[i] == 'na' or not data[i]):  # if no data            setattr(Info,outname,-1)         elif (i > 2): # from columns 4-9 get number            setattr(Info,outname, float(data[i]))    # get Year 3 mark for 4th year M+P students from column 10 (if it exists)    if (Info.classyear == 4 and Info.mathstudent == True):        if (ndata < 10):            print('Using straight Phys/Math average for year3mark does not seem to appear in the CF file (no column 10?)!')            Info.year3mark = (Info.phys3+Info.math3)/2 # incorrect - not a straight average (in case no year3 mark available)        elif (data[9] == 'n/a' or not data[9]):            print('Using straight Phys/Math average because year3mark is not available in CF file!')            Info.year3mark = (Info.phys3+Info.math3)/2 # incorrect - not a straight average (in case no year3 mark available)        else:            Info.year3mark=float(data[9])            return Info################################################################# get credit weights from coursename or credweights dictionary if 0# will run through all courses# unless idx set to list of indices to re-do (e.g. if compensated later need to put credweights back for these only)def get_credweights(Info,credweightunits,useidx=False):    credits = Info.credits.copy()  # get credits        # loop over those that are zero using supplied useidx or all zeroes if not    if (useidx):        idx = list([useidx])        credweights = Info.credweights.copy()   # take existing credweights    else:        credweights = credits.copy()  # does not exist yet so take credits as default        idx = [i for i, j in enumerate(credits) if j == 0]    # loop over relevant idx    for i in idx:        coursename = Info.coursenames[i]        if (useidx):            credweights[i] = credits[i]   # if possible compensation put it back to original credits                        if (credits[i] == 0):            try:                credweights[i] = credweightunits[coursename]            except:                print('*WARNING: Unknown credit weight for {0:s} (so will remain as zero-credit weighting)'.format(coursename))    Info.credweights = credweights  # Add back to Info                    return Info################################################################# get core/non-core courses for physics and mathdef get_core_courses(Info,isphysicscore, ismathcoure):    coursenames     = Info.coursenames.copy()        # Physics core courses    physicscore_idx = [i for i in range(len(coursenames)) if coursenames[i] in isphysicscore]  # get indices where core courses         # Math core courses (N.B. Y1 all math courses are core)    mathcore_idx = [i for i in range(len(coursenames)) if coursenames[i] in ismathcore]  # get indices where core courses         # Add any Y1 math courses for M+P students as well since these must be passed    if (Info.classyear == 1 and Info.mathstudent == True):        math_units_idx = Info.math_units_idx.copy()        mathcore_idx.extend(math_units_idx)            # Add back to Info    Info.physicscore_idx = physicscore_idx    Info.mathcore_idx   = mathcore_idx    Info.core_idx        = physicscore_idx + mathcore_idx  # all core course indices    return Info################################################################# determine exluded courses from year mark including which ones to be deferreddef exclude_courses(Info):        # find where codes exist    codes = Info.codes    idx = [i for i in range(len(codes)) if codes[i] != '']  # get indices where codes exist    # loop over each code and excluded if required    excluded_idx = []    excludedcoursenames = []    deferred_idx = []    deferredcoursenames = ''    deferredcredits = 0    creditsexcluded = 0    # loop over each code    for i in idx:        # X = exclude from year mark        if (codes[i] == 'X'):            excluded_idx.append(i)            excludedcoursenames.append(Info.coursenames[i])            creditsexcluded += Info.credweights[i]            Info.marksout[i] = Info.marksout[i] + '_X'  # decide later if compensated or not (if <30, should be X1 anyway)             Info.credweights[i] = 0        # XL = Absent from exam with reason: excludes from the calculation of the year mark and flags as a resit at 1st attempt (deferred)        if (codes[i] == 'XL'):            excluded_idx.append(i)            excludedcoursenames.append(Info.coursenames[i])            creditsexcluded += Info.credweights[i]            Info.marksout[i] = Info.marksout[i] + '_XL'            Info.credweights[i] = 0            # Defer if Y1/Y2 and if resittable (credits>0)            if ((Info.classyear == 1 or Info.classyear == 2) and Info.credits[i] > 0):                Info.marksout[i] = Info.marksout[i] + '_D'                deferred_idx.append(i)                deferredcoursenames += Info.coursenames[i] + '[1] / '                deferredcredits += Info.credits[i]        # X1 = Deferall in Y1/Y2 (same as XL)         if (codes[i] == 'X1'):            excluded_idx.append(i)            excludedcoursenames.append(Info.coursenames[i])            creditsexcluded += Info.credweights[i]            Info.marksout[i] = Info.marksout[i] + '_X1'            Info.credweights[i] = 0            # Defer if Y1/Y2 and if resittable (credits>0)            if ((Info.classyear == 1 or Info.classyear == 2) and Info.credits[i] > 0):                Info.marksout[i] = Info.marksout[i] + '_D'                deferred_idx.append(i)                deferredcoursenames += Info.coursenames[i] + '[1] / '                deferredcredits += Info.credits[i]                  # XN = Missed with no reason - do NOT exclude!        if (codes[i] == 'XN'):            Info.marksout[i] = Info.marksout[i] + '_XN'                # Add extras back to Info    Info.excluded_idx        = excluded_idx    Info.excludedcoursenames = excludedcoursenames    Info.creditsexcluded     = creditsexcluded    Info.deferred_idx        = deferred_idx    Info.deferredcoursenames = deferredcoursenames    Info.deferredcredits     = deferredcredits        return Info################################################################# Function to determine MATH units and marks/credits and also math credits takendef get_math_units(Info):    math_units = []    coursenames = Info.coursenames    idx = [i for i in range(len(coursenames)) if 'MATH' in coursenames[i]]  # get indices if MATH unit    idx2 = [i for i in range(len(coursenames)) if 'MATH' not in coursenames[i]]  # get indices if not MATH unit    # Physics/math credits taken    mathcreditstaken = np.sum(np.array(Info.credits)[idx])    physicscreditstaken = np.sum(np.array(Info.credits)[idx2])    # Add back to Info    Info.math_units_idx = idx    Info.physics_units_idx = idx2    Info.mathcreditstaken = mathcreditstaken    Info.physicscreditstaken = physicscreditstaken    Info.creditstaken = mathcreditstaken + physicscreditstaken        return Info################################################################# Determine the overall project mark for S1/S2 or both# taking into account special cases for non-standard projects (Phys/Phil and M+P)def get_projectmark(Info):    # If not Y3/Y4 then skip this function    if (Info.classyear == 1 or Info.classyear == 2):        return Info        # taking into account special cases for non-standard projects (Phys/Phil and M+P)    # or with only 1 project    coursenames = Info.coursenames    project1mark = -1    # -1 means no mark       project2mark = -1    # -1 means no mark        # BSc dissertation for 3rd years    if ('PHYS30880' in coursenames):        idx = coursenames.index('PHYS30880')        project1mark = Info.marks[idx]        project1cred = Info.credits[idx]            if ('PHYS40181' in coursenames and 'PHYS40182' in coursenames):        idx = coursenames.index('PHYS40181')        project1mark = Info.marks[idx]      # S1        project1cred = Info.credits[idx]        idx = coursenames.index('PHYS40182')        project2mark = Info.marks[idx]      # S2        project2cred = Info.credits[idx]            elif ('PHYS40181' in coursenames and 'PHYS40182' not in coursenames):        idx = coursenames.index('PHYS40181')        project1mark = Info.marks[idx]      # S1        project1cred = Info.credits[idx]    elif ('PHYS40181' not in coursenames and 'PHYS40182' in coursenames):        idx = coursenames.index('PHYS40182')        project2mark = Info.marks[idx]      # S2        project2cred = Info.credits[idx]                    # for Phys/Phil who do an essay for one project - only worth 10 credits c.f. 20 credits for physics    if ('PHIL40000' in coursenames and project1mark==-1):        idx = coursenames.index('PHIL40000')        project1mark = Info.marks[idx]        project1cred = Info.credits[idx]    elif ('PHIL40000' in coursenames and project2mark==-1):        idx = coursenames.index('PHIL40000')        project2mark = Info.marks[idx]        project2cred = Info.credits[idx]            # for Math/Phys Math projects only 15 credits c.f. 20 credits for physics    if ('MATH40011' in coursenames and project1mark==-1):        idx = coursenames.index('MATH40011')        project1mark = Info.marks[idx]        project1cred = Info.credits[idx]    if ('MATH40022' in coursenames and project2mark==-1):        idx = coursenames.index('MATH40022')        project2mark = Info.marks[idx]        project2cred = Info.credits[idx]            # combine S1/S2 project marks    if (project1mark >=0 and project2mark >=0):        projectmark = ((project1mark*project1cred)+(project2mark*project2cred))/float(project1cred+project2cred)        projectcred = project1cred+project2cred    elif (project1mark >=0 and project2mark == -1):        projectmark = project1mark        projectcred = project1cred    elif (project2mark >=0 and project1mark == -1):        projectmark = project2mark        projectcred = project2cred    elif (project1mark == -1 and project2mark == -1):        projectmark = 0        projectcred = 0            # Add to Info    Info.projectmark = round(projectmark+0.000001)    Info.projectcred = projectcred    return Info################################################################# Find which units are passed/faileddef get_passed_failed(Info,mustpass,noresitlist):    marks = Info.marks.copy()  # get numerical marks        # get passed marks/credits    passed_idx = np.array([i for i in range(len(marks)) if marks[i] >= 39.95])  # passed marks    if (len(passed_idx) > 0):        creditspassed = np.sum(np.array(Info.credits)[passed_idx])  # Sum of passed credits    else:        creditspassed = 0    # also get Y3 unit credits passed (needed for BSc criteria) for Y3 students    if (Info.classyear == 31 or Info.classyear == 32):        passed3_idx = np.array([i for i in range(len(marks)) if (marks[i] >= 39.95 and Info.coursenames[i][4] == '3')])        if (len(passed3_idx) > 0):            credits3passed = np.sum(np.array(Info.credits)[passed3_idx]) # Sum of passed Y3 courses        else:            credits3passed = 0        Info.passed3_idx = passed3_idx        Info.credits3passed = credits3passed            # get nominally failed marks/credits    failed_idx = np.array([i for i in range(len(marks)) if marks[i] < 39.95])  # failed marks    if (len(failed_idx) > 0):        creditsfailed = np.sum(np.array(Info.credits)[failed_idx])  # Sum of "failed" credits    else:        creditsfailed = 0            # Store locations of units in 30-39 range for possible compensation    units30_39_idx = np.array([i for i in range(len(marks)) if (marks[i] >= 29.95 and marks[i] < 39.95)])        # loop through nominally failed courses and determine outcome at end    for i in failed_idx:        # has this course been failed when it must be passed i.e. lab,  project?        if (Info.coursenames[i] in mustpass):            Info.faillabprog = True        #if any course is < 30%, resits triggered for 1st/2nd year (also trigger resits later)        if(marks[i]<29.95 and Info.coursenames[i] not in noresitlist and Info.credits[i] > 0 and i not in Info.excluded_idx):            Info.someunitunder30=True                    # Add back to Info    Info.passed_idx = passed_idx    Info.creditspassed = creditspassed    Info.failed_idx = failed_idx    Info.creditsfailed = creditsfailed    Info.units30_39_idx = units30_39_idx        return Info################################################################# Determine which units are to be referred (resit) or can be compensateddef get_referred_units(Info):        # If not Y1/Y2 then skip this function (no resits in Y3/Y4)    if (Info.classyear != 1 and Info.classyear != 2):        return Info    # if not more than 40 credits < 40% and none below 30%, they can all be compensated (except Y1 math)    if (Info.someunitunder30==0 and Info.faillabprog==0 and (Info.creditsfailed-Info.deferredcredits <= 40)):        Info.compensation = True        for idx in Info.units30_39_idx:            if (Info.classyear == 1 and Info.mathstudent == True and idx in Info.math_units_idx and idx not in Info.deferred_idx):                Info.referred_idx.append(idx)   # Any Y1 math units are referred for M+P students                Info.marksout[idx] = Info.marksout[idx] + '_R'                Info.referredcoursenames += Info.coursenames[idx] + ' / '            elif (idx not in Info.deferred_idx and Info.credits[idx] !=0):                Info.marksout[idx] = Info.marksout[idx] + '_C'   # add code to show it is compensated                Info.compensated_idx.append(idx)                if (Info.codes[idx].find('XN') > 0): # only if not excluded                    Info = get_credweights(Info,credweightunits,useidx=idx)     # put credit weight back in case it has been zeroed                # if any mark <30% must be resat and triggers resits of any core course 30-39% (if <40 credits 30-39%)    if (Info.someunitunder30==1 and Info.faillabprog==0 and (Info.creditsfailed-Info.deferredcredits <= 40)):        Info.resitstriggered = True        for idx in Info.failed_idx: # loop through all failed courses            if (Info.marks[idx] < 29.95 and idx not in Info.excluded_idx and Info.credits[idx] != 0):  # if <30% must be resat                Info.referred_idx.append(idx)                  Info.marksout[idx] = Info.marksout[idx] + '_R'                Info.referredcoursenames += Info.coursenames[idx] + ' / '            elif (idx in Info.units30_39_idx and idx in Info.core_idx and idx not in Info.excluded_idx and Info.credits[idx] !=0): # if 30-39 resit if core course                Info.referred_idx.append(idx)                  Info.marksout[idx] = Info.marksout[idx] + '_R'                Info.referredcoursenames += Info.coursenames[idx] + ' / '            elif (idx not in Info.deferred_idx and Info.credits[idx] !=0):        # else will be compensated (not for 0-credit units)                Info.marksout[idx] = Info.marksout[idx] + '_C'                Info.compensated_idx.append(idx)                Info.compensation = True                    # if > 40 credits at 30-39%, all core units must be resat    if ((Info.creditsfailed-Info.deferredcredits) > 40):        Info.resitstriggered = True        for idx in Info.failed_idx:  # loop through all failed courses            if (Info.marks[idx] < 29.95 and idx not in Info.excluded_idx and Info.credits[idx] !=0): # courses < 30% must be resat                Info.referred_idx.append(idx)                  Info.marksout[idx] = Info.marksout[idx] + '_R'                Info.referredcoursenames += Info.coursenames[idx] + ' / '            elif (idx in Info.core_idx and idx not in Info.excluded_idx and Info.credits[idx] !=0):  # only for core courses                Info.referred_idx.append(idx)                  Info.marksout[idx] = Info.marksout[idx] + '_R'                Info.referredcoursenames += Info.coursenames[idx] + ' / '            elif (idx not in Info.deferred_idx and Info.credits[idx] !=0): # else must be compensated as an option                Info.compensation = True                Info.compensated_idx.append(idx)                Info.marksout[idx] = Info.marksout[idx] + '_C'                    return Info################################################################# get overall average year markdef get_year_mark(Info):    marks = np.array(Info.marks.copy())    credweights = np.array(Info.credweights.copy())    sumcredweights = np.sum(credweights)    Info.sumcredweights = sumcredweights    if (sumcredweights > 0):        Info.yearmark = round(np.sum(marks*credweights)/sumcredweights + 0.000001,1)  # round to 1 d.p.    else:        Info.yearmark = 0.0        return Info################################################################# get overall average year mark for Physics and Math separately including overall year mark (for M+P students only)def get_mp_year_mark(Info):        marks       = np.array(Info.marks.copy())    credweights = np.array(Info.credweights.copy())  # Needed for separate Physics/Math averages    credits     = np.array(Info.credits.copy())      # Needed for year average for weighting of Physics/Math            # Physics    idx = Info.physics_units_idx    physicscredweights = np.sum(credweights[idx])    if (physicscredweights > 0):        physics_yearmark = np.sum(marks[idx]*credweights[idx])/physicscredweights  # do not round yet    else:        physics_yearmark = 0.0            # Math    idx = Info.math_units_idx    mathcredweights = np.sum(credweights[idx])    if (mathcredweights > 0):        math_yearmark = np.sum(marks[idx]*credweights[idx])/mathcredweights  # do not round yet    else:        math_yearmark = 0.0        # Overall year mark replaced by weighted average of M+P separately using original credit weightings (for M+P students only)    # Include deferred credits when calculating the Phys/Math credit split    if (Info.mathstudent):        #credweights2 = credweights.copy()        #for i in Info.deferred_idx: credweights2[i] = credits[i]   # put back credits        sumcredits_physics = np.sum(credits[Info.physics_units_idx])        sumcredits_math    = np.sum(credits[Info.math_units_idx])        yearmark           = (physics_yearmark*sumcredits_physics + math_yearmark*sumcredits_math)/(sumcredits_physics+sumcredits_math)        Info.yearmark      = round(yearmark+0.000001,1)  # only add back to Info if math student (round to 1 d.p.)            # Add back to Info    Info.physicscredweights = physicscredweights    Info.mathcredweights    = mathcredweights    Info.physics_yearmark   = round(physics_yearmark+0.000001,1)  # round to 1 d.p.    Info.math_yearmark      = round(math_yearmark+0.00001,1)      # round to 1 d.p.        # Add O/P/M string and physics/math credist taken string for output    Info.year_opm           = str(Info.yearmark) + ' / ' + str(Info.physics_yearmark) + ' / ' + str(Info.math_yearmark)     Info.creditstaken_pm    = str(Info.physicscreditstaken) + ' / ' + str(Info.mathcreditstaken)        return Info################################################################# get status for progression# remove referred/deferred info if already faileddef get_status(Info):    # borderlines for MPhys students    if (AY<=2019):        rbsc_upper = 52.95        rx_upper   = 54.95    else:        rbsc_upper = 51.95  # changed due to COVID after 2019        rx_upper   = 54.95        if (Info.deferredcoursenames != ''):        Info.status = 'A/D'         # student with deferrals    if (Info.referredcoursenames != ''):         Info.status = 'REVW'        # student with resits (REVW trumps A/D)                    # MPhys borderline/move to BSc students (for Y2/3 and above)    if (Info.mphysstudent == True and Info.classyear != 1 and Info.classyear != 4 and Info.classyear != 31):        if (Info.yearmark < rbsc_upper and len(Info.deferred_idx) == 0 and len(Info.referred_idx) == 0):            Info.status = 'R/BSc'        elif (Info.yearmark < rx_upper and len(Info.deferred_idx) == 0 and len(Info.referred_idx) == 0):            Info.status = 'R/X'    # Y3->Y4 progression    if (Info.classyear == 31):        if (Info.faillabprog==False and Info.creditspassed>=80 and Info.yearmark>=49.95 and Info.overallmark>=49.95):            Info.status   = 'ACTV'            Info.fail     = False            Info.progress = True        elif (Info.faillabprog==False and Info.creditspassed>=80 and (Info.yearmark>=47.95 and Info.overallmark>=47.95) ):  # borderline goes to review            Info.status   = 'REVW'            Info.fail     = True            Info.progress = False        elif (Info.faillabprog==False and Info.creditspassed>=60):  # borderline wtih fewer credits goes to review for BSc            if (Info.overallmark>59.95 and Info.creditspassed>=80): Info.status = 'REVW BSc 2:1'            elif (Info.overallmark>49.95 and Info.creditspassed>=80): Info.status = 'REVW BSc 2:2'            elif (Info.overallmark>39.95 and Info.creditspassed>=60): Info.status = 'REVW BSc 3'            else:                Info.status   = 'FAIL'                Info.fail     = True                Info.progress = False        else:  # MPhys Fail -> BSc            Info.status   = 'FAIL'            Info.fail     = True            Info.progress = False                # Additional requirement for M+P students to get >45% M+P separately to progress     if (Info.mathstudent == True and Info.finalyear == False):         if (Info.faillabprog == False and (Info.physics_yearmark<45 or Info.math_yearmark<45)): # >45% M+P separately            Info.status = 'REVW'            Info.fail = True            Info.progress = False            if (Info.classyear==31):                       if (Info.overallmark>boundaryupper2): Info.status = 'REVW BSc 2:1'                elif (Info.overallmark>boundarylower2): Info.status = 'REVW BSc 2:2'                elif (Info.overallmark>boundarythird): Info.status = 'REVW BSc 3'                else: Info.status = 'REVW'                Info.fail = True                Info.progress = False            if (Info.faillabprog == True):  # student has failed lab        Info.status = 'FAIL'    # If yearmark < 40% or fewer than 60 credits, then fail     if ((Info.creditspassed + Info.deferredcredits) < 60):        Info.fail   = True        Info.status = 'FAIL'            # Remove referred/deferred courses if already failed    if (Info.status == 'FAIL'):        for idx in Info.referred_idx: # remove referred codes            spos = Info.marksout[idx].find('_R')            Info.marksout[idx] = Info.marksout[idx][0:spos]        for idx in Info.deferred_idx: # remove deferred codes            spos = Info.marksout[idx].find('_D')            Info.marksout[idx] = Info.marksout[idx][0:spos]        for idx in Info.compensated_idx: # remove compensated codes            spos = Info.marksout[idx].find('_C')            Info.marksout[idx] = Info.marksout[idx][0:spos]                # and remove other relevant arrays        Info.referred_idx = []        Info.referredcoursenames = ''        Info.deferred_idx = []        Info.deferredcoursenames = ''        return Info################################################################# Get overall mark based on years availabledef get_overall_mark(Info,doCF):    overallmark=-1    overallmathmark=-1    overallphysicsmark=-1    progtaken = Info.Plan        # If no Carry Forward, then can only do this years mark and get out    if (doCF == False):        Info.overallmark = overallmark        Info.overallphysicsmark = overallphysicsmark        Info.overallmathmark   = overallmathmark        Info.overallmark_opm   = ''                return Info        # BSc    if ('BSc' in progtaken and 'Math' not in progtaken):                if(Info.phys1<0 and Info.phys2>0): overallmark=0.3333*Info.phys2+0.6666*Info.yearmark # no first year mark, so direct entry        elif(Info.phys1<0 and Info.phys2<0): overallmark = Info.yearmark  # no first or second year mark, so direct entry (also 1st year)        elif(Info.phys1>0 and Info.phys2<0): overallmark = 0.25*Info.phys1 + 0.75*Info.yearmark  # for 2nd years when CF file available        else: overallmark = 0.1*Info.phys1+0.3*Info.phys2+0.6*Info.yearmark        overallphysicsmark = overallmark            # BSc M/P    if ('BSc' in progtaken and 'Math' in progtaken):        if (Info.phys1<0 and Info.phys2>0): # no first year mark, so direct entry            overallmark=0.3333*(Info.phys2+Info.math2)/2.+0.6666*Info.yearmark             overallphysicsmark = 0.3333 * Info.phys2 + 0.6666 * Info.physics_yearmark             overallmathmark = 0.3333 * Info.math2 + 0.6666 * Info.math_yearmark        elif (Info.phys1>0 and Info.phys2<0): # 2nd year students when CF file available             overallmark = 0.25*(Info.phys1+Info.math1)/2. + 0.75*Info.yearmark            overallphysicsmark = 0.25*Info.phys1 + 0.75*Info.physics_yearmark            overallmathmark = 0.25*Info.math1 + 0.75*Info.math_yearmark        else:            overallmark= 0.1*(Info.phys1+Info.math1)/2. + 0.3*(Info.phys2+Info.math2)/2. +0.6*Info.yearmark            overallphysicsmark = 0.1*Info.phys1 + 0.3*Info.phys2 + 0.6*Info.physics_yearmark            overallmathmark = 0.1*Info.math1 + 0.3*Info.math2 + 0.6*Info.math_yearmark                         #  MPHYS    if ('MPhys' in progtaken and 'Math' not in progtaken):        if (Info.phys1>0 and Info.phys2>0 and Info.phys3<0): overallmark = (0.06/0.625)*Info.phys1 + (0.19/0.625)*Info.phys2 + (0.375/0.625)*Info.yearmark # 3rd year progressing        elif (Info.phys1 < 0 and Info.phys2 > 0 and Info.classyear == 31): overallmark = (0.19/0.565)*Info.phys2 + (0.375/0.565)*Info.yearmark # 3rd year progressing (no 1st year mark)        elif (Info.phys1 < 0 and Info.phys2 > 0 and Info.phys3 > 0): overallmark = 0.2*Info.phys2+ 0.4*Info.phys3 + 0.4*Info.yearmark  # no first  year mark, so direct entry        elif (Info.phys1 < 0 and Info.phys2 < 0 and Info.phys3>0): overallmark = 0.5*Info.phys3 + 0.5*Info.yearmark  # no first or second year mark, so direct entry (4th year)        elif (Info.phys1 < 0 and Info.phys2 < 0 and Info.phys3<0): overallmark = Info.yearmark  # only 4th year mark available        elif (Info.phys1>0 and Info.phys2<0): overallmark = (0.06/0.25)*Info.phys1 + (0.19/0.25)*Info.yearmark   # 2nd year when CF file available         else: overallmark = 0.06 * Info.phys1 + 0.19 * Info.phys2 + 0.375 * Info.phys3 + 0.375*Info.yearmark   # 4th year default              # MPHYS study in    if ('MPhys' in progtaken and 'Math' not in progtaken and 'Study' in progtaken):        if (Info.phys1>0 and Info.phys2<0): overallmark = (0.08/0.31)*Info.phys1 + (0.23/0.31)*Info.yearmark   # 2nd year when CF available         elif (Info.phys1>0 and Info.phys2>0 and Info.phys3<0): overallmark = (0.08/0.54)*Info.phys1 + (0.23/0.54)*Info.phys2 + (0.23/0.54)*Info.yearmark   # 3rd year        else: overallmark = 0.08 * Info.phys1 + 0.23 * Info.phys2 + 0.23 * Info.phys3 + 0.46*Info.yearmark     # 4th year    # Phys Europe 4th year - requires [3A] or [A] to be added to the program code to differentiate them.    if ('3A' in progtaken or '[A]' in progtaken):        overallmark = 0.08 * Info.phys1 + 0.23 * Info.phys2 + 0.23 * Info.phys3 + 0.46 * Info.yearmark    overallphysicsmark = overallmark  # log physics mark        # MPHYS M/P.    if ('Phys' in progtaken and 'Math' in progtaken and 'BSc' not in progtaken):        if (Info.phys1 < 0 and Info.phys2 > 0): # no first  year mark, so direct entry            overallmark = 0.2*(Info.phys2+Info.math2)/2.+ 0.4*Info.year3mark + 0.4*Info.yearmark              overallmathmark = 0.2*Info.math2 + 0.4*Info.math3 + 0.4*Info.math_yearmark            overallphysicsmark = 0.2*Info.phys2+ 0.4*Info.phys3 + 0.4*Info.physics_yearmark        elif (Info.phys1 < 0 and Info.phys2 < 0): # no first or second year mark, so direct entry            overallmark = 0.5*Info.year3mark + 0.5*Info.yearmark              overallphysicsmark = 0.5*Info.phys3 + 0.5*Info.physics_yearmark            overallmathmark = 0.5*Info.math3 + 0.5*Info.math_yearmark        elif (Info.phys1>0 and Info.phys2<0):  # 2nd years when CF file available             #overallmark = 0.06/0.25 * (Info.phys1+Info.math1)/2. + 0.19/0.25*(Info.math_yearmark+Info.physics_yearmark)/2.            overallmark = 0.06/0.25 * (Info.phys1+Info.math1)/2. + 0.19/0.25*Info.yearmark            overallmathmark =  0.06/0.25 * Info.math1 + 0.19/0.25 * Info.math_yearmark            overallphysicsmark = 0.06/0.25 * Info.phys1 + 0.19/0.25 * Info.physics_yearmark        elif (Info.phys1>0 and Info.phys2>0 and Info.phys3<0): # 3rd years            overallmark = (0.06/0.625)*(Info.phys1+Info.math1)/2. + (0.19/0.625)*(Info.phys2+Info.math2)/2. + (0.375/0.625)*Info.yearmark            overallmathmark =  (0.06/0.625)*Info.math1 + (0.19/0.625)*Info.math2 + (0.375/0.625)*Info.math_yearmark            overallphysicsmark = (0.06/0.625)*Info.phys1 + (0.19/0.625)*Info.phys2 + (0.375/0.625)*Info.physics_yearmark        else: # 4th years            overallmark = 0.06 * (Info.phys1+Info.math1)/2. + 0.19 * (Info.phys2+Info.math2)/2. + 0.375 * Info.year3mark + 0.375*Info.yearmark            overallmathmark =  0.06 * Info.math1 + 0.19*Info.math2 + 0.375*Info.math3 + 0.375*Info.math_yearmark            overallphysicsmark = 0.06 * Info.phys1 + 0.19 * Info.phys2 + 0.375 * Info.phys3 + 0.375*Info.physics_yearmark    # Add back to Info    Info.overallmark         = round(overallmark+0.000001,1)    Info.physics_overallmark = round(overallphysicsmark+0.000001,1)    Info.math_overallmark    = round(overallmathmark+0.000001,1)    # also output O/P/M    Info.overallmark_opm = str(Info.overallmark) + ' / ' + str(Info.physics_overallmark) + ' / ' + str(Info.math_overallmark)        return Info################################################################# get degree classification based on overall mark for finalyear students# also, include promotion if relevantdef get_degclass(Info):    # If not final year    if (Info.finalyear == False):        return Info    fail = 0  # Not a fail by default    # BSc    if (classyear == 32):                    # get appropriate number of credits passed        if (AY >= 2022): creditspassed = Info.credits3passed  # must be Y3 courses from 2022 onwards        else: creditspassed = Info.creditspassed  # any final year credits ok for AY before 2022                    if  creditspassed>=creditstogetBScgood and Info.overallmark>=boundaryfirst:            honours=1            degclass=4        elif creditspassed >= creditstogetBSclower and creditspassed <=creditstogetBScgood and Info.overallmark >= boundaryfirst:            honours = 1            degclass = 3        elif creditspassed>=creditstogetBScgood and Info.overallmark>=boundaryupper2 and Info.overallmark<boundaryfirst:            honours = 1            degclass = 3        elif creditspassed>=creditstogetBSclower and creditspassed <=creditstogetBScgood and Info.overallmark>=boundaryupper2 and Info.overallmark<boundaryfirst:            honours = 1            degclass = 2        elif creditspassed>=creditstogetBScgood and Info.overallmark>=boundarylower2 and Info.overallmark<boundaryupper2:            honours = 1            degclass = 2        elif creditspassed>=creditstogetBSclower and creditspassed<creditstogetBScgood and Info.overallmark>=boundarylower2 and Info.overallmark<boundaryupper2:            honours = 1            degclass = 1        elif creditspassed >= creditstogetBSclower and Info.overallmark >= boundarythird:            honours = 1            degclass = 1        elif creditspassed >= creditstogetBSclower:            honours =0            degclass=0        else: # Fail            honours=0            degclass=-1            fail = 1    # MPhys    if (classyear == 4):        if  Info.creditspassed>=creditstogetMPHYS and Info.overallmark>=boundaryfirst:            honours=1            degclass=4        elif Info.creditspassed>=creditstogetMPHYS and Info.overallmark>=boundaryupper2 and Info.overallmark<boundaryfirst:            honours = 1            degclass = 3        elif Info.creditspassed>=creditstogetMPHYS and Info.overallmark>=boundarylower2 and Info.overallmark<boundaryupper2:            honours = 1            degclass = 2        # no thirds in MPHYS        else: # Fail            honours=0            fail = 1            degclass=-1    # Put back into Info    Info.honours  = honours    Info.degclass = degclass    Info.fail     = fail    return Info################################################################# Apply promotion to borderline students in final yeardef apply_promotion(Info):    if (Info.finalyear == False):  # if not final year, continue        return Info    # determine if borderline or not    if( (Info.overallmark >= borderfirst and Info.overallmark < boundaryfirst) or (Info.overallmark >= borderupper2 and Info.overallmark < boundaryupper2) or (Info.overallmark >= borderlower2 and Info.overallmark < boundarylower2) or (Info.overallmark>=borderthird and Info.overallmark<boundarythird)):        Info.borderline = True        Info.promote    = False    else:   # Just carry on if not borderline        Info.borderline = False        Info.promote = False        return Info    # If borderline see if can be promoted    if (Info.borderline == True):        # Get credits credits in each class        marks = Info.marks.copy()        idx = [i for i, v in enumerate(marks) if v >= boundaryfirst] # 1st        Info.credsatfirst = sum([Info.credits[i] for i in idx])        idx = [i for i, v in enumerate(marks) if (v >= boundaryupper2 and v < boundaryfirst)]  #2:1        Info.credsatupper2 = sum([Info.credits[i] for i in idx])        idx = [i for i, v in enumerate(marks) if (v >= boundarylower2 and v < boundaryupper2)] #2:2        Info.credsatlower2 = sum([Info.credits[i] for i in idx])        idx = [i for i, v in enumerate(marks) if (v >= boundarythird and v < boundarylower2)]  #3rd        Info.credsatthird = sum([Info.credits[i] for i in idx])        # credits above each class        Info.credsaboveupper2 = Info.credsatfirst + Info.credsatupper2        Info.credsabovelower2 = Info.credsatupper2 + Info.credsatlower2        Info.credsabovethird  = Info.credsatlower2 + Info.credsatthird                # Apply algorithm A        if (Info.classyear == 32):  # BSc            if(Info.degclass==3 and Info.credsatfirst>=creditstogetBScgood):                Info.promote=True            if(Info.degclass==2 and Info.credsaboveupper2>=creditstogetBScgood):                Info.promote=True            if(Info.degclass==1 and Info.credsabovelower2>=creditstogetBScgood):                Info.promote=True        else: # MPhys            if (Info.degclass == 3 and Info.credsatfirst >= creditstogetMPHYSalgA):                Info.promote = True            if (Info.degclass == 2 and Info.credsaboveupper2 >= creditstogetMPHYSalgA):                Info.promote = True            if (Info.degclass == 1 and Info.credsabovelower2 >= creditstogetMPHYSalgA):                Info.promote = True        # If A is successful, promote and return        if (Info.promote == True):            Info.promotetype = 'A'            Info.degclass += 1            return Info        # if A doesn't work, try algorithm B        if(Info.classyear == 32):  # BSc            if(Info.degclass==3 and Info.credsatfirst >= creditstogetalgB and Info.projectmark>=boundaryfirst and Info.yearmark>Info.overallmark):                Info.promote=True            if(Info.degclass==2 and Info.credsaboveupper2 >= creditstogetalgB and Info.projectmark>=boundaryupper2 and Info.yearmark>Info.overallmark):                Info.promote=True            if(Info.degclass==True and Info.credsabovelower2 >= creditstogetalgB and Info.projectmark>=boundarylower2 and Info.yearmark>Info.overallmark):                Info.promote=True        else: # MPhys            if (Info.degclass==3 and Info.credsatfirst >= creditstogetalgB and Info.projectmark>=boundaryfirst and Info.yearmark > Info.overallmark):                Info.promote = True            if (Info.degclass==2 and Info.credsaboveupper2 >= creditstogetalgB and Info.projectmark>=boundaryupper2 and Info.yearmark > Info.overallmark):                Info.promote = True            if (Info.degclass==1 and Info.credsabovelower2 >= creditstogetalgB and Info.projectmark>=boundarylower2 and Info.yearmark > Info.overallmark):                Info.promote = True        # If B is successful, promote and return        if (Info.promote == True):            Info.promotetype = 'B'            Info.degclass += 1            return Info    return Info################################################################# convert degree class to a string for output grid# Also apply additional finalyear criteria to affect output stringdef degclass_to_string(Info):    # deg classification    degclass_dict = {        4:"1",        3:"2:1",        2:"2:2",        1:"3",        0:"Ord.",        -1:"Fail",        -2:"NOT SET!!!"}    # degree type    degstr = Info.Plan.split('(')[0] + ' '    # Add to Info, keeping original class if promoted and add promotion string if necessary    if (Info.promote == True):        Info.degclass_str = degstr + degclass_dict[Info.degclass-1] + ' P(' + Info.promotetype + ')'    else:        Info.degclass_str = degstr + degclass_dict[Info.degclass] #     # If 4th year MPhys fail, output REVW BSc    if (Info.classyear == 4 and Info.finalyear == True and Info.fail == True):        if (Info.overallmark>boundaryupper2): Info.degclass_str = 'REVW BSc 2:1'        elif (Info.overallmark>boundarylower2): Info.degclass_str = 'REVW BSc 2:2'        elif (Info.overallmark>boundarythird): Info.degclass_str = 'REVW BSc 3'        else: fail = True    # If Euro student probably don't have all marks in so reset - temporary!!    if ('Eu' in Info.Plan):        Info.degclass_str = ''        Info.fail = False                return Info################################################################# make basic output dataframe def make_output_df():    # make list of all possible columns    columns = ['Emplid', 'Name', 'Plan', 'Unit 1', 'Unit 2', 'Unit 3', 'Unit 4', 'Unit 5', 'Unit 6', 'Unit 7', 'Unit 8', 'Unit 9', 'Unit 10', 'Unit 11', 'Unit 12', 'Unit 13', 'Unit 14', 'Unit 15', 'Unit 16', 'Unit 17', 'Unit 18', 'Unit 19', 'Unit 20', 'Credits Taken', 'Credits Passed', 'Year Mark', 'Overall', 'Year Av O/P/M', 'Status', 'Referred', 'Deferred','Resits', 'Mit Circ']        # make dataframe    df = pd.DataFrame(columns=columns)    return df################################################################# add column data from this student (Info) to the output student dataframedef add_data_df(df,Info,doCF,encode_sids):    # First few columns    if (encode_sids == True):        new_row1 = {'Emplid': Info.emplid, 'Emplid*': Info.emplid_encoded, 'Name': Info.Name, 'Plan': Info.Plan}        new_row2 = {'Emplid': '', 'Emplid*': '', 'Name': '', 'Plan': ''}    elif (Info.anonymous == False):        new_row1 = {'Emplid': Info.emplid, 'Name': Info.Name, 'Plan': Info.Plan}        new_row2 = {'Emplid': '', 'Name': '', 'Plan': ''}    else:        new_row1 = {'Emplid*': Info.emplid_encoded, 'Plan': Info.Plan}        new_row2 = {'Emplid*': '', 'Plan': ''}            # Add each unit that exists    for i in range(len(Info.coursenamesout)):           unit_str = 'Unit ' + str(i+1)         new_row1[unit_str] = Info.coursenamesout[i]        new_row2[unit_str] = Info.marksout[i]     # Rest of default columns    new_row1['Creds Taken']      = Info.creditstaken    new_row1['Creds Passed']     = Info.creditspassed    new_row1['Creds Taken/Passed'] = str(Info.creditstaken) + ' / ' + str(Info.creditspassed)    new_row1['Phys/Math Creds Taken'] = Info.creditstaken_pm    new_row1['Year Mark']          = Info.yearmark    new_row1['Year Av O/P/M']      = Info.year_opm    new_row1['Status']             = Info.status    new_row1['Mit Circ']           = Info.mitcirc    new_row1['Referred']           = Info.referredcoursenames    new_row1['Deferred']           = Info.deferredcoursenames    new_row1['Resits']             = Info.deferredcoursenames + Info.referredcoursenames        new_row2['Creds Taken']      = ''    new_row2['Creds Passed']     = ''    new_row2['Creds Taken/Passed'] = ''    new_row2['Phys/Math Creds Taken'] = ''    new_row2['Year Mark']          = ''    new_row2['Year Av O/P/M']      = ''    new_row2['Status']             = ''    new_row2['Mit Circ']           = ''    new_row2['Referred']           = ''    new_row2['Deferred']           = ''    new_row2['Resits']             = ''    # CF info if available    if (doCF == True):        new_row1['Phys 1']         = Info.phys1        new_row1['Phys 2']         = Info.phys2        new_row1['Phys 3']         = Info.phys3        new_row1['Math 1']         = Info.math1        new_row1['Math 2']         = Info.math1        new_row1['Math 3']         = Info.math1        new_row1['Overall']        = Info.overallmark        new_row1['Phys Overall']   = Info.physics_overallmark        new_row1['Math Overall']   = Info.math_overallmark        new_row1['Overall O/P/M']  = Info.overallmark_opm                    new_row2['Phys 1']         = ''        new_row2['Phys 2']         = ''        new_row2['Phys 3']         = ''        new_row2['Math 1']         = ''        new_row2['Math 2']         = ''        new_row2['Math 3']         = ''        new_row2['Overall']        = ''        new_row2['Phys Overall']   = ''        new_row2['Math Overall']   = ''        new_row2['Overall O/P/M']  = ''        if (Info.finalyear == True):  # Final year students            new_row1['Honours']    = Info.honours            new_row1['Fail']       = Info.fail            new_row1['Deg']        = Info.degclass            new_row1['Deg Class']  = Info.degclass_str            new_row2['Honours']    = ''            new_row2['Fail']       = ''            new_row2['Deg']        = ''            new_row2['Deg Class']  = ''                    if (Info.classyear == 4 and Info.mathstudent == True) : # for 4th M+P students            new_row1['Year 3']         = Info.year3mark            new_row2['Year 3']         = ''                # add the rows to the df    df = df.append(new_row1, ignore_index=True)    df = df.append(new_row2, ignore_index=True)    return df################################################################# Get maximum unit number used in a dataframe that actually contains datadef get_maxunit_number(df):    maxunit = 0  # counter    for i in range(20):  # max units will be 20        unit_str = 'Unit ' + str(i+1)        data     = df[unit_str].tolist()   # data for this unit number        if (any(data) == True): # check if any non-empty strings            maxunit += 1        return maxunit################################################################# Set output columns for output spreadsheet depending on student type/yeardef set_output_columns(Info,maxunit,doCF):    # First few columns are same for all (no Name if anonymous)    if (encode_sids == True):        columns = ['Emplid*', 'Emplid', 'Name', 'Plan']    elif (Info.anonymous == False):        columns = ['Emplid', 'Name', 'Plan']    else:        columns = ['Emplid*', 'Plan']            # Units where data exist    for i in range(maxunit):        unit_str = 'Unit ' + str(i+1)        columns.append(unit_str)    # Credits passed/taken    #columns.append('Creds Taken')    #columns.append('Creds Passed')    columns.append('Creds Taken/Passed')  # combined column to save space        # Physics/maths credits if M+P student    #if (Info.mathstudent == True):    #    columns.append('Phys/Math Creds Taken')        # Marks columns depending on years/student type    # Previous years marks (if doCF == True)    if (doCF == True):        if (Info.classyear == 2):            columns.append('Phys 1')        if (Info.classyear == 31 or Info.classyear == 32):            columns.append('Phys 1')            columns.append('Phys 2')        if (Info.classyear == 4):            columns.append('Phys 1')            columns.append('Phys 2')            columns.append('Phys 3')    # Previous math marks if M+P student    if (Info.mathstudent == True and doCF == True):        if (Info.classyear == 2):            columns.append('Math 1')        if (Info.classyear == 31 or Info.classyear == 32):            columns.append('Math 1')            columns.append('Math 2')        if (Info.classyear == 4):            columns.append('Math 1')            columns.append('Math 2')            columns.append('Math 3')             # Year mark    if (Info.mathstudent == True):  # Math students have O/P/M        columns.append('Year Av O/P/M')    else:        columns.append('Year Mark')    # Overall mark    if (doCF == True):        if (Info.mathstudent == False):            columns.append('Overall')        else:            columns.append('Overall O/P/M')            # Mit Circ    columns.append('Mit Circ')    # Deg Class if final year otherwise Status if not final year    if (doCF == True and Info.finalyear == True):        columns.append('Deg Class')    else:        columns.append('Status')    # Resits for Y1/Y2    if (Info.classyear == 1 or Info.classyear == 2):        columns.append('Resits')            return columns################################################################# sort df by year mark (progressing) / overall mark (final year)def sort_df(df,Info):    # progressing students    if (Info.finalyear == False):        for i in np.arange(0,df.shape[0]-1,2): df["Year Mark"].values[i+1] = df["Year Mark"].values[i]        df.sort_values(by="Year Mark",ascending=False,inplace=True,kind='mergesort')        for i in np.arange(0,df.shape[0]-1,2): df["Year Mark"].values[i+1] = ''        # graduating students    if (Info.finalyear == True):        for i in np.arange(0,df.shape[0]-1,2): df["Overall"].values[i+1] = df["Overall"].values[i]        df.sort_values(by="Overall",ascending=False,inplace=True,kind='mergesort')        for i in np.arange(0,df.shape[0]-1,2): df["Overall"].values[i+1] = ''    return df################################################################# Add useful codes to end of spreadsheetdef add_codes_df(df):    code_info = np.array([['',''],                ['Key:',''], ['',''],                 ['Mit Circ','Mitigating Circumstances'],                 ['#','Mit Circs not accepted'],                ['#*','Mit Circs acc; no action'],                ['#**','Mit Circs acc; action taken'],                ['',''],                ['ACTV','Met progression criteria (BSc/MPhys)'],                ['REVW','Review (resits)'],                ['A/D', 'Deferred units'],                ['R/X','MPhys student not achieved 55%'],                ['R/BSc','MPhys student not achieved 52%'],                ['FAIL','Failed due to <40% overall or <40% in lab or <60 credits'],                ['',''],                ['XL','Absent from exam, with reason'],                ['XN','Absent from exam, no reason'],                ['X','Mark excluded'],                ['X1','Resit at first attempt'],                ['',''],                ['*', 'Carry Forward flag in year mark']])                #['XX_P1 (YY)', 'XX post-penalty mark, YY pre-penalty mark (>=40%)'],                #['XX_P2 (YY)', 'XX post-penalty mark, YY pre-penalty mark (30-39%)'],                #['XX_P3 (YY)', 'XX post-penalty mark, YY pre-penalty mark (<30%)'] ])        nrows = np.shape(code_info)[0]   # number of extra rows to add    tempdf_single = df[0:1].copy()  # single line temporary df    tempdf = tempdf_single.copy()  # tempdf to be added to main dataframe    while (tempdf.count()[0] <= nrows):  # copy extra rows if they required otherwise will not get full list of codes        tempdf = pd.concat([tempdf,tempdf_single])    tempdf[:] = ''  # blank values    for i in np.arange(nrows):  # add code info        tempdf[columns[0]][i:i+1] = code_info[i,0]        tempdf[columns[1]][i:i+1] = code_info[i,1]    df = pd.concat([df,tempdf])   # add df's together    return df, nrows################################################################# Encode student IDs def encode_emplid(Info):    sid = Info.emplid    ndigits = len(sid)    offsets = [1,2,3]*10  # long list of offsets to add to each digit *except* the last one    lastdigit = int(sid[-1])  # last digit for getting starting point of offset            sid_encoded = 'E'  # always begin with an "E" to show it is encoded     for i in range(ndigits-1):        digit = (int(sid[i]) + offsets[i] + lastdigit)%10   # add offset based on last digit then take last digit        sid_encoded += str(digit)    sid_encoded += str(lastdigit)   # add original last digit back which is needed to decode        Info.emplid_encoded = sid_encoded  # add back to Info                return Info################################################################# Apply CF flags if CF_flagfile availabledef apply_CFflags(dfout,df_CFflags,doCF):    # If no data, do nothing    if (CF_flagfile == '' or doCF == False):        return dfout    # Print statement    print('Applying CF flags...')        # get data from CF flag file    flags_sid = df_CFflags.iloc[:,1].values  # 2nd column    flags_year = df_CFflags.loc[:,"Year"].values     nflags = len(flags_sid)    # loop through each row in CF flag file    for i in range(nflags):        sid = flags_sid[i]        year = str(flags_year[i])        idx = dfout[dfout.loc[:,'Emplid'] == sid].index.values  # row index of student        # skip if no matching student        if (len(idx) < 1):            continue                # edit the mark in the appropriate column by adding a '*'        if (year == '2'): column = 'Phys 2'        if (year == '3'): column = 'Phys 3'        markout = dfout.loc[idx[0]][column]        markout = str(markout) + '*'        dfout.loc[idx[0], column] = markout            return dfout################################################################# output to Excel spreadsheet (strings_to_numbers option so not to store unit numbers as text)def df_to_excel(df, columns, nrows, outfilename='test.xlsx',sheet_name='Sheet 1'):    try:        writer = pd.ExcelWriter(outfilename, engine='xlsxwriter',engine_kwargs={'options': {'strings_to_numbers': True}})    except:        print('\nERROR writing out to {0:s} Please check directory...\n'.format(outfilename))        sys.exit(0)        # output columns to excel spredsheet directly from Data Frame    df.to_excel(writer,index=False,sheet_name=sheet_name,columns=columns)        # Change column width/formatting before finally writing out    workbook = writer.book    worksheet = writer.sheets[sheet_name]   # Sheet name    format1dp = workbook.add_format({'num_format': '#0.00'})  # Add float formatting to 1.d.p.        i = 0    for column_str in columns: # loop over each column        col_idx = i  # df.columns.get_loc(column_str)        format1 = None  # default is no format                # set the widths        if (column_str.find('Emplid') >=0): col_width=9        elif (column_str == 'Name'): col_width=15        elif (column_str == 'Plan'): col_width=20        elif (column_str.find('Unit') >= 0): col_width=9        elif (column_str.find('Creds') >= 0): col_width=17        elif (column_str.find('Final Year Physics Mark') >=0): col_width=18        elif (column_str.find('Final Year Math Mark') >=0): col_width=16        elif (column_str.find('O/P/M') >=0): col_width=14        elif (column_str.find('Overall') >=0):                col_width=8                format1 = format1dp        elif (column_str.find('Overall Physics') >=0): col_width=15        elif (column_str.find('Overall Math') >=0): col_width=13        elif (column_str.find('Phys') >= 0): col_width=6        elif (column_str.find('Math') >= 0): col_width=7        elif (column_str.find('Year 3 Mark') >=0): col_width=8        elif (column_str.find('Year Mark') >=0): col_width=9        elif (column_str.find('Status') >=0): col_width=8        elif (column_str.find('Deg Class') >= 0): col_width=15        elif (column_str.find('Resits') >= 0): col_width=15        elif (column_str.find('Mit') >= 0 or column_str.find('Sp') >=0): col_width=6        else: col_width=12  # default column width        writer.sheets[sheet_name].set_column(col_idx, col_idx, col_width,format1)  # Set column width and any other formatting        # Make sure year and overall marks are to 1 d.p. (e.g. 3.0 not 3)        #if (column_str.find('Year') >= 0 or column_str.find('Overall') >=0):        #    writer.sheets[sheet_name].set_column(col_idx, col_idx, None, format1dp)            #worksheet.set_column(col_idx, col_idx, None, format1dp)        i += 1  # increment counter    # Make original id and name columns hidden if encode_sids option is set    if (encode_sids == True):        col_idx = columns.index('Emplid')        worksheet.set_column(col_idx, col_idx, None, None, {'hidden': True})        col_idx = columns.index('Name')        worksheet.set_column(col_idx, col_idx, None, None, {'hidden': True})                    # make banded rows and slightly larger cells for easier viewing    #format1_pale = workbook.add_format({'bg_color': '#FFFFCC'})    format1_grey = workbook.add_format({'bg_color': '#E0E0E0'})    cellheight = 17  # (Excel default is 15)    nrows = df.count()[0]-nrows    for row in range(1, nrows, 2):        worksheet.set_row(row, cellheight, cell_format=format1_grey)    # Write out and finish    writer.save()    return None################################################################################################################################# some data definitions################################################################# Credits requiredcreditstogetMPHYS = 80  creditstogetBScgood=80creditstogetBSclower=60if (int(AY) <= 2019): creditstogetMPHYSalgA = 75 # Used for algA else: creditstogetMPHYSalgA = 80 # New rule for 2020 onwardscreditstogetalgB = 70  # Used for algB# boundaries for degree class (2 d.ps because marks are stored to 1 d.p.)boundaryfirst=69.95boundaryupper2=59.95boundarylower2=49.95boundarythird=39.95# borderlines for promotion consideration if (AY == 2020 or AY == 2021):    borderfirst = boundaryfirst - 3.0    borderupper2 = boundaryupper2 - 3.0    borderlower2 = boundarylower2 - 3.0    borderthird = boundarythird - 4.0else:    borderfirst = boundaryfirst - 2.0    borderupper2 = boundaryupper2 - 2.0    borderlower2 = boundarylower2 - 2.0    borderthird = boundarythird - 3.0# any students to skip# For 2021 to omit exception students (see Suzanne's email 11-Jun-2021 and Y2 issues xls file and Judith email 08-Jul-2021) if (int(AY) == 2021): donotprocess={'10304702','10301241','10341954','9954785','9976148','9914290'}   # IDs should be strings! else: donotprocess={}# define core for purpose of triggered resits i.e.  what gets resat if a student is going to have resits anyway.# This one is for studtype=1, for most Physics studentsisphysicscore={'PHYS10071','PHYS10101','PHYS10121','PHYS10191','PHYS10302','PHYS10342','PHYS10352','PHYS10372','PHYS20101','PHYS20141','PHYS20171','PHYS20252','PHYS20312','PHYS20352'}# M+P students have a different list in *addition* to the iscore list above# (only need 2nd year courses because all MATHs courses in Y1 must be passed - these courses add later when they are known)ismathcore={'MATH20401', 'MATH29142'}# Set the core list depending on whether M+P student or notif (studtype == 1): iscore = isphysicscoreelse: iscore = isphysicscore.union(ismathcore)#define what must be passed e.g. lab, BSc dissertation.mustpass={'PHYS10180','PHYS10280',          'PHYS20180','PHYS20280',          'PHYS30180','PHYS30280','PHYS30880',          'PHYS40181','PHYS40182'}# these are where units may have different credits for the marks vs progression (*make sure these are integers, not floats!)credweightunits={'PHYS20040':10,  # main general paper (doesn't count towards progression/resits, but does count towards marks)'PHYS20240':6,            # shorter version worth only 6 (M+P,Phys/Phil, 2nd/3rd year direct entry) 'PHYS20811':5,            # Professional development CD: changed from 9 to 5 in AY2021'PHYS20821':5,            # for the few students resitting the year this course still here'PHYS30010':10,           # General paper (doesn't count towards progression/resits, but does count towards marks)'PHYS30210':6,           # General paper (short version for M+P, Phys/Phil, 2nd/3rd year direct entry)'PHYS30811':3}             # Added back for those few students re-sitting#'PHYS20030':0,            # Peer-Assisted Study Sessions (PASS) - no marks, no credits, but here just in case #'ULGE21030':0,            # #'ULFR21030':0,#'ULJA21020':0,#'ULRU11010':0,#'MATH35012':0,#'COMP39112':0,#'MATH49102':0}if (int(AY) <= 2020): credweightunits['PHYS20811'] = 9  # Professional development CD: changed from 9 to 5 in AY2021if (int(AY) >= 2022): credweightunits['PHYS30811'] = 0  # Now 0 (Judith, priv. comm. 24-Jun-2022)     noresitlist={}  # any units that can't be resit (other than 0 credit units (which are not resitable) like lab etc.)# courses to completley ignore because they don't have a mark e.g. tutorials, PASS etc. ignore_courses={'MPHYS',         # not a course                'MPHYSON',       # not a course                'PHYS10000',    # tutorials/similar                'PHYS20000',    # tutorials/similar                'PHYS30000',    # tutorials/similar                'PHYS40000',    # tutorials/similar                'PHYS10010',                    'PHYS10020',                  'PHYS10030',    # PASS (no mark/credits)                'PHYS10022',                'PHYS11000',                'PHYS21000',                'PHYS31000',                'PHYS41000',                'PHYS20030',                'PHYS19990',    # PASS Peer=Assissted Self-Study                'PHYS29990',    # PASS Peer=Assissted Self-Study                'PHYS39990',    # PASS Peer=Assissted Self-Study                'PHYS49990',    # PASS Peer=Assissted Self-Study                'MATH S100',    # Math Study module (0 credited) [last 0 omitted on prurpose because of extra gap]                'MATH S200',    # Math Study module (0 credited) [last 0 omitted on prurpose because of extra gap]                'MATH S300',    # Math Study module (0 credited) [last 0 omitted on prurpose because of extra gap]                'MATH S400',    # Math Study module (0 credited) [last 0 omitted on prurpose because of extra gap]                'MATH    S',     # sometimes this format                }    ############################################################################################################################################################################################# NOW THE RUNNING PART OF THE CODE############################################################################################################################################################################################# final filenamefilename= indir + filename# Do Carry Forward or not depending on CFfilename, OR, manually set to False to ignore CFif (CFfilename != ''):    doCF = Trueelse:    doCF = Falseif (AY == 2019 and classyear == 2): doCF = False  # no 2nd year carry forward available in 2018/19#doCF = False  # to manually override if no CF available (usually - just comment out this line with a '#' at the front)    # get input datadfallstudents = read_data(filename)              # read in file to a Pandas dataframe and remove NaNsdfallstudents = extract_students_by_type(dfallstudents,classyear, studtype) # extract relevant students on programmedf_CF         = get_CF_data(doCF, CFfilename)    # Get CarryForward data from separate file (if exists and doCF==True)dfout         = make_output_df()                 # Empty output dataframe with all possible columns                            sids          = get_sids(dfallstudents)          # get student ids for all relevant studentscolumn_names  = dfallstudents.columns.to_list()  # get column namesnstudents     = len(sids)                        # Number of students to deal withdf_CFflags    = read_CFflags(CF_flagfile, doCF)  # If CF_flagfile exists and doCF==True, read in the data for later################################################################# loop over SIDscounter = 0           # counter for student numberall_sids = []         # for later if neededall_sids_encoded = [] # for later if neededfor anid in sids:    # info    counter += 1    print('Processing student ID {0:s} ({1:d}/{2:d})'.format(anid,counter,nstudents))    if (anid in donotprocess):        continue            # do most of the work    dfstudent = get_dfstudent(dfallstudents,anid)                   # get df for this student including unnamed columns    Info      = make_Info(dfstudent,anid,classyear, ignore_courses) # Make basic Info record class using input data (courses/marks/credits etc)    Info      = add_CF_data(Info,df_CF, anid)                    # Add CF data to Info    Info      = get_credweights(Info,credweightunits,useidx=False)  # Get credit weights using credweightunits dictionary    Info      = exclude_courses(Info)                               # Determine excluced courses    Info      = get_math_units(Info)                                # Determine which units are maths, marks/credits/credits takens    Info      = get_core_courses(Info,isphysicscore, ismathcore)   # Determine which courses are "core" including Math for M+P students    Info      = get_projectmark(Info)                               # Determine the project mark    Info      = get_passed_failed(Info,mustpass,noresitlist)        # Determine which units are passed/failed    Info      = get_referred_units(Info)                            # Determine which units are referred (resit)    Info      = get_year_mark(Info)                                 # Determine average mark for the year    Info      = get_mp_year_mark(Info)                              # Determine math/physics marks separately for M+P students year mark    Info      = get_overall_mark(Info,doCF)                         # Get overall mark if CF available    Info      = get_status(Info)                                    # Determine status code for progression/degree, removing referred courses if failed        # For finalyear students only    if (Info.finalyear):        Info      = get_degclass(Info)                                  # Get degree classification        Info      = apply_promotion(Info)                               # Apply promotion for borderline students in final year        Info      = degclass_to_string(Info)                            # Convert degree classification into a string for output    # If requested (encode_sids == True) then encode them    if (encode_sids == True):        Info   = encode_emplid(Info)        all_sids.append(Info.emplid)        all_sids_encoded.append(Info.emplid_encoded)        #print(Info.emplid, Info.emplid_encoded)            dfout     = add_data_df(dfout,Info,doCF,encode_sids)                # Add data to final dataframe (including CF if doCF==True)    # testing    #print(Info.marksout)    #print(Info.codes)    #print(Info.credits)    #print(Info.credweights)    #print(Info.yearmark)    #if (anid == '10702304'): # Jodie Farrar    #if (anid == '10483154'): # Yang Dan    #if (anid == '10483022'): # BSc fail    #if (anid == '10479587'): # BSc fail    #    sys.exit(0)dfout     = apply_CFflags(dfout,df_CFflags,doCF)   # Add CF flags if availabledfout     = dfout.replace(np.nan, '', regex=True)  # Remove NaNsmaxunit   = get_maxunit_number(dfout)                                # Get maximum unit numbercolumns   = set_output_columns(Info, maxunit,doCF)                   # Set output columns for output spreadsheet depending on student type/classyear dfout     = sort_df(dfout,Info)                                      # Sort students by year mark (progressing) or overall mark (final year)dfout, nrows = add_codes_df(dfout)                                   # Add useful codes to end of spreadsheetdf_to_excel(dfout, columns, nrows, outfilename=outfilename,sheet_name='Sheet 1') # Output to excel spreadsheet# If encode_sids is set then output a lookup tableif (encode_sids == True):    data = np.column_stack([all_sids, all_sids_encoded])    sidfilename = outfilename.split('.xls')[0] + '_sids.txt'    np.savetxt(sidfilename, data, fmt=['%s ','%s'])# Final end statementsif (len(donotprocess) > 0):    print('Did not process (ignored) the following students:\n')    print(donotprocess)print('Final output written to {0:s}'.format(outfilename))############################################################################################### End of code##############################################################################################    